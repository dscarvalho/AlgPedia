{
    "about": "The MM algorithm is an iterative optimization method which exploits the convexity of a function in order to find their maxima or minima. The MM stands for \u201cMajorize-Minimization\u201d or \u201cMinorize-Maximization\u201d, depending on whether the desired optimization is a maximization or a minimization. MM itself is not an algorithm, but a description of how to construct an optimization algorithm.", 
    "name": "Mm Algorithm", 
    "classification": "Optimization Algorithms And Methods", 
    "full_text": "The MM algorithm is an iterative optimization method which exploits the convexity of a function in order to find their maxima or minima. The MM stands for \u201cMajorize-Minimization\u201d or \u201cMinorize-Maximization\u201d, depending on whether the desired optimization is a maximization or a minimization. MM itself is not an algorithm, but a description of how to construct an optimization algorithm.\nThe EM algorithm can be treated as a special case of the MM algorithm.[1] [2] However, in the EM algorithm conditional expectations are usually involved, while in the MM algorithm convexity and inequalities are the main focus, and it is easier to understand and apply in most cases.\n\n\nThe historical basis for the MM algorithm can be dated back to at least 1970, when Ortega and Rheinboldt were performing studies related to line search methods.[3] The same concept continued to reappear in different areas in different forms. In 2000, Hunter and Lange put forth \"MM\" as a general framework.[4] Recent studies have applied the method in a wide range of subject areas, such as mathematics, statistics, machine learning and engineering.\nThe MM algorithm works by finding a surrogate function that minorizes or majorizes the objective function. Optimizing the surrogate function will drive the objective function upward or downward until a local optimum is reached.\nTaking the minorize-maximization version, let \n\n\n\nf\n(\n\u03b8\n)\n\n\n{\\displaystyle f(\\theta )}\n\n be the objective concave function to be maximized. At the m step of the algorithm, \n\n\n\nm\n=\n0\n,\n1...\n\n\n{\\displaystyle m=0,1...}\n\n, the constructed function \n\n\n\ng\n(\n\u03b8\n\n|\n\n\n\u03b8\n\nm\n\n\n)\n\n\n{\\displaystyle g(\\theta |\\theta _{m})}\n\n will be called the minorized version of the objective function (the surrogate function) at \n\n\n\n\n\u03b8\n\nm\n\n\n\n\n{\\displaystyle \\theta _{m}}\n\n if\nThen, maximize \n\n\n\ng\n(\n\u03b8\n\n|\n\n\n\u03b8\n\nm\n\n\n)\n\n\n{\\displaystyle g(\\theta |\\theta _{m})}\n\n instead of \n\n\n\nf\n(\n\u03b8\n)\n\n\n{\\displaystyle f(\\theta )}\n\n, and let\nThe above iterative method will guarantee that \n\n\n\nf\n(\n\n\u03b8\n\nm\n\n\n)\n\n\n{\\displaystyle f(\\theta _{m})}\n\n will converge to a local optimum or a saddle point as m goes to infinity.[5] By the above construction\nThe marching of \n\n\n\n\n\u03b8\n\nm\n\n\n\n\n{\\displaystyle \\theta _{m}}\n\n and the surrogate functions relative to the objective function is shown in the figure.\nMajorize-Minimization is the same procedure but with a convex objective to be minimised.\nOne can use any inequality to construct the desired majorized/minorized version of the objective function. Typical choices include", 
    "dbpedia_url": "http://dbpedia.org/resource/MM_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/MM_algorithm\n"
}
{
    "about": "Search-based software engineering (SBSE) applies metaheuristic search techniques such as genetic algorithms, simulated annealing and tabu search to software engineering problems. Many activities in software engineering can be stated as optimization problems. Optimization techniques of operations research such as linear programming or dynamic programming are mostly impractical for large scale software engineering problems because of their computational complexity. Researchers and practitioners use metaheuristic search techniques to find near-optimal or \"good-enough\" solutions.", 
    "classification": "Optimization Algorithms And Methods", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Search-based_software_engineering\n", 
    "full_text": "Search-based software engineering (SBSE) applies metaheuristic search techniques such as genetic algorithms, simulated annealing and tabu search to software engineering problems. Many activities in software engineering can be stated as optimization problems. Optimization techniques of operations research such as linear programming or dynamic programming are mostly impractical for large scale software engineering problems because of their computational complexity. Researchers and practitioners use metaheuristic search techniques to find near-optimal or \"good-enough\" solutions.\nSBSE problems can be divided into two types:\n\n\nSBSE converts a software engineering problem into a computational search problem that can be tackled with a metaheuristic. This involves defining a search space, or the set of possible solutions. This space is typically too large to be explored exhaustively, suggesting a metaheuristic approach. A metric [2] (also called a fitness function, cost function, objective function or quality measure) is then used to measure the quality of potential solutions. Many software engineering problems can be reformulated as a computational search problem.[3]\nThe term \"search-based application\", in contrast, refers to using search engine technology, rather than search techniques, in another industrial application.\nOne of the earliest attempts to apply optimization to a software engineering problem was reported by Webb Miller and David Spooner in 1976 in the area of software testing.[4] In 1992, S.Xanthakis and his colleagues applied a search technique to a software engineering problem for the first time.[5] The term SBSE was first used in 2001 by Harman and Jones.[6] The research community grew to include more than 800 authors by 2013, spanning approximately 270 institutions in 40 countries.[citation needed]\nSearch-based software engineering is applicable to almost all phases of the software development process. Software testing has been one of the major applications.[7] Search techniques have been applied to other software engineering activities, for instance, requirements analysis,[8][9] design,[10] development,[11] and maintenance.[12]\nRequirements engineering is the process by which the needs of a software's users and environment are determined and managed. Search-based methods have been used for requirements selection and optimisation with the goal of finding the best possible subset of requirements that matches user requests amid constraints such as limited resources and interdependencies between requirements. This problem is often tackled as a multiple-criteria decision-making problem and, generally involves presenting the decision maker with a set of good compromises between cost and user satisfaction.[13][14]\nIdentifying a software bug (or a code smell) and then debugging (or refactoring) the software is largely a manual and labor-intensive endeavor, though the process is tool-supported. One objective of SBSE is to automatically identify and fix bugs (for example via mutation testing).\nGenetic programming, a biologically-inspired technique that involves evolving programs through the use of crossover and mutation, has been used to search for repairs to programs by altering a few lines of source code. The GenProg Evolutionary Program Repair software repaired 55 out of 105 bugs for approximately $8 each in one test.[15]\nCoevolution adopts a \"predator and prey\" metaphor in which a suite of programs and a suite of unit tests evolve together and influence each other.[16]\nSearch-based software engineering has been applied to software testing, including automatic generation of test cases (test data), test case minimization and test case prioritization. Regression testing has also received some attention.\nThe use of SBSE in program optimization, or modifying a piece of software to make it more efficient in terms of speed and resource use, has been the object of successful research. In one instance, a 50,000 line program was genetically improved, resulting in a program 70 times faster on average.[17]\nA number of decisions that are normally made by a project manager can be done automatically, for example, project scheduling.[18]\nAccording to the guide worldwide conhecimdo the PMBOK Guide in its 5th Edition, which provides guidelines for management of individual projects and defines concepts associated with project management. This also describes the life cycle of the project management and related processes, as well as the project life cycle.\nThe PMBOK Guide recognizes 47 processes that fall into five process groups and 10 knowledge areas that are typical in almost all project areas.\nEach knowledge area is a set of concepts, terms and activities that make up a project management expertise field. In the 5th PMBOK we have 10 knowledge areas, which are:[19][20][21]\nTools available for SBSE include OpenPAT.[22] and EvoSuite [23] and a code coverage measurement for Python[24]\nA number of methods and techniques are available, including:\nAs a relatively new area of research, SBSE does not yet experience broad industry acceptance. Software engineers are reluctant to adopt tools over which they have little control or that generate solutions that are unlike those that humans produce.[26] In the context of SBSE use in fixing or improving programs, developers need to be confident that any automatically produced modification does not generate unexpected behavior outside the scope of a system's requirements and testing environment. Considering that fully automated programming has yet to be achieved, a desirable property of such modifications would be that they need to be easily understood by humans to support maintenance activities.[27]\nAnother concern is that SBSE might make the software engineer redundant. Supporters claim that the motivation for SBSE is to enhance the relationship between the engineer and the program.[28]", 
    "name": "Search Based Software Engineering"
}
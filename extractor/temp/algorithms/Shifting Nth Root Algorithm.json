{
    "about": "The shifting nth root algorithm is an algorithm for extracting the nth root of a positive real number which proceeds iteratively by shifting in n digits of the radicand, starting with the most significant, and produces one digit of the root on each iteration, in a manner similar to long division.", 
    "name": "Shifting Nth Root Algorithm", 
    "classification": "Computer Arithmetic Algorithms", 
    "full_text": "The shifting nth root algorithm is an algorithm for extracting the nth root of a positive real number which proceeds iteratively by shifting in n digits of the radicand, starting with the most significant, and produces one digit of the root on each iteration, in a manner similar to long division.\n\n\nLet B be the base of the number system you are using, and n be the degree of the root to be extracted. Let x be the radicand processed thus far, y be the root extracted thus far, and r be the remainder. Let \u03b1 be the next n digits of the radicand, and \u03b2 be the next digit of the root. Let x' be the new value of x for the next iteration, y' be the new value of y for the next iteration, and r' be the new value of r for the next iteration. These are all integers.\nAt each iteration, the invariant \n\n\n\n\ny\n\nn\n\n\n+\nr\n=\nx\n\n\n{\\displaystyle y^{n}+r=x}\n\n will hold. The invariant \n\n\n\n(\ny\n+\n1\n\n)\n\nn\n\n\n>\nx\n\n\n{\\displaystyle (y+1)^{n}>x}\n\n will hold. Thus y is the largest integer less than or equal to the nth root of x, and r is the remainder.\nThe initial values of x, y, and r should be 0. The value of \u03b1 for the first iteration should be the most significant aligned block of n digits of the radicand. An aligned block of n digits means a block of digits aligned so that the decimal point falls between blocks. For example, in 123.4 the most significant aligned block of 2 digits is 01, the next most significant is 23, and the third most significant is 40.\nOn each iteration we shift in n digits of the radicand, so we have \n\n\n\n\nx\n\u2032\n\n=\n\nB\n\nn\n\n\nx\n+\n\u03b1\n\n\n{\\displaystyle x'=B^{n}x+\\alpha }\n\n and we produce 1 digit of the root, so we have \n\n\n\n\ny\n\u2032\n\n=\nB\ny\n+\n\u03b2\n\n\n{\\displaystyle y'=By+\\beta }\n\n. We want to choose \u03b2 and r' so that the invariants described above hold. It turns out that there is always exactly one such choice, as will be proved below.\nThe first invariant says that:\nor\nSo, pick the largest integer \u03b2 such that\nand let\nSuch a \u03b2 always exists, since if \n\n\n\n\u03b2\n=\n0\n\n\n{\\displaystyle \\beta =0}\n\n then the condition is \n\n\n\n\nB\n\nn\n\n\n\ny\n\nn\n\n\n\u2264\n\nB\n\nn\n\n\nx\n+\n\u03b1\n\n\n{\\displaystyle B^{n}y^{n}\\leq B^{n}x+\\alpha }\n\n, but \n\n\n\n\ny\n\nn\n\n\n\u2264\nx\n\n\n{\\displaystyle y^{n}\\leq x}\n\n, so this is always true. Also, \u03b2 must be less than B, since if \n\n\n\n\u03b2\n=\nB\n\n\n{\\displaystyle \\beta =B}\n\n then we would have\nbut the second invariant implies that\nand since \n\n\n\n\nB\n\nn\n\n\nx\n\n\n{\\displaystyle B^{n}x}\n\n and \n\n\n\n\nB\n\nn\n\n\n(\ny\n+\n1\n\n)\n\nn\n\n\n\n\n{\\displaystyle B^{n}(y+1)^{n}}\n\n are both multiples of \n\n\n\n\nB\n\nn\n\n\n\n\n{\\displaystyle B^{n}}\n\n the difference between them must be at least \n\n\n\n\nB\n\nn\n\n\n\n\n{\\displaystyle B^{n}}\n\n, and then we have\nbut \n\n\n\n0\n\u2264\n\u03b1\n<\n\nB\n\nn\n\n\n\n\n{\\displaystyle 0\\leq \\alpha <B^{n}}\n\n by definition of \u03b1, so this can't be true, and \n\n\n\n(\nB\ny\n+\n\u03b2\n\n)\n\nn\n\n\n\n\n{\\displaystyle (By+\\beta )^{n}}\n\n is a monotonically increasing function of \u03b2, so it can't be true for larger \u03b2 either, so we conclude that there exists an integer \u03b3 with \n\n\n\n\u03b3\n<\nB\n\n\n{\\displaystyle \\gamma <B}\n\n such that an integer r' with \n\n\n\n\nr\n\u2032\n\n\u2265\n0\n\n\n{\\displaystyle r'\\geq 0}\n\n exists such that the first invariant holds if and only if \n\n\n\n0\n\u2264\n\u03b2\n\u2264\n\u03b3\n\n\n{\\displaystyle 0\\leq \\beta \\leq \\gamma }\n\n.\nNow consider the second invariant. It says:\nor\nNow, if \u03b2 is not the largest admissible \u03b2 for the first invariant as described above, then \n\n\n\n\u03b2\n+\n1\n\n\n{\\displaystyle \\beta +1}\n\n is also admissible, and we have\nThis violates the second invariant, so to satisfy both invariants we must pick the largest \u03b2 allowed by the first invariant. Thus we have proven the existence and uniqueness of \u03b2 and r'.\nTo summarize, on each iteration:\nNow, note that \n\n\n\nx\n=\n\ny\n\nn\n\n\n+\nr\n\n\n{\\displaystyle x=y^{n}+r}\n\n, so the condition\nis equivalent to\nand\nis equivalent to\nThus, we don't actually need \n\n\n\nx\n\n\n{\\displaystyle x}\n\n, and since \n\n\n\nr\n=\nx\n\u2212\n\ny\n\nn\n\n\n\n\n{\\displaystyle r=x-y^{n}}\n\n and \n\n\n\nx\n<\n(\ny\n+\n1\n\n)\n\nn\n\n\n\n\n{\\displaystyle x<(y+1)^{n}}\n\n, \n\n\n\nr\n<\n(\ny\n+\n1\n\n)\n\nn\n\n\n\u2212\n\ny\n\nn\n\n\n\n\n{\\displaystyle r<(y+1)^{n}-y^{n}}\n\n or \n\n\n\nr\n<\nn\n\ny\n\nn\n\u2212\n1\n\n\n+\nO\n(\n\ny\n\nn\n\u2212\n2\n\n\n)\n\n\n{\\displaystyle r<ny^{n-1}+O(y^{n-2})}\n\n, or \n\n\n\nr\n<\nn\n\nx\n\n\n\nn\n\u2212\n1\n\nn\n\n\n\n+\nO\n(\n\nx\n\n\n\nn\n\u2212\n2\n\nn\n\n\n\n)\n\n\n{\\displaystyle r<nx^{{n-1} \\over n}+O(x^{{n-2} \\over n})}\n\n, so by using \n\n\n\nr\n\n\n{\\displaystyle r}\n\n instead of \n\n\n\nx\n\n\n{\\displaystyle x}\n\n we save time and space by a factor of 1/n. Also, the \n\n\n\n\nB\n\nn\n\n\n\ny\n\nn\n\n\n\n\n{\\displaystyle B^{n}y^{n}}\n\n we subtract in the new test cancels the one in \n\n\n\n(\nB\ny\n+\n\u03b2\n\n)\n\nn\n\n\n\n\n{\\displaystyle (By+\\beta )^{n}}\n\n, so now the highest power of y we have to evaluate is \n\n\n\n\ny\n\nn\n\u2212\n1\n\n\n\n\n{\\displaystyle y^{n-1}}\n\n rather than \n\n\n\n\ny\n\nn\n\n\n\n\n{\\displaystyle y^{n}}\n\n.\nAs noted above, this algorithm is similar to long division, and it lends itself to the same notation:\nNote that after the first iteration or two the leading term dominates the \n\n\n\n(\nB\ny\n+\n\u03b2\n\n)\n\nn\n\n\n\u2212\n\nB\n\nn\n\n\n\ny\n\nn\n\n\n\n\n{\\displaystyle (By+\\beta )^{n}-B^{n}y^{n}}\n\n, so we can get an often correct first guess at \u03b2 by dividing \n\n\n\n\nB\n\nn\n\n\nr\n+\n\u03b1\n\n\n{\\displaystyle B^{n}r+\\alpha }\n\n by \n\n\n\nn\n\nB\n\nn\n\u2212\n1\n\n\n\ny\n\nn\n\u2212\n1\n\n\n\n\n{\\displaystyle nB^{n-1}y^{n-1}}\n\n.\nOn each iteration, the most time-consuming task is to select \u03b2. We know that there are B possible values, so we can find \u03b2 using \n\n\n\nO\n(\nlog\n\u2061\n(\nB\n)\n)\n\n\n{\\displaystyle O(\\log(B))}\n\n comparisons. Each comparison will require evaluating \n\n\n\n(\nB\ny\n+\n\u03b2\n\n)\n\nn\n\n\n\u2212\n\nB\n\nn\n\n\n\ny\n\nn\n\n\n\n\n{\\displaystyle (By+\\beta )^{n}-B^{n}y^{n}}\n\n. In the kth iteration, y has k digits, and the polynomial can be evaluated with \n\n\n\n2\nn\n\u2212\n4\n\n\n{\\displaystyle 2n-4}\n\n multiplications of up to \n\n\n\nk\n(\nn\n\u2212\n1\n)\n\n\n{\\displaystyle k(n-1)}\n\n digits and \n\n\n\nn\n\u2212\n2\n\n\n{\\displaystyle n-2}\n\n additions of up to \n\n\n\nk\n(\nn\n\u2212\n1\n)\n\n\n{\\displaystyle k(n-1)}\n\n digits, once we know the powers of y and \u03b2 up through \n\n\n\nn\n\u2212\n1\n\n\n{\\displaystyle n-1}\n\n for y and n for \u03b2. \u03b2 has a restricted range, so we can get the powers of \u03b2 in constant time. We can get the powers of y with \n\n\n\nn\n\u2212\n2\n\n\n{\\displaystyle n-2}\n\n multiplications of up to \n\n\n\nk\n(\nn\n\u2212\n1\n)\n\n\n{\\displaystyle k(n-1)}\n\n digits. Assuming n-digit multiplication takes time \n\n\n\nO\n(\n\nn\n\n2\n\n\n)\n\n\n{\\displaystyle O(n^{2})}\n\n and addition takes time \n\n\n\nO\n(\nn\n)\n\n\n{\\displaystyle O(n)}\n\n, we take time \n\n\n\nO\n(\n\nk\n\n2\n\n\n\nn\n\n2\n\n\n)\n\n\n{\\displaystyle O(k^{2}n^{2})}\n\n for each comparison, or time \n\n\n\nO\n(\n\nk\n\n2\n\n\n\nn\n\n2\n\n\nlog\n\u2061\n(\nB\n)\n)\n\n\n{\\displaystyle O(k^{2}n^{2}\\log(B))}\n\n to pick \u03b2. The remainder of the algorithm is addition and subtraction that takes time \n\n\n\nO\n(\nk\n)\n\n\n{\\displaystyle O(k)}\n\n, so each iteration takes \n\n\n\nO\n(\n\nk\n\n2\n\n\n\nn\n\n2\n\n\nlog\n\u2061\n(\nB\n)\n)\n\n\n{\\displaystyle O(k^{2}n^{2}\\log(B))}\n\n. For all k digits, we need time \n\n\n\nO\n(\n\nk\n\n3\n\n\n\nn\n\n2\n\n\nlog\n\u2061\n(\nB\n)\n)\n\n\n{\\displaystyle O(k^{3}n^{2}\\log(B))}\n\n.\nThe only internal storage needed is r, which is \n\n\n\nO\n(\nk\n)\n\n\n{\\displaystyle O(k)}\n\n digits on the kth iteration. That this algorithm doesn't have bounded memory usage puts an upper bound on the number of digits which can be computed mentally, unlike the more elementary algorithms of arithmetic. Unfortunately, any bounded memory state machine with periodic inputs can only produce periodic outputs, so there are no such algorithms which can compute irrational numbers from rational ones, and thus no bounded memory root extraction algorithms.\nNote that increasing the base increases the time needed to pick \u03b2 by a factor of \n\n\n\nO\n(\nlog\n\u2061\n(\nB\n)\n)\n\n\n{\\displaystyle O(\\log(B))}\n\n, but decreases the number of digits needed to achieve a given precision by the same factor, and since the algorithm is cubic time in the number of digits, increasing the base gives an overall speedup of \n\n\n\nO\n(\n\nlog\n\n2\n\n\n\u2061\n(\nB\n)\n)\n\n\n{\\displaystyle O(\\log ^{2}(B))}\n\n. When the base is larger than the radicand, the algorithm degenerates to binary search, so it follows that this algorithm is not useful for computing roots with a computer, as it is always outperformed by much simpler binary search, and has the same memory complexity.", 
    "dbpedia_url": "http://dbpedia.org/resource/Shifting_nth_root_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Shifting_nth_root_algorithm\n"
}
{
    "about": "In modular arithmetic computation, Montgomery modular multiplication, more commonly referred to as Montgomery multiplication, is a method for performing fast modular multiplication. It was introduced in 1985 by the American mathematician Peter L. Montgomery.[1][2]", 
    "name": "Montgomery Modular Multiplication", 
    "classification": "Cryptographic Algorithms", 
    "full_text": "In modular arithmetic computation, Montgomery modular multiplication, more commonly referred to as Montgomery multiplication, is a method for performing fast modular multiplication. It was introduced in 1985 by the American mathematician Peter L. Montgomery.[1][2]\nGiven two integers a and b and module N, the classical modular multiplication algorithm computes ab mod N. Montgomery multiplication works by transforming a and b into a representation known as Montgomery form. For a modulus N, the Montgomery form of a is defined to be aR mod N for some constant R depending only on N and the underlying computer architecture. If aR mod N and bR mod N are the Montgomery forms of a and b, then their Montgomery product is abR mod N. Montgomery multiplication is a fast algorithm to compute the Montgomery product. Transforming the result out of Montgomery form yields the classical modular product ab mod N.\nBecause of the overhead involved in converting a and b into Montgomery form, computing a single product by Montgomery multiplication is slower than computing the product in the integers and performing a modular reduction by division or Barrett reduction. However, when many products are required, as in modular exponentiation, the conversion to Montgomery form becomes a negligible fraction of the time of the computation, and performing the computation by Montgomery multiplication is faster than the available alternatives. Many important cryptosystems such as RSA and Diffie\u2013Hellman key exchange are based on arithmetic operations modulo a large number, and for these cryptosystems, the increased speed afforded by Montgomery multiplication can be important in practice.[3]\n\n\nLet N denote a positive integer modulus. The quotient ring Z/NZ consists of residue classes modulo N, that is, its elements are sets of the form\nwhere a ranges across the integers. Each residue class is a set of integers such that the difference of any two integers in the set is divisible by N (and the residue class is maximal with respect to that property; integers aren't left out of the residue class unless they would violate the divisibility condition). The residue class corresponding to a is denoted a. Equality of residue classes is called congruence and is denoted\nStoring an entire residue class on a computer is impossible because the residue class has infinitely many elements. Instead, residue classes are stored as representatives. Conventionally, these representatives are the integers a for which 0 \u2264 a \u2264 N \u2212 1. If a is an integer, then the representative of a is written a mod N. When writing congruences, it is common to identify an integer with the residue class it represents. With this convention, the above equality is written a \u2261 b mod N.\nArithmetic on residue classes is done by first performing integer arithmetic on their representatives. The output of the integer operation determines a residue class, and the output of the modular operation is determined by computing the residue class's representative. For example, if N = 17, then the sum of the residue classes 7 and 15 is computed by finding the integer sum 7 + 15 = 22, then determining 22 mod 17, the integer between 0 and 16 whose difference with 22 is a multiple of 17. In this case, that integer is 5, so 7 + 15 \u2261 5 mod 17.\nIf a and b are integers in the range [0, N \u2212 1], then their sum is in the range [0, 2N \u2212 2] and their difference is in the range [\u2212N + 1, N \u2212 1], so determining the representative in [0, N \u2212 1] requires at most one subtraction or addition (respectively) of N. However, the product ab is in the range [0, N2 \u2212 2N + 1]. Storing the intermediate integer product ab requires twice as many bits as either a or b, and efficiently determining the representative in [0, N \u2212 1] requires division. Mathematically, the integer between 0 and N \u2212 1 that is congruent to ab can be expressed by applying the Euclidean division theorem:\nwhere q is the quotient \n\n\n\n\u230a\na\nb\n\n/\n\nN\n\u230b\n\n\n{\\displaystyle \\lfloor ab/N\\rfloor }\n\n and r, the remainder, is in the interval [0, N \u2212 1]. The remainder r is ab mod N. Determining r can be done by computing q, then subtracting qN from ab. For example, the product 7 \u22c5 15 is determined by computing \n\n\n\n7\n\u22c5\n15\n=\n105\n\n\n{\\displaystyle 7\\cdot 15=105}\n\n, dividing \n\n\n\n\u230a\n105\n\n/\n\n17\n\u230b\n=\n6\n\n\n{\\displaystyle \\lfloor 105/17\\rfloor =6}\n\n, and subtracting \n\n\n\n105\n\u2212\n6\n\u22c5\n17\n=\n105\n\u2212\n102\n=\n3\n\n\n{\\displaystyle 105-6\\cdot 17=105-102=3}\n\n.\nBecause the computation of q requires division, it is undesirably expensive on most computer hardware. Montgomery form is a different way of expressing the elements of the ring in which modular products can be computed without expensive divisions. While divisions are still necessary, they can be done with respect to a different divisor R. This divisor can be chosen to be a power of two, for which division can be replaced by shifting, or a whole number of machine words, for which division can be replaced by omitting words. These divisions are fast, so most of the cost of computing modular products using Montgomery form is the cost of computing ordinary products.\nThe auxiliary modulus R must be a positive integer such that gcd(N, R) = 1. For computational purposes it is also necessary that division and reduction modulo R be inexpensive, and the modulus is not useful for modular multiplication unless R > N. The Montgomery form or Montgomery representation of the residue class a with respect to R is aR mod N, that is, it is the representative of the residue class aR. For example, suppose that N = 17 and that R = 100. The Montgomery forms of 3, 5, 7, and 15 are 300 mod 17 = 11, 500 mod 17 = 7, 700 mod 17 = 3, and 1500 mod 17 = 4.\nAddition and subtraction in Montgomery form are the same as ordinary modular addition and subtraction because of the distributive law:\nThis is a consequence of the fact that, because gcd(R, N) = 1, multiplication by R is an isomorphism on the additive group Z/NZ. For example, (7 + 15) mod 17 = 5, which in Montgomery form becomes (3 + 4) mod 17 = 7.\nMultiplication in Montgomery form, however, is seemingly more complicated. The usual product of aR and bR does not represent the product of a and b because it has an extra factor of R:\nComputing products in Montgomery form requires removing the extra factor of R. While division by R is cheap, the intermediate product (aR mod N)(bR mod N) is not divisible by R because the modulo operation has destroyed that property. So for instance, the product of the Montgomery forms of 7 and 15 modulo 17 is the product of 3 and 4, which is 12. Since 12 is not divisible by 100, additional effort is required to remove the extra factor of R.\nRemoving the extra factor of R can be done by multiplying by an integer R\u2032 such that \n\n\n\nR\n\nR\n\u2032\n\n\u2261\n1\n\n\n(\nmod\n\nN\n)\n\n\n\n{\\displaystyle RR'\\equiv 1{\\pmod {N}}}\n\n, that is, by an R\u2032 whose residue class is the modular inverse of R mod N. Then, working modulo N,\nThe integer R\u2032 exists because of the assumption that R and N are coprime. It can be constructed using the extended Euclidean algorithm. The extended Euclidean algorithm efficiently determines integers R\u2032 and N\u2032 that satisfy B\u00e9zout's identity: 0 < R\u2032 < N, 0 < N\u2032 < R, and:\nThis shows that it is possible to do multiplication in Montgomery form. A straightforward algorithm to multiply numbers in Montgomery form is therefore to multiply aR mod N, bR mod N, and R\u2032 as integers and reduce modulo N.\nFor example, to multiply 7 and 15 modulo 17 in Montgomery form, again with R = 100, compute the product of 3 and 4 to get 12 as above. The extended Euclidean algorithm implies that 8\u22c5100 \u2212 47\u22c517 = 1, so R\u2032 = 8. Multiply 12 by 8 to get 96 and reduce modulo 17 to get 11. This is the Montgomery form of 3, as expected.\nWhile the above algorithm is correct, it is slower than multiplication in the standard representation because of the need to multiply by R\u2032 and divide by N. Montgomery reduction, also known as REDC, is an algorithm that simultaneously computes the product by R\u2032 and reduces modulo N more quickly than the naive method. The speed is because all computations are done using only reduction and divisions with respect to R, not N:\nTo see that this algorithm is correct, first observe that m is chosen precisely so that T + mN is divisible by R. A number is divisible by R if and only if it is congruent to zero mod R, and we have:\nTherefore, t is an integer. Second, the output is either t or t \u2212 N, both of which are congruent to t mod N, so prove that the output is congruent to TR\u22121 mod N, it suffices to prove that t is. Modulo N, t satisfies:\nTherefore, the output has the correct residue class. Third, m is in [0, R \u2212 1], and therefore T + mN is between 0 and (RN \u2212 1) + (R \u2212 1)N < 2RN. Hence t is less than 2N, and because it's an integer, this puts t in the range [0, 2N \u2212 1]. Therefore, reducing t into the desired range requires at most a single subtraction, so the algorithm's output lies in the correct range.\nTo use REDC to compute the product of 7 and 15 modulo 17, first convert to Montgomery form and multiply as integers to get 12 as above. Then apply REDC with R = 100, N = 17, N\u2032 = 47, and T = 12. The first step sets m to 12 \u22c5 47 mod 100 = 64. The second step sets t to (12 + 64 \u22c5 17) / 100. Notice that 12 + 64 \u22c5 17 is 1100, a multiple of 100 as expected. t is set to 11, which is less than 17, so the final result is 11, which agrees with the computation of the previous section.\nAs another example, consider the product 7 \u22c5 15 mod 17 but with R = 10. Using the extended Euclidean algorithm, compute \u22125 \u22c5 10 + 3 \u22c5 17 = 1, so N\u2032 will be \u22123 mod 10 = 7. The Montgomery forms of 7 and 15 are 70 mod 17 = 2 and 150 mod 17 = 14, respectively. Their product 28 is the input T to REDC, and since 28 < RN = 170, the assumptions of REDC are satisfied. To run REDC, set m to (28 mod 10) \u22c5 7 mod 10 = 196 mod 10 = 6. Then 28 + 6 \u22c5 17 = 130, so t = 13. Because 30 mod 17 = 13, this is the Montgomery form of 3 = 7 \u22c5 15 mod 17.\nMany operations of interest modulo N can be expressed equally well in Montgomery form. Addition, subtraction, negation, comparison for equality, multiplication by an integer not in Montgomery form, and greatest common divisors with N may all be done with the standard algorithms. The Jacobi symbol can be calculated as \n\n\n\n(\n\n\n\na\nN\n\n\n\n)\n=\n(\n\n\n\n\na\nR\n\nN\n\n\n\n)\n\n/\n\n(\n\n\n\nR\nN\n\n\n\n)\n\n\n{\\displaystyle ({\\tfrac {a}{N}})=({\\tfrac {aR}{N}})/({\\tfrac {R}{N}})}\n\n as long as (R/N) is stored.\nWhen R > N, most other arithmetic operations can be expressed in terms of REDC. This assumption implies that the product of two representatives mod N is less than RN, the exact hypothesis necessary for REDC to generate correct output. In particular, the product of aR mod N and bR mod N is REDC((aR mod N)(bR mod N)). The combined operation of multiplication and REDC is often called Montgomery multiplication.\nConversion into Montgomery form is done by computing REDC((a mod N)(R2 mod N)). Conversion out of Montgomery form is done by computing REDC(aR mod N). The modular inverse of aR mod N is REDC((aR mod N)\u22121(R3 mod N)). Modular exponentiation can be done using exponentiation by squaring by initializing the initial product to the Montgomery representation of 1, that is, to R mod N, and by replacing the multiply and square steps by Montgomery multiplies.\nPerforming these operations requires knowing at least N\u2032 and R2 mod N. When R is a power of a small positive integer b, N\u2032 can be computed by Hensel's lemma: The inverse of N modulo b is computed by a naive algorithm (for instance, if b = 2 then the inverse is 1), and Hensel's lemma is used repeatedly to find the inverse modulo higher and higher powers of b, stopping when the inverse modulo R is known; N\u2032 is the negation of this inverse. The constants R mod N and R3 mod N can be generated as REDC(R2 mod N) and as REDC((R2 mod N)(R2 mod N)). The fundamental operation is to compute REDC of a product. When standalone REDC is needed, it can be computed as REDC of a product with 1 mod N. The only place where a direct reduction modulo N is necessary is in the precomputation of R2 mod N.\nMost cryptographic applications require numbers that are hundreds or even thousands of bits long. Such numbers are too large to be stored in a single machine word. Typically, the hardware performs multiplication mod some base B, so performing larger multiplications requires combining several small multiplications. The base B is typically 2 for microelectronic applications, 28 for 8-bit firmware,[4] or 232 or 264 for software applications.\nThe REDC algorithm requires products modulo R, and typically R > N so that REDC can be used to compute products. However, when R is a power of B, there is a variant of REDC which requires products only of machine word sized integers. Suppose that positive multi-precision integers are stored little endian, that is, x is stored as an array x[0], ..., x[\u2113 - 1] such that 0 \u2264 x[i] < B for all i and x = \u2211 x[i] Bi. The algorithm begins with a multiprecision integer T and reduces it one word at a time. First an appropriate multiple of N is added to make T divisible by B. Then a multiple of N is added to make T divisible by B2, and so on. Eventually T is divisible by R, and after division by R the algorithm is in the same place as REDC was after the computation of t.\nThe final comparison and subtraction is done by the standard algorithms.\nThe above algorithm is correct for essentially the same reasons that REDC is correct. Each time through the i loop, m is chosen so that T[i] + mN[0] is divisible by B. Then mNBi is added to T. Because this quantity is zero mod N, adding it does not affect the value of T mod N. If mi denotes the value of m computed in the ith iteration of the loop, then the algorithm sets S to T + (\u2211 mi Bi)N. Because MultiPrecisionREDC and REDC produce the same output, this sum is the same as the choice of m that the REDC algorithm would make.\nThe last word of T, T[r + p + 1], is used only to hold a carry, and so consequently it is either zero or one. Depending upon the processor, it may be possible to store this word as a carry flag instead of a full-sized word.\nIt is possible to combine multiprecision multiplication and REDC into a single algorithm. This combined algorithm is usually called Montgomery multiplication. Several different implementations are described by Ko\u00e7, Acar, and Kaliski.[5] The algorithm may use as little as p + 2 words of storage (plus a carry bit).\nAs an example, let B = 10, N = 997, and R = 1000. Suppose that a = 314 and b = 271. The Montgomery representations of a and b are 314000 mod 997 = 942 and 271000 mod 997 = 813. Compute 942 \u22c5 813 = 765846. The initial input T to MultiPrecisionREDC will be [6, 4, 8, 5, 6, 7]. The number N will be represented as [7, 9, 9]. The extended Euclidean algorithm says that \u2212299 \u22c5 10 + 3 \u22c5 997 = 1, so N\u2032 will be 7.\nTherefore, before the final comparison and subtraction, S = 1047. The final subtraction yields the number 50. Since the Montgomery representation of 314 \u22c5 271 mod 997 = 349 is 349000 mod 997 = 50, this is the expected result.\nWhen working in base 2, determining the correct m at each stage is particularly easy: If the current working bit is even, then m is zero and if it's odd, then m is one. Furthermore, because each step of MultiPrecisionREDC requires knowing only the lowest bit, Montgomery multiplication can be easily combined with a carry-save adder.\nWhen using it as a part of a cryptographically secure algorithm, unmodified Montgomery reduction is vulnerable to side channel attacks, where the attacker can learn about the inner workings of the algorithm by studying the differences in time, power-consumption or any other parameter affected by the fact that the algorithm performs very different actions depending on the input. However it is simple to modify the algorithm or the hardware to make it resistant to such attacks.[4][6]", 
    "dbpedia_url": "http://dbpedia.org/resource/Montgomery_modular_multiplication", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Montgomery_modular_multiplication\n"
}
{
    "about": "The activity selection problem is a combinatorial optimization problem concerning the selection of non-conflicting activities to perform within a given time frame, given a set of activities each marked by a start time (si) and finish time (fi). The problem is to select the maximum number of activities that can be performed by a single person or machine, assuming that a person can only work on a single activity at a time.", 
    "name": "Activity Selection Problem", 
    "classification": "Scheduling Algorithms", 
    "full_text": "The activity selection problem is a combinatorial optimization problem concerning the selection of non-conflicting activities to perform within a given time frame, given a set of activities each marked by a start time (si) and finish time (fi). The problem is to select the maximum number of activities that can be performed by a single person or machine, assuming that a person can only work on a single activity at a time.\nA classic application of this problem is in scheduling a room for multiple competing events, each having its own time requirements (start and end time), and many more arise within the framework of operations research.\n\n\nAssume there exist n activities with each of them being represented by a start time si and finish time fi. Two activities i and j are said to be non-conflicting if si \u2265 fj or sj \u2265 fi. The activity selection problem consists in finding the maximal solution set (S) of non-conflicting activities, or more precisely there must exist no solution set S' such that |S'| > |S| in the case that multiple maximal solutions have equal sizes.\nThe activity selection problem is notable in that using a greedy algorithm to find a solution will always result in an optimal solution. A pseudocode sketch of the iterative version of the algorithm and a proof of the optimality of its result are included below.\nLine 1: This algorithm is called Greedy-Iterative-Activity-Selector, because it is first of all a greedy algorithm, and then it is iterative. There's also a recursive version of this greedy algorithm.\nNote that these arrays are indexed starting from 1 up to the length of the corresponding array.\nLine 3: Sorts in increasing order of finish times the array of activities \n\n\n\nA\n\n\n{\\displaystyle A}\n\n by using the finish times stored in the array \n\n\n\nf\n\n\n{\\displaystyle f}\n\n. This operation can be done in \n\n\n\nO\n(\nn\n\u22c5\n\nlog\n\n2\n\n\n\u2061\nn\n)\n\n\n{\\displaystyle O(n\\cdot \\log _{2}n)}\n\n time, using for example merge sort, heap sort, or quick sort algorithms.\nLine 5: Creates a set \n\n\n\nS\n\n\n{\\displaystyle S}\n\n to store the selected activities, and initialises it with the first activity \n\n\n\nA\n[\n1\n]\n\n\n{\\displaystyle A[1]}\n\n. Note that, since the \n\n\n\nA\n\n\n{\\displaystyle A}\n\n has already been sorted according to the finish times in \n\n\n\nf\n\n\n{\\displaystyle f}\n\n, \n\n\n\nA\n[\n1\n]\n\n\n{\\displaystyle A[1]}\n\n is the activity with the smallest finish time.\nLine 6: Creates a variable \n\n\n\nk\n\n\n{\\displaystyle k}\n\n that keeps track of the index of the last selected activity.\nLine 10: Starts iterating from the second element of that array \n\n\n\nA\n\n\n{\\displaystyle A}\n\n up to its last element.\nLine 11: If the start time \n\n\n\ns\n[\ni\n]\n\n\n{\\displaystyle s[i]}\n\n of the \n\n\n\ni\nt\nh\n\n\n{\\displaystyle ith}\n\n activity (\n\n\n\nA\n[\ni\n]\n\n\n{\\displaystyle A[i]}\n\n) is greater or equal to the finish time \n\n\n\nf\n[\nk\n]\n\n\n{\\displaystyle f[k]}\n\n of the last selected activity (\n\n\n\nA\n[\nk\n]\n\n\n{\\displaystyle A[k]}\n\n), then \n\n\n\nA\n[\ni\n]\n\n\n{\\displaystyle A[i]}\n\n is compatible to the selected activities in the set \n\n\n\nS\n\n\n{\\displaystyle S}\n\n, and thus it can be added to \n\n\n\nS\n\n\n{\\displaystyle S}\n\n; this is what is done in line 12.\nLine 13: The index of the last selected activity is updated to the just added activity \n\n\n\nA\n[\ni\n]\n\n\n{\\displaystyle A[i]}\n\n.\nLet \n\n\n\nS\n=\n{\n1\n,\n2\n,\n\u2026\n,\nn\n}\n\n\n{\\displaystyle S=\\{1,2,\\ldots ,n\\}}\n\n be the set of activities ordered by finish time. Thus activity 1 has the earliest finish time.\nSuppose A is a subset of S and is an optimal solution, and let activities in A be ordered by finish time. Suppose that the first activity in A is k \u2260 1, that is, this optimal solution does not start with the \"greedy choice.\" We want to show that there is another solution B that begins with the greedy choice, activity 1.\nLet \n\n\n\nB\n=\n(\nA\n\u2216\n{\nk\n}\n)\n\u222a\n{\n1\n}\n\n\n{\\displaystyle B=(A\\setminus \\{k\\})\\cup \\{1\\}}\n\n. Because \n\n\n\n\nf\n\n1\n\n\n\u2264\n\nf\n\nk\n\n\n\n\n{\\displaystyle f_{1}\\leq f_{k}}\n\n, the activities in B are disjoint and since B has same number of activities as A, i.e., |A| = |B|, B is also optimal.\nOnce the greedy choice is made, the problem reduces to finding an optimal solution for the subproblem. If A is an optimal solution to the original problem S, then \n\n\n\n\nA\n\n\u2032\n\n\n=\nA\n\u2216\n{\n1\n}\n\n\n{\\displaystyle A^{\\prime }=A\\setminus \\{1\\}}\n\n is an optimal solution to the activity-selection problem \n\n\n\n\nS\n\u2032\n\n=\n{\ni\n\u2208\nS\n:\n\ns\n\ni\n\n\n\u2265\n\nf\n\n1\n\n\n}\n\n\n{\\displaystyle S'=\\{i\\in S:s_{i}\\geq f_{1}\\}}\n\n.\nWhy? If we could find a solution B\u2032 to S\u2032 with more activities then A\u2032, adding 1 to B\u2032 would yield a solution B to S with more activities than A, contradicting the optimality.\nThe generalized version of the activity selection problem involves selecting an optimal set of non-overlapping activities such that the total weight is maximized. Unlike the unweighted version, there is no greedy solution to the weighted activity selection problem. However, a dynamic programming solution can readily be formed using the following approach:[1]\nConsider an optimal solution containing activity \n\n\n\nk\n\n\n{\\displaystyle k}\n\n. We now have non-overlapping activities on the left and right of \n\n\n\nk\n\n\n{\\displaystyle k}\n\n. We can recursively find solutions for these two sets because of optimal sub-structure. As we don't know \n\n\n\nk\n\n\n{\\displaystyle k}\n\n, we can try each of the activities. This approach leads to an \n\n\n\nO\n(\n\nn\n\n3\n\n\n)\n\n\n{\\displaystyle O(n^{3})}\n\n solution. This can be optimized further considering that for each set of activities in \n\n\n\n(\ni\n,\nj\n)\n\n\n{\\displaystyle (i,j)}\n\n, we can find the optimal solution if we had known the solution for \n\n\n\n(\ni\n,\nt\n)\n\n\n{\\displaystyle (i,t)}\n\n, where \n\n\n\nt\n\n\n{\\displaystyle t}\n\n is the last non-overlapping interval with \n\n\n\nj\n\n\n{\\displaystyle j}\n\n in \n\n\n\n(\ni\n,\nj\n)\n\n\n{\\displaystyle (i,j)}\n\n. This yields an \n\n\n\nO\n(\n\nn\n\n2\n\n\n)\n\n\n{\\displaystyle O(n^{2})}\n\n solution. This can be further optimized considering the fact that we do not need to consider all ranges \n\n\n\n(\ni\n,\nj\n)\n\n\n{\\displaystyle (i,j)}\n\n but instead just \n\n\n\n(\n1\n,\nj\n)\n\n\n{\\displaystyle (1,j)}\n\n. The following algorithm thus yields an \n\n\n\nO\n(\nn\nlog\n\u2061\nn\n)\n\n\n{\\displaystyle O(n\\log n)}\n\n solution:", 
    "dbpedia_url": "http://dbpedia.org/resource/Activity_selection_problem", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Activity_selection_problem\n"
}
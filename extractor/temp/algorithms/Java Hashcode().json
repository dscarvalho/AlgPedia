{
    "about": "In the Java programming language, every class implicitly or explicitly provides a hashCode() method, which digests the data stored in an instance of the class into a single hash value (a 32-bit signed integer). This hash is used by other code when storing or manipulating the instance \u2013 the values are intended to be evenly distributed for varied inputs for use in clustering. This property is important to the performance of hash tables and other data structures that store objects in groups (\"buckets\") based on their computed hash values. Technically, in Java, hashCode() by default is a native method, meaning, it has the modifier 'native', as it is implemented directly in the native code in the JVM.", 
    "name": "Java Hashcode()", 
    "classification": "Checksum Algorithms", 
    "full_text": "In the Java programming language, every class implicitly or explicitly provides a hashCode() method, which digests the data stored in an instance of the class into a single hash value (a 32-bit signed integer). This hash is used by other code when storing or manipulating the instance \u2013 the values are intended to be evenly distributed for varied inputs for use in clustering. This property is important to the performance of hash tables and other data structures that store objects in groups (\"buckets\") based on their computed hash values. Technically, in Java, hashCode() by default is a native method, meaning, it has the modifier 'native', as it is implemented directly in the native code in the JVM.\n\n\nAll the classes inherit a basic hash scheme from the fundamental base class java.lang.Object, but instead many override this to provide a hash function that better handles their specific data. Classes which provide their own implementation must override the object method public int hashCode().\nThe general contract for overridden implementations of this method is that they behave in a way consistent with the same object's equals() method: that a given object must consistently report the same hash value (unless it is changed so that the new version is no longer considered \"equal\" to the old), and that two objects which equals() says are equal must report the same hash value. There's no requirement that hash values be consistent between different Java implementations, or even between different execution runs of the same program, and while two unequal objects having different hashes is very desirable, this is not mandatory (that is, the hash function implemented doesn't need to be a perfect hash).[1]\nFor example, the class Employee might implement its hash function by composing the hashes of its members:\nIn an attempt to provide a fast implementation, early versions of the Java String class provided a hashCode() implementation that considered at most 16 characters picked from the string. For some common data this worked very poorly, delivering unacceptably clustered results and consequently slow hashtable performance.[2]\nFrom Java 1.2, java.lang.String class implements its hashCode() using a product sum algorithm over the entire text of the string.[2] An instance s of the java.lang.String class, for example, would have a hash code \n\n\n\nh\n(\ns\n)\n\n\n{\\displaystyle h(s)}\n\n defined by\nwhere terms are summed using Java 32-bit int addition, \n\n\n\ns\n\n[\n\ni\n\n]\n\n\n\n{\\displaystyle s\\left[\\,i\\,\\right]}\n\n denotes the ASCII code of the \n\n\n\ni\n\n\n{\\displaystyle i}\n\nth character of the string, and \n\n\n\nn\n\n\n{\\displaystyle n}\n\n is the length of s.[3] [4]", 
    "dbpedia_url": "http://dbpedia.org/resource/Java_hashCode()", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Java_hashCode()\n"
}
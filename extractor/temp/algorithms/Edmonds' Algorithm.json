{
    "about": "In graph theory, Edmonds' algorithm or Chu\u2013Liu/Edmonds' algorithm is an algorithm for finding a spanning arborescence of minimum weight (sometimes called an optimum branching). It is the directed analog of the minimum spanning tree problem. The algorithm was proposed independently first by Yoeng-Jin Chu and Tseng-Hong Liu (1965) and then by Jack Edmonds (1967).", 
    "name": "Edmonds' Algorithm", 
    "classification": "Graph Algorithms", 
    "full_text": "In graph theory, Edmonds' algorithm or Chu\u2013Liu/Edmonds' algorithm is an algorithm for finding a spanning arborescence of minimum weight (sometimes called an optimum branching). It is the directed analog of the minimum spanning tree problem. The algorithm was proposed independently first by Yoeng-Jin Chu and Tseng-Hong Liu (1965) and then by Jack Edmonds (1967).\n\n\nThe algorithm takes as input a directed graph \n\n\n\nD\n=\n\u27e8\nV\n,\nE\n\u27e9\n\n\n{\\displaystyle D=\\langle V,E\\rangle }\n\n where \n\n\n\nV\n\n\n{\\displaystyle V}\n\n is the set of nodes and \n\n\n\nE\n\n\n{\\displaystyle E}\n\n is the set of directed edges, a distinguished vertex \n\n\n\nr\n\u2208\nV\n\n\n{\\displaystyle r\\in V}\n\n called the root, and a real-valued weight \n\n\n\nw\n(\ne\n)\n\n\n{\\displaystyle w(e)}\n\n for each edge \n\n\n\ne\n\u2208\nE\n\n\n{\\displaystyle e\\in E}\n\n. It returns a spanning arborescence \n\n\n\nA\n\n\n{\\displaystyle A}\n\n rooted at \n\n\n\nr\n\n\n{\\displaystyle r}\n\n of minimum weight, where the weight of an arborescence is defined to be the sum of its edge weights, \n\n\n\nw\n(\nA\n)\n=\n\n\u2211\n\ne\n\u2208\nA\n\n\n\nw\n(\ne\n)\n\n\n\n{\\displaystyle w(A)=\\sum _{e\\in A}{w(e)}}\n\n.\nThe algorithm has a recursive description. Let \n\n\n\nf\n(\nD\n,\nr\n,\nw\n)\n\n\n{\\displaystyle f(D,r,w)}\n\n denote the function which returns a spanning arborescence rooted at \n\n\n\nr\n\n\n{\\displaystyle r}\n\n of minimum weight. We first remove any edge from \n\n\n\nE\n\n\n{\\displaystyle E}\n\n whose destination is \n\n\n\nr\n\n\n{\\displaystyle r}\n\n. We may also replace any set of parallel edges (edges between the same pair of vertices in the same direction) by a single edge with weight equal to the minimum of the weights of these parallel edges.\nNow, for each node \n\n\n\nv\n\n\n{\\displaystyle v}\n\n other than the root, find the edge incoming to \n\n\n\nv\n\n\n{\\displaystyle v}\n\n of lowest weight (with ties broken arbitrarily). Denote the source of this edge by \n\n\n\n\u03c0\n(\nv\n)\n\n\n{\\displaystyle \\pi (v)}\n\n. If the set of edges \n\n\n\nP\n=\n{\n(\n\u03c0\n(\nv\n)\n,\nv\n)\n\u2223\nv\n\u2208\nV\n\u2216\n{\nr\n}\n}\n\n\n{\\displaystyle P=\\{(\\pi (v),v)\\mid v\\in V\\setminus \\{r\\}\\}}\n\n does not contain any cycles, then \n\n\n\nf\n(\nD\n,\nr\n,\nw\n)\n=\nP\n\n\n{\\displaystyle f(D,r,w)=P}\n\n.\nOtherwise, \n\n\n\nP\n\n\n{\\displaystyle P}\n\n contains at least one cycle. Arbitrarily choose one of these cycles and call it \n\n\n\nC\n\n\n{\\displaystyle C}\n\n. We now define a new weighted directed graph \n\n\n\n\nD\n\n\u2032\n\n\n=\n\u27e8\n\nV\n\n\u2032\n\n\n,\n\nE\n\n\u2032\n\n\n\u27e9\n\n\n{\\displaystyle D^{\\prime }=\\langle V^{\\prime },E^{\\prime }\\rangle }\n\n in which the cycle \n\n\n\nC\n\n\n{\\displaystyle C}\n\n is \"contracted\" into one node as follows:\nThe nodes of \n\n\n\n\nV\n\n\u2032\n\n\n\n\n{\\displaystyle V^{\\prime }}\n\n are the nodes of \n\n\n\nV\n\n\n{\\displaystyle V}\n\n not in \n\n\n\nC\n\n\n{\\displaystyle C}\n\n plus a new node denoted \n\n\n\n\nv\n\nC\n\n\n\n\n{\\displaystyle v_{C}}\n\n.\nFor each edge in \n\n\n\n\nE\n\n\u2032\n\n\n\n\n{\\displaystyle E^{\\prime }}\n\n, we remember which edge in \n\n\n\nE\n\n\n{\\displaystyle E}\n\n it corresponds to.\nNow find a minimum spanning arborescence \n\n\n\n\nA\n\n\u2032\n\n\n\n\n{\\displaystyle A^{\\prime }}\n\n of \n\n\n\n\nD\n\n\u2032\n\n\n\n\n{\\displaystyle D^{\\prime }}\n\n using a call to \n\n\n\nf\n(\n\nD\n\n\u2032\n\n\n,\nr\n,\n\nw\n\n\u2032\n\n\n)\n\n\n{\\displaystyle f(D^{\\prime },r,w^{\\prime })}\n\n. Since \n\n\n\n\nA\n\n\u2032\n\n\n\n\n{\\displaystyle A^{\\prime }}\n\n is a spanning arborescence, each vertex has exactly one incoming edge. Let \n\n\n\n(\nu\n,\n\nv\n\nC\n\n\n)\n\n\n{\\displaystyle (u,v_{C})}\n\n be the unique incoming edge to \n\n\n\n\nv\n\nC\n\n\n\n\n{\\displaystyle v_{C}}\n\n in \n\n\n\n\nA\n\n\u2032\n\n\n\n\n{\\displaystyle A^{\\prime }}\n\n. This edge corresponds to an edge \n\n\n\n(\nu\n,\nv\n)\n\u2208\nE\n\n\n{\\displaystyle (u,v)\\in E}\n\n with \n\n\n\nv\n\u2208\nC\n\n\n{\\displaystyle v\\in C}\n\n. Remove the edge \n\n\n\n(\n\u03c0\n(\nv\n)\n,\nv\n)\n\n\n{\\displaystyle (\\pi (v),v)}\n\n from \n\n\n\nC\n\n\n{\\displaystyle C}\n\n, breaking the cycle. Mark each remaining edge in \n\n\n\nC\n\n\n{\\displaystyle C}\n\n. For each edge in \n\n\n\n\nA\n\n\u2032\n\n\n\n\n{\\displaystyle A^{\\prime }}\n\n, mark its corresponding edge in \n\n\n\nE\n\n\n{\\displaystyle E}\n\n. Now we define \n\n\n\nf\n(\nD\n,\nr\n,\nw\n)\n\n\n{\\displaystyle f(D,r,w)}\n\n to be the set of marked edges, which form a minimum spanning arborescence.\nObserve that \n\n\n\nf\n(\nD\n,\nr\n,\nw\n)\n\n\n{\\displaystyle f(D,r,w)}\n\n is defined in terms of \n\n\n\nf\n(\n\nD\n\n\u2032\n\n\n,\nr\n,\n\nw\n\n\u2032\n\n\n)\n\n\n{\\displaystyle f(D^{\\prime },r,w^{\\prime })}\n\n, with \n\n\n\n\nD\n\n\u2032\n\n\n\n\n{\\displaystyle D^{\\prime }}\n\n having strictly fewer vertices than \n\n\n\nD\n\n\n{\\displaystyle D}\n\n. Finding \n\n\n\nf\n(\nD\n,\nr\n,\nw\n)\n\n\n{\\displaystyle f(D,r,w)}\n\n for a single-vertex graph is trivial (it is just \n\n\n\nD\n\n\n{\\displaystyle D}\n\n itself), so the recursive algorithm is guaranteed to terminate.\nThe running time of this algorithm is \n\n\n\nO\n(\nE\nV\n)\n\n\n{\\displaystyle O(EV)}\n\n. A faster implementation of the algorithm due to Robert Tarjan runs in time \n\n\n\nO\n(\nE\nlog\n\u2061\nV\n)\n\n\n{\\displaystyle O(E\\log V)}\n\n for sparse graphs and \n\n\n\nO\n(\n\nV\n\n2\n\n\n)\n\n\n{\\displaystyle O(V^{2})}\n\n for dense graphs. This is as fast as Prim's algorithm for an undirected minimum spanning tree. In 1986, Gabow, Galil, Spencer, and Tarjan produced a faster implementation, with running time \n\n\n\nO\n(\nE\n+\nV\nlog\n\u2061\nV\n)\n\n\n{\\displaystyle O(E+V\\log V)}\n\n.", 
    "dbpedia_url": "http://dbpedia.org/resource/Edmonds'_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Edmonds'_algorithm\n"
}
{
    "about": "The Hadamard transform (also known as the Walsh\u2013Hadamard transform, Hadamard\u2013Rademacher\u2013Walsh transform, Walsh transform, or Walsh\u2013Fourier transform) is an example of a generalized class of Fourier transforms. It performs an orthogonal, symmetric, involutive, linear operation on 2m real numbers (or complex numbers, although the Hadamard matrices themselves are purely real).", 
    "name": "Hadamard Transform", 
    "classification": "Quantum Algorithms", 
    "full_text": "The Hadamard transform (also known as the Walsh\u2013Hadamard transform, Hadamard\u2013Rademacher\u2013Walsh transform, Walsh transform, or Walsh\u2013Fourier transform) is an example of a generalized class of Fourier transforms. It performs an orthogonal, symmetric, involutive, linear operation on 2m real numbers (or complex numbers, although the Hadamard matrices themselves are purely real).\nThe Hadamard transform can be regarded as being built out of size-2 discrete Fourier transforms (DFTs), and is in fact equivalent to a multidimensional DFT of size 2 \u00d7 2 \u00d7 \u22ef \u00d7 2 \u00d7 2.[2] It decomposes an arbitrary input vector into a superposition of Walsh functions.\nThe transform is named for the French mathematician Jacques Hadamard, the German-American mathematician Hans Rademacher, and the American mathematician Joseph L. Walsh.\n\n\nThe Hadamard transform Hm is a 2m\u00a0\u00d7\u00a02m matrix, the Hadamard matrix (scaled by a normalization factor), that transforms 2m real numbers xn into 2m real numbers Xk. The Hadamard transform can be defined in two ways: recursively, or by using the binary (base-2) representation of the indices n and k.\nRecursively, we define the 1\u00a0\u00d7\u00a01 Hadamard transform H0 by the identity H0 = 1, and then define Hm for m\u00a0>\u00a00 by:\nwhere the 1/\u221a2 is a normalization that is sometimes omitted.\nFor m\u00a0>\u00a01, we can also define Hm by:\nwhere \n\n\n\n\u2297\n\n\n{\\displaystyle \\otimes }\n\n represents the Kronecker product. Thus, other than this normalization factor, the Hadamard matrices are made up entirely of 1 and \u22121.\nEquivalently, we can define the Hadamard matrix by its (k,\u00a0n)-th entry by writing\nand\nwhere the kj and nj are the binary digits (0 or 1) of k and n, respectively. Note that for the element in the top left corner, we define: \n\n\n\nk\n=\nn\n=\n0\n\n\n{\\displaystyle k=n=0}\n\n. In this case, we have:\nThis is exactly the multidimensional \n\n\n\n\n2\n\n\u00d7\n\n2\n\n\u00d7\n\n\u22ef\n\n\u00d7\n\n2\n\n\u00d7\n\n2\n\n\n\n{\\displaystyle \\scriptstyle 2\\,\\times \\,2\\,\\times \\,\\cdots \\,\\times \\,2\\,\\times \\,2}\n\n DFT, normalized to be unitary, if the inputs and outputs are regarded as multidimensional arrays indexed by the nj and kj, respectively.\nSome examples of the Hadamard matrices follow.\n(This H1 is precisely the size-2 DFT. It can also be regarded as the Fourier transform on the two-element additive group of Z/(2).)\nwhere \n\n\n\ni\n\u22c5\nj\n\n\n{\\displaystyle i\\cdot j}\n\n is the bitwise dot product of the binary representations of the numbers i and j. For example, if \n\n\n\n\nn\n\u2265\n2\n\n\n\n{\\displaystyle \\scriptstyle n\\geq 2}\n\n, then \n\n\n\n\n(\n\n\nH\n\nn\n\n\n\n\n)\n\n3\n,\n2\n\n\n\n=\n\n(\n\u2212\n1\n\n)\n\n3\n\u22c5\n2\n\n\n\n=\n\n(\n\u2212\n1\n\n)\n\n(\n1\n,\n1\n)\n\u22c5\n(\n1\n,\n0\n)\n\n\n\n=\n\n(\n\u2212\n1\n\n)\n\n1\n+\n0\n\n\n\n=\n\n(\n\u2212\n1\n\n)\n\n1\n\n\n\n=\n\n\u2212\n1\n\n\n\n{\\displaystyle \\scriptstyle ({H_{n}})_{3,2}\\;=\\;(-1)^{3\\cdot 2}\\;=\\;(-1)^{(1,1)\\cdot (1,0)}\\;=\\;(-1)^{1+0}\\;=\\;(-1)^{1}\\;=\\;-1}\n\n, agreeing with the above (ignoring the overall constant). Note that the first row, first column of the matrix is denoted by \n\n\n\n\n(\n\n\nH\n\nn\n\n\n\n\n)\n\n0\n,\n0\n\n\n\n\n\n{\\displaystyle \\scriptstyle ({H_{n}})_{0,0}}\n\n.\nThe rows of the Hadamard matrices are the Walsh functions.\nThe Hadamard transform can be computed in n\u00a0log\u00a0n operations (n\u00a0=\u00a02m), using the fast Hadamard transform algorithm.\nIn quantum information processing the Hadamard transformation, more often called Hadamard gate in this context (cf. quantum gate), is a one-qubit rotation, mapping the qubit-basis states \n\n\n\n\n|\n\n0\n\u27e9\n\n\n{\\displaystyle |0\\rangle }\n\n and \n\n\n\n\n|\n\n1\n\u27e9\n\n\n{\\displaystyle |1\\rangle }\n\n to two superposition states with equal weight of the computational basis states \n\n\n\n\n|\n\n0\n\u27e9\n\n\n{\\displaystyle |0\\rangle }\n\n and \n\n\n\n\n|\n\n1\n\u27e9\n\n\n{\\displaystyle |1\\rangle }\n\n. Usually the phases are chosen so that we have\nin Dirac notation. This corresponds to the transformation matrix\nin the \n\n\n\n\n|\n\n0\n\u27e9\n,\n\n|\n\n1\n\u27e9\n\n\n{\\displaystyle |0\\rangle ,|1\\rangle }\n\n basis.\nMany quantum algorithms use the Hadamard transform as an initial step, since it maps n qubits initialized with \n\n\n\n\n|\n\n0\n\u27e9\n\n\n{\\displaystyle |0\\rangle }\n\n to a superposition of all 2n orthogonal states in the \n\n\n\n\n|\n\n0\n\u27e9\n,\n\n|\n\n1\n\u27e9\n\n\n{\\displaystyle |0\\rangle ,|1\\rangle }\n\n basis with equal weight.\nIt is useful to note that computing the quantum Hadamard transform is simply the application of a Hadamard gate to each qubit individually because of the tensor product structure of the Hadamard transform. This simple result means the quantum Hadamard transform requires n operations, compared to the classical case of n\u00a0log\u00a0n operations.\nOne application of the Hadamard gate to either a 0 or 1 qubit will produce a quantum state that, if observed, will be a 0 or 1 with equal probability (as seen in the first two operations). This is exactly like flipping a fair coin in the standard probabilistic model of computation. However, if the Hadamard gate is applied twice in succession (as is effectively being done in the last two operations), then the final state is always the same as the initial state. This would be like taking a fair coin that is showing heads, flipping it twice, and it always landing on heads after the second flip. The ket \n\n\n\n\n|\n\n0\n\u27e9\n=\n\n\n[\n\n\n\n1\n\n\n\n\n0\n\n\n\n]\n\n\n\n\n{\\displaystyle |0\\rangle ={\\begin{bmatrix}1\\\\0\\\\\\end{bmatrix}}}\n\n and the ket \n\n\n\n\n|\n\n1\n\u27e9\n=\n\n\n[\n\n\n\n0\n\n\n\n\n1\n\n\n\n]\n\n\n\n\n{\\displaystyle |1\\rangle ={\\begin{bmatrix}0\\\\1\\\\\\end{bmatrix}}}\n\n.\nThe Hadamard transform is also used in data encryption, as well as many signal processing and data compression algorithms, such as JPEG XR and MPEG-4 AVC. In video compression applications, it is usually used in the form of the sum of absolute transformed differences. It is also a crucial part of Grover's algorithm and Shor's algorithm in quantum computing. The Hadamard transform is also applied in scientific methods such as NMR, mass spectroscopy and crystallography.", 
    "dbpedia_url": "http://dbpedia.org/resource/Hadamard_transform", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Hadamard_transform\n"
}
{
    "about": "In computer programming, the Schwartzian transform is technique used to improve the efficiency of sorting a list of items. This idiom[1] is appropriate for comparison-based sorting when the ordering is actually based on the ordering of a certain property (the key) of the elements, where computing that property is an intensive operation that should be performed a minimal number of times. The Schwartzian transform is notable in that it does not use named temporary arrays.", 
    "name": "Schwartzian Transform", 
    "classification": "Sorting Algorithms", 
    "full_text": "In computer programming, the Schwartzian transform is technique used to improve the efficiency of sorting a list of items. This idiom[1] is appropriate for comparison-based sorting when the ordering is actually based on the ordering of a certain property (the key) of the elements, where computing that property is an intensive operation that should be performed a minimal number of times. The Schwartzian transform is notable in that it does not use named temporary arrays.\nThe Schwartzian transform is a version of a Lisp idiom known as decorate-sort-undecorate, which avoids recomputing the sort keys by temporarily associating them with the input items. This approach is similar to memoization, which avoids repeating the calculation of the key corresponding to a specific input value. By comparison, this idiom assures that each input item's key is calculated exactly once, which may still result in repeating some calculations if the input data contains duplicate items.\nThe idiom is named after Randal L. Schwartz, who first demonstrated it in Perl shortly after the release of Perl 5 in 1994. The term \"Schwartzian transform\" applied solely to Perl programming for a number of years, but it has later been adopted by some users of other languages, such as Python, to refer to similar idioms in those languages. However, the algorithm was already in use in other languages (under no specific name) before it was popularized among the Perl community in the form of that particular idiom by Schwartz. The term \"Schwartzian transform\" indicates a specific idiom, and not the algorithm in general.\nFor example, to sort the word list (\"aaaa\",\"a\",\"aa\") according to word length: first build the list ([\"aaaa\",4],[\"a\",1],[\"aa\",2]), then sort it according to the numeric values getting ([\"a\",1],[\"aa\",2],[\"aaaa\",4]), then strip off the numbers and you get (\"a\",\"aa\",\"aaaa\"). That was the algorithm in general, so it does not count as a transform. To make it a true Schwartzian transform, it would be done in Perl like this:\n\n\nThe general form of the Schwartzian Transform is:\nWhere foo($_) represents an expression that takes $_ (each item of the list in turn) and produces the corresponding value that is to be compared in its stead.\nReading from right to left (or from the bottom to the top):\nThe use of anonymous arrays ensures that memory will be reclaimed by the Perl garbage collector immediately after the sorting is done.\nWithout the Schwartzian transform, the sorting in the example above would be written in Perl like this:\nWhile it is shorter to code, the naive approach here could be much less efficient if the key function (called foo in the example above) is expensive to compute. This is because the code inside the brackets is evaluated each time two elements need to be compared. An optimal comparison sort performs O(n log n) comparisons (where n is the length of the list), with 2 calls to foo every comparison, resulting in O(n log n) calls to foo. In comparison, using the Schwartzian transform, we only make 1 call to foo per element, at the beginning map stage, for a total of n calls to foo.\nHowever, if the function foo is relatively simple, then the extra overhead of the Schwartzian transform may be unwarranted.\nFor example, to sort a list of files by their modification times, a naive approach might be as follows:\nUnless the modification times are memoized for each file, this method requires re-computing them every time a file is compared in the sort. Using the Schwartzian transform, the modification time is calculated only once per file.\nA Schwartzian transform involves the functional idiom described above, which does not use temporary arrays.\nThe same algorithm can be written procedurally to better illustrate how it works, but this requires using temporary arrays, and is not a Schwartzian transform. The following example pseudo-code implements the algorithm in this way:\nThe first known online appearance of the Schwartzian Transform is a December 16, 1994 posting by Randal Schwartz to a thread in comp.unix.shell, crossposted to comp.lang.perl. (The current version of the Perl Timeline is incorrect and refers to a later date in 1995.) The thread began with a question about how to sort a list of lines by their \"last\" word:\nSchwartz responded with:\nThis code produces the result:\nSchwartz noted in the post that he was \"Speak[ing] with a lisp in Perl,\" a reference to the idiom's Lisp origins.\nThe term \"Schwartzian Transform\" itself was coined by Tom Christiansen in a follow-up reply. Later posts by Christiansen made it clear that he had not intended to name the construct, but merely to refer to it from the original post: his attempt to finally name it \"The Black Transform\" did not take hold (\"Black\" here being a pun on \"schwar[t]z\", which means black in German).\nSome other languages provide a convenient interface to the same optimization as the Schwartzian transform:", 
    "dbpedia_url": "http://dbpedia.org/resource/Schwartzian_transform", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Schwartzian_transform\n"
}
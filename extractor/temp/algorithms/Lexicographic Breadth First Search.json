{
    "about": "In computer science, lexicographic breadth-first search or Lex-BFS is a linear time algorithm for ordering the vertices of a graph. The algorithm is different from breadth first search, but it produces an ordering that is consistent with breadth-first search.", 
    "classification": "Graph Algorithms", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Lexicographic_breadth-first_search\n", 
    "full_text": "In computer science, lexicographic breadth-first search or Lex-BFS is a linear time algorithm for ordering the vertices of a graph. The algorithm is different from breadth first search, but it produces an ordering that is consistent with breadth-first search.\nThe lexicographic breadth-first search algorithm is based on the idea of partition refinement and was first developed by Donald J. Rose, Robert E. Tarjan, and George S. Lueker\u00a0(1976). A more detailed survey of the topic is presented by Corneil (2004). It has been used as a subroutine in other graph algorithms including the recognition of chordal graphs, and optimal coloring of distance-hereditary graphs.\n\n\nThe breadth-first search algorithm is commonly defined by the following process:\nHowever, rather than defining the vertex to choose at each step in an imperative way as the one produced by the dequeue operation of a queue, one can define the same sequence of vertices declaratively, by the properties of these vertices. That is, a standard breadth-first search is just the result of repeatedly applying the rule:\nIn some cases, this ordering of vertices by the output positions of their predecessors may have ties \u2014 two different vertices have the same earliest predecessor. In this case, the order in which those two vertices are chosen may be arbitrary. The output of lexicographic breadth-first search differs from a standard breadth-first search in having a consistent rule for breaking such ties. In lexicographic breadth-first search, the output ordering is the order that would be produced by the rule:\nSo, when two vertices v and w have the same earliest predecessor, earlier than any other unchosen vertices, the standard breadth-first search algorithm will order them arbitrarily. Instead, in this case, the LexBFS algorithm would choose between v and w by the output ordering of their second-earliest predecessors. If only one of them has a second-earliest predecessor that has already been output, that one is chosen. If both v and w have the same second-earliest predecessor, then the tie is broken by considering their third-earliest predecessors, and so on.\nApplying this rule directly by comparing vertices according to this rule would lead to an inefficient algorithm. Instead, the lexicographic breadth-first search uses a set partitioning data structure in order to produce the same ordering more efficiently, just as a standard breadth-first search uses a queue data structure to produce its ordering efficiently.\nThe lexicographic breadth-first search algorithm replaces the queue of vertices of a standard breadth-first search with an ordered sequence of sets of vertices. The sets in the sequence form a partition of the remaining vertices. At each step, a vertex v from the first set in the sequence is removed from that set, and if that removal causes the set to become empty then the set is removed from the sequence. Then, each set in the sequence is replaced by two subsets: the neighbors of v and the non-neighbors of v. The subset of neighbors is placed earlier in the sequence than the subset of non-neighbors. In pseudocode, the algorithm can be expressed as follows:\nEach vertex is processed once, each edge is examined only when its two endpoints are processed, and (with an appropriate representation for the sets in \u03a3 that allows items to be moved from one set to another in constant time) each iteration of the inner loop takes only constant time. Therefore, like simpler graph search algorithms such as breadth-first search and depth first search, this algorithm takes linear time.\nThe algorithm is called lexicographic breadth-first search because the order it produces is an ordering that could also have been produced by a breadth-first search, and because if the ordering is used to index the rows and columns of an adjacency matrix of a graph then the algorithm sorts the rows and columns into Lexicographical order.\nA graph G is defined to be chordal if its vertices have a perfect elimination ordering, an ordering such that for any vertex v the neighbors that occur later in the ordering form a clique. In a chordal graph, the reverse of a lexicographic ordering is always a perfect elimination ordering. Therefore, one can test whether a graph is chordal in linear time by the following algorithm:\nThis application was the original motivation that led Rose, Tarjan & Lueker (1976) to develop the lexicographic breadth first search algorithm.[1]\nA graph G is said to be perfectly orderable if there is a sequence of its vertices with the property that, for any induced subgraph of G, a greedy coloring algorithm that colors the vertices in the induced sequence ordering is guaranteed to produce an optimal coloring.\nFor a chordal graph, a perfect elimination ordering is a perfect ordering: the number of the color used for any vertex is the size of the clique formed by it and its earlier neighbors, so the maximum number of colors used is equal to the size of the largest clique in the graph, and no coloring can use fewer colors. An induced subgraph of a chordal graph is chordal and the induced subsequence of its perfect elimination ordering is a perfect elimination ordering on the subgraph, so chordal graphs are perfectly orderable, and lexicographic breadth-first search can be used to optimally color them.\nThe same property is true for a larger class of graphs, the distance-hereditary graphs: distance-hereditary graphs are perfectly orderable, with a perfect ordering given by the reverse of a lexicographic ordering, so lexicographic breadth-first search can be used in conjunction with greedy coloring algorithms to color them optimally in linear time.[2]\nBretscher et al. (2008) describe an extension of lexicographic breadth-first search that breaks any additional ties using the complement graph of the input graph. As they show, this can be used to recognize cographs in linear time. Habib et al. (2000) describe additional applications of lexicographic breadth-first search including the recognition of comparability graphs and interval graphs.\nAn enumeration of the vertices of a graph is said to be a LexBFS ordering if it is the possible output of the application of LexBFS to this graph.\nLet \n\n\n\nG\n=\n(\nV\n,\nE\n)\n\n\n{\\displaystyle G=(V,E)}\n\n be a graph with \n\n\n\nn\n\n\n{\\displaystyle n}\n\n vertices. Recall that \n\n\n\nN\n(\nv\n)\n\n\n{\\displaystyle N(v)}\n\n is the set of neighbors of \n\n\n\nv\n\n\n{\\displaystyle v}\n\n. Let \n\n\n\n\u03c3\n=\n(\n\nv\n\n1\n\n\n,\n\u2026\n,\n\nv\n\nn\n\n\n)\n\n\n{\\displaystyle \\sigma =(v_{1},\\dots ,v_{n})}\n\n be an enumeration of the vertices of \n\n\n\nV\n\n\n{\\displaystyle V}\n\n. The enumeration \n\n\n\n\u03c3\n\n\n{\\displaystyle \\sigma }\n\n is a LexBFS ordering (with source \n\n\n\n\nv\n\n1\n\n\n\n\n{\\displaystyle v_{1}}\n\n) if, for all \n\n\n\n1\n\u2264\ni\n<\nj\n<\nk\n\u2264\nn\n\n\n{\\displaystyle 1\\leq i<j<k\\leq n}\n\n with \n\n\n\n\nv\n\ni\n\n\n\u2208\nN\n(\n\nv\n\nj\n\n\n)\n\u2216\nN\n(\n\nv\n\nk\n\n\n)\n\n\n{\\displaystyle v_{i}\\in N(v_{j})\\setminus N(v_{k})}\n\n, there exists \n\n\n\nm\n<\ni\n\n\n{\\displaystyle m<i}\n\n such that \n\n\n\n\nv\n\nm\n\n\n\u2208\nN\n(\n\nv\n\nj\n\n\n)\n\u2216\nV\n(\n\nv\n\nk\n\n\n)\n\n\n{\\displaystyle v_{m}\\in N(v_{j})\\setminus V(v_{k})}\n\n.", 
    "name": "Lexicographic Breadth First Search"
}
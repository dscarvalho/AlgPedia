{
    "about": "In mathematics, a minimum bottleneck spanning tree (MBST) in an undirected graph is a spanning tree in which the most expensive edge is as cheap as possible. A bottleneck edge is the highest weighted edge in a spanning tree. A spanning tree is a minimum bottleneck spanning tree if the graph does not contain a spanning tree with a smaller bottleneck edge weight.[1] For a directed graph, a similar problem is known as Minimum Bottleneck Spanning Arborescence (MBSA).", 
    "name": "Minimum Bottleneck Spanning Tree", 
    "classification": "Graph Algorithms", 
    "full_text": "In mathematics, a minimum bottleneck spanning tree (MBST) in an undirected graph is a spanning tree in which the most expensive edge is as cheap as possible. A bottleneck edge is the highest weighted edge in a spanning tree. A spanning tree is a minimum bottleneck spanning tree if the graph does not contain a spanning tree with a smaller bottleneck edge weight.[1] For a directed graph, a similar problem is known as Minimum Bottleneck Spanning Arborescence (MBSA).\n\n\nIn an undirected graph G(V,\u00a0E) and a function w\u00a0:\u00a0E\u00a0\u2192\u00a0R, let S be the set of all spanning trees Ti. Let B(Ti) be the maximum weight edge for any spanning tree Ti. We define subset of minimum bottleneck spanning trees S' such that for every Tj\u00a0\u2208\u00a0S' and Tk\u00a0\u2208\u00a0S we have B(Tj)\u00a0\u2264\u00a0B(Tk) for all i and\u00a0k.[2]\nThe graph on the right is an example of MBST, the red edges in the graph form a MBST of G(V,\u00a0E).\nAn arborescence of graph G is a directed tree of G which contains a directed path from a specified node L to each node of a subset V\u2019 of V\u00a0\\\u00a0{L}. Node L is called the root of arborescence. An arborescence is a spanning arborescence if V\u2019\u00a0=\u00a0V\u00a0\\\u00a0{L}. MBST in this case is a spanning arborescence with the minimum bottleneck edge. An MBST in this case is called a Minimum Bottleneck Spanning Arborescence (MBSA).\nThe graph on the right is an example of MBSA, the red edges in the graph form a MBSA of G(V,\u00a0E).\nA MST (or minimum spanning tree) is necessarily a MBST, but a MBST is not necessarily a MST.[citation needed]\nCamerini proposed[3] an algorithm used to obtain a minimum bottleneck spanning tree (MBST) in a given undirected, connected, edge-weighted graph in 1978. It half divides edges into two sets. The weights of edges in one set are no more than that in the other. If a spanning tree exists in subgraph composed solely with edges in smaller edges set, it then computes a MBST in the subgraph, a MBST of the subgraph is exactly a MBST of the original graph. If a spanning tree does not exist, it combines each disconnected component into a new super vertex, then computes a MBST in the graph formed by these super vertices and edges in the larger edges set. A forest in each disconnected component is part of a MBST in original graph. Repeat this process until two (super) vertices are left in the graph and a single edge with smallest weight between them is to be added. A MBST is found consisting of all the edges found in previous steps.[4]\nThe procedure has two input parameters. G is a graph, w is a weights array of all edges in the graph G.[5]\nIn the above (GA)\u03b7 is the subgraph composed of super vertices (by regarding vertices in a disconnected component as one) and edges in A.\nThe algorithm is running in O(E) time, where E is the number of edges. This bound is achieved as follows:\nIn the following example green edges are used to form a MBST and dashed red areas indicate super vertices formed during the algorithm steps.\nThere are two algorithms available for directed graph: Camerini\u2019s algorithm for finding MBSA and another from Gabow and Tarjan.[4]\nFor a directed graph, Camerini\u2019s algorithm focuses on finding the set of edges that would have its maximum cost as the bottleneck cost of the MBSA. This is done by partitioning the set of edges E into two sets A and B and maintaining the set T that is the set in which it is known that GT does not have a spanning arborescence, increasing T by B whenever the maximal arborescence of G(B\u00a0\u222a\u00a0T) is not a spanning arborescence of G, otherwise we decrease E by\u00a0A. Total total time complexity is O(E\u00a0log\u00a0E).[3][4]\nGabow and Tarjan provided a modification of Dijkstra's algorithm for single-source shortest path that produces an MBSA. Their algorithm runs in O(E\u00a0+\u00a0V\u00a0log\u00a0V) time if Fibonacci heap used.[6]\nThe following example shows that how the algorithm works.\nAnother approach proposed by Tarjan and Gabow with bound of O(E\u00a0log*\u00a0V) for sparse graphs, in which it is very similar to Camerini\u2019s algorithm for MBSA, but rather than partitioning the set of edges into two sets per each iteration, K(i) was introduced in which i is the number of splits that has taken place or in other words the iteration number, and K(i) is an increasing function that denotes the number of partitioned sets that one should have per iteration. K(i)\u00a0=\u00a02k(i\u00a0\u2212\u00a01) with k(1)\u00a0=\u00a02. The algorithm finds \u03bb* in which it is the value of the bottleneck edge in any MBSA. After \u03bb* is found any spanning arborescence in G(\u03bb*) is an MBSA in which G(\u03bb*) is the graph where all its edge\u2019s costs are \u2264\u00a0\u03bb*.[4][6]", 
    "dbpedia_url": "http://dbpedia.org/resource/Minimum_bottleneck_spanning_tree", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Minimum_bottleneck_spanning_tree\n"
}
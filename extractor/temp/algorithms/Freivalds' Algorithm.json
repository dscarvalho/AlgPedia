{
    "about": "Freivalds' algorithm (named after R\u016bsi\u0146\u0161 M\u0101rti\u0146\u0161 Freivalds) is a probabilistic randomized algorithm used to verify matrix multiplication. Given three n\u00a0\u00d7\u00a0n matrices \n\n\n\nA\n\n\n{\\displaystyle A}\n\n, \n\n\n\nB\n\n\n{\\displaystyle B}\n\n, and \n\n\n\nC\n\n\n{\\displaystyle C}\n\n, a general problem is to verify whether \n\n\n\nA\n\u00d7\nB\n=\nC\n\n\n{\\displaystyle A\\times B=C}\n\n. A na\u00efve algorithm would compute the product \n\n\n\nA\n\u00d7\nB\n\n\n{\\displaystyle A\\times B}\n\n explicitly and compare term by term whether this product equals \n\n\n\nC\n\n\n{\\displaystyle C}\n\n. However, the best known matrix multiplication algorithm runs in \n\n\n\nO\n(\n\nn\n\n2.3729\n\n\n)\n\n\n{\\displaystyle O(n^{2.3729})}\n\n time.[1] Freivalds' algorithm utilizes randomization in order to reduce this time bound to \n\n\n\nO\n(\n\nn\n\n2\n\n\n)\n\n\n{\\displaystyle O(n^{2})}\n\n [2] with high probability. In \n\n\n\nO\n(\nk\n\nn\n\n2\n\n\n)\n\n\n{\\displaystyle O(kn^{2})}\n\n time the algorithm can verify a matrix product with probability of failure less than \n\n\n\n\n2\n\n\u2212\nk\n\n\n\n\n{\\displaystyle 2^{-k}}\n\n.", 
    "name": "Freivalds' Algorithm", 
    "classification": "Matrix Multiplication Algorithms", 
    "full_text": "Freivalds' algorithm (named after R\u016bsi\u0146\u0161 M\u0101rti\u0146\u0161 Freivalds) is a probabilistic randomized algorithm used to verify matrix multiplication. Given three n\u00a0\u00d7\u00a0n matrices \n\n\n\nA\n\n\n{\\displaystyle A}\n\n, \n\n\n\nB\n\n\n{\\displaystyle B}\n\n, and \n\n\n\nC\n\n\n{\\displaystyle C}\n\n, a general problem is to verify whether \n\n\n\nA\n\u00d7\nB\n=\nC\n\n\n{\\displaystyle A\\times B=C}\n\n. A na\u00efve algorithm would compute the product \n\n\n\nA\n\u00d7\nB\n\n\n{\\displaystyle A\\times B}\n\n explicitly and compare term by term whether this product equals \n\n\n\nC\n\n\n{\\displaystyle C}\n\n. However, the best known matrix multiplication algorithm runs in \n\n\n\nO\n(\n\nn\n\n2.3729\n\n\n)\n\n\n{\\displaystyle O(n^{2.3729})}\n\n time.[1] Freivalds' algorithm utilizes randomization in order to reduce this time bound to \n\n\n\nO\n(\n\nn\n\n2\n\n\n)\n\n\n{\\displaystyle O(n^{2})}\n\n [2] with high probability. In \n\n\n\nO\n(\nk\n\nn\n\n2\n\n\n)\n\n\n{\\displaystyle O(kn^{2})}\n\n time the algorithm can verify a matrix product with probability of failure less than \n\n\n\n\n2\n\n\u2212\nk\n\n\n\n\n{\\displaystyle 2^{-k}}\n\n.\n\n\nThree n\u00a0\u00d7\u00a0n matrices \n\n\n\nA\n\n\n{\\displaystyle A}\n\n, \n\n\n\nB\n\n\n{\\displaystyle B}\n\n, and \n\n\n\nC\n\n\n{\\displaystyle C}\n\n.\nYes, if \n\n\n\nA\n\u00d7\nB\n=\nC\n\n\n{\\displaystyle A\\times B=C}\n\n; No, otherwise.\nIf \n\n\n\nA\n\u00d7\nB\n=\nC\n\n\n{\\displaystyle A\\times B=C}\n\n, then the algorithm always returns \"Yes\". If \n\n\n\nA\n\u00d7\nB\n\u2260\nC\n\n\n{\\displaystyle A\\times B\\neq C}\n\n, then the probability that the algorithm returns \"Yes\" is less than or equal to one half. This is called one-sided error.\nBy iterating the algorithm k times and returning \"Yes\" only if all iterations yield \"Yes\", a runtime of \n\n\n\nO\n(\nk\n\nn\n\n2\n\n\n)\n\n\n{\\displaystyle O(kn^{2})}\n\n and error probability of \n\n\n\n\u2264\n1\n\n/\n\n\n2\n\nk\n\n\n\n\n{\\displaystyle \\leq 1/2^{k}}\n\n is achieved.\nSuppose one wished to determine whether:\nA random two-element vector with entries equal to 0 or 1 is selected \u2014 say \n\n\n\n\n\n\nr\n\u2192\n\n\n\n=\n\n\n[\n\n\n\n1\n\n\n\n\n1\n\n\n\n]\n\n\n\n\n{\\displaystyle {\\vec {r}}={\\begin{bmatrix}1\\\\1\\end{bmatrix}}}\n\n \u2014 and used to compute:\nThis yields the zero vector, suggesting the possibility that AB = C. However, if in a second trial the vector \n\n\n\n\n\n\nr\n\u2192\n\n\n\n=\n\n\n[\n\n\n\n1\n\n\n\n\n0\n\n\n\n]\n\n\n\n\n{\\displaystyle {\\vec {r}}={\\begin{bmatrix}1\\\\0\\end{bmatrix}}}\n\n is selected, the result becomes:\nThe result is nonzero, proving that in fact AB \u2260 C.\nThere are four two-element 0/1 vectors, and half of them give the zero vector in this case (\n\n\n\n\n\n\nr\n\u2192\n\n\n\n=\n\n\n[\n\n\n\n0\n\n\n\n\n0\n\n\n\n]\n\n\n\n\n{\\displaystyle {\\vec {r}}={\\begin{bmatrix}0\\\\0\\end{bmatrix}}}\n\n and \n\n\n\n\n\n\nr\n\u2192\n\n\n\n=\n\n\n[\n\n\n\n1\n\n\n\n\n1\n\n\n\n]\n\n\n\n\n{\\displaystyle {\\vec {r}}={\\begin{bmatrix}1\\\\1\\end{bmatrix}}}\n\n), so the chance of randomly selecting these in two trials (and falsely concluding that AB=C) is 1/22 or 1/4. In the general case, the proportion of r yielding the zero vector may be less than 1/2, and a larger number of trials (such as 20) would be used, rendering the probability of error very small.\nLet p equal the probability of error. We claim that if A\u00a0\u00d7\u00a0B = C, then p = 0, and if A\u00a0\u00d7\u00a0B \u2260 C, then p \u2264 1/2.\nThis is regardless of the value of \n\n\n\n\n\n\nr\n\u2192\n\n\n\n\n\n{\\displaystyle {\\vec {r}}}\n\n, since it uses only that \n\n\n\nA\n\u00d7\nB\n\u2212\nC\n=\n0\n\n\n{\\displaystyle A\\times B-C=0}\n\n. Hence the probability for error in this case is:\nLet\nWhere\nSince \n\n\n\nA\n\u00d7\nB\n\u2260\nC\n\n\n{\\displaystyle A\\times B\\neq C}\n\n, we have that some element of \n\n\n\nD\n\n\n{\\displaystyle D}\n\n is nonzero. Suppose that the element \n\n\n\n\nd\n\ni\nj\n\n\n\u2260\n0\n\n\n{\\displaystyle d_{ij}\\neq 0}\n\n. By the definition of matrix multiplication, we have:\nFor some constant \n\n\n\ny\n\n\n{\\displaystyle y}\n\n. Using Bayes' Theorem, we can partition over \n\n\n\ny\n\n\n{\\displaystyle y}\n\n:\n\n\n\n\nPr\n[\n\np\n\ni\n\n\n=\n0\n]\n=\nPr\n[\n\np\n\ni\n\n\n=\n0\n\n|\n\ny\n=\n0\n]\n\u22c5\nPr\n[\ny\n=\n0\n]\n\n+\n\nPr\n[\n\np\n\ni\n\n\n=\n0\n\n|\n\ny\n\u2260\n0\n]\n\u22c5\nPr\n[\ny\n\u2260\n0\n]\n\n\n{\\displaystyle \\Pr[p_{i}=0]=\\Pr[p_{i}=0|y=0]\\cdot \\Pr[y=0]\\,+\\,\\Pr[p_{i}=0|y\\neq 0]\\cdot \\Pr[y\\neq 0]}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(1)\nWe use that:\nPlugging these in the equation (1), we get:\nTherefore,\nThis completes the proof.\nSimple algorithmic analysis shows that the running time of this algorithm is O(n2), beating the classical deterministic algorithm's bound of O(n3). The error analysis also shows that if we run our algorithm k times, we can achieve an error bound of less than \n\n\n\n\n\n1\n\n2\n\nk\n\n\n\n\n\n\n{\\displaystyle {\\frac {1}{2^{k}}}}\n\n, an exponentially small quantity. The algorithm is also fast in practice due to wide availability of fast implementations for matrix-vector products. Therefore, utilization of randomized algorithms can speed up a very slow deterministic algorithm. In fact, the best known deterministic matrix multiplication verification algorithm known at the current time is a variant of the Coppersmith\u2013Winograd algorithm with an asymptotic running time of O(n2.3729).[1]\nFreivalds' algorithm frequently arises in introductions to probabilistic algorithms due to its simplicity and how it illustrates the superiority of probabilistic algorithms in practice for some problems.", 
    "dbpedia_url": "http://dbpedia.org/resource/Freivalds'_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Freivalds'_algorithm\n"
}
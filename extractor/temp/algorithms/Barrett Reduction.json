{
    "about": "In modular arithmetic, Barrett reduction is a reduction algorithm introduced in 1986 by P.D. Barrett.[1] A naive way of computing", 
    "name": "Barrett Reduction", 
    "classification": "Cryptographic Algorithms", 
    "full_text": "In modular arithmetic, Barrett reduction is a reduction algorithm introduced in 1986 by P.D. Barrett.[1] A naive way of computing\nwould be to use a fast division algorithm. Barrett reduction is an algorithm designed to optimize this operation assuming \n\n\n\nn\n\n\n{\\displaystyle n}\n\n is constant, and \n\n\n\na\n<\n\nn\n\n2\n\n\n\n\n{\\displaystyle a<n^{2}}\n\n, replacing divisions by multiplications.\n\n\nLet \n\n\n\nm\n=\n1\n\n/\n\nn\n\n\n{\\displaystyle m=1/n}\n\n be the inverse of \n\n\n\nn\n\n\n{\\displaystyle n}\n\n as a floating point number. Then\nwhere \n\n\n\n\u230a\nx\n\u230b\n\n\n{\\displaystyle \\lfloor x\\rfloor }\n\n denotes the floor function. The result is exact, as long as m is computed with sufficient accuracy.\nBarrett initially considered an integer version of the above algorithm when the values fit into machine words.\nWhen calculating \n\n\n\na\n\n\nmod\n\n\n\n\nn\n\n\n{\\displaystyle a\\,{\\bmod {\\,}}n}\n\n using the method above, but with integers, the obvious analogue would be to use division by \n\n\n\nn\n\n\n{\\displaystyle n}\n\n:\nHowever, division can be expensive and, in cryptographic settings, may not be a constant-time instruction on some CPUs. Thus Barrett reduction approximates \n\n\n\n1\n\n/\n\nn\n\n\n{\\displaystyle 1/n}\n\n with a value \n\n\n\nx\n\n/\n\n\n2\n\nk\n\n\n\n\n{\\displaystyle x/2^{k}}\n\n because division by \n\n\n\n\n2\n\nk\n\n\n\n\n{\\displaystyle 2^{k}}\n\n is just a right-shift and so is cheap.\nIn order to calculate the best value for \n\n\n\nm\n\n\n{\\displaystyle m}\n\n given \n\n\n\n\n2\n\nk\n\n\n\n\n{\\displaystyle 2^{k}}\n\n consider:\nIn order for \n\n\n\nm\n\n\n{\\displaystyle m}\n\n to be an integer, we need to round \n\n\n\n\n\n2\n\nk\n\n\n\n\n/\n\n\nn\n\n\n\n{\\displaystyle {2^{k}}/{n}}\n\n somehow. Rounding to the nearest integer will give the best approximation but can result in \n\n\n\nm\n\n/\n\n\n2\n\nk\n\n\n\n\n{\\displaystyle m/2^{k}}\n\n being larger than \n\n\n\n1\n\n/\n\nn\n\n\n{\\displaystyle 1/n}\n\n, which can cause underflows. Thus \n\n\n\nm\n=\n\u230a\n\n\n2\n\nk\n\n\n\n\n/\n\n\nn\n\n\u230b\n\n\n{\\displaystyle m=\\lfloor {2^{k}}/{n}\\rfloor }\n\n is generally used.\nThus we can approximate the function above with:\nHowever, since \n\n\n\nm\n\n/\n\n\n2\n\nk\n\n\n\u2264\n1\n\n/\n\nn\n\n\n{\\displaystyle m/2^{k}\\leq 1/n}\n\n, the value of q in that function can end up being one too small, and thus a is only guaranteed to be within \n\n\n\n[\n0\n,\n2\nn\n)\n\n\n{\\displaystyle [0,2n)}\n\n rather than \n\n\n\n[\n0\n,\nn\n)\n\n\n{\\displaystyle [0,n)}\n\n as is generally required. A conditional subtraction will correct this:\nSince \n\n\n\nm\n\n/\n\n\n2\n\nk\n\n\n\n\n{\\displaystyle m/2^{k}}\n\n is only an approximation, the valid range of \n\n\n\na\n\n\n{\\displaystyle a}\n\n needs to be considered. The error of the approximation of \n\n\n\n1\n\n/\n\nn\n\n\n{\\displaystyle 1/n}\n\n is:\nThus the error in the value of q is \n\n\n\na\ne\n\n\n{\\displaystyle ae}\n\n. As long as \n\n\n\na\ne\n<\n1\n\n\n{\\displaystyle ae<1}\n\n then the reduction is valid thus \n\n\n\na\n<\n1\n\n/\n\ne\n\n\n{\\displaystyle a<1/e}\n\n. The reduction function might not immediately give the wrong answer when \n\n\n\na\n\u2265\n1\n\n/\n\ne\n\n\n{\\displaystyle a\\geq 1/e}\n\n but the bounds on \n\n\n\na\n\n\n{\\displaystyle a}\n\n must be respected to ensure the correct answer in the general case.\nBy choosing larger values of \n\n\n\nk\n\n\n{\\displaystyle k}\n\n, the range of values of \n\n\n\na\n\n\n{\\displaystyle a}\n\n for which the reduction is valid can be increased, but larger values of \n\n\n\nk\n\n\n{\\displaystyle k}\n\n may cause overflow problems elsewhere.\nConsider the case of \n\n\n\nn\n=\n101\n\n\n{\\displaystyle n=101}\n\n when operating with 16-bit integers.\nThe smallest value of \n\n\n\nk\n\n\n{\\displaystyle k}\n\n that makes sense is seven because if \n\n\n\n\n2\n\nk\n\n\n<\nn\n\n\n{\\displaystyle 2^{k}<n}\n\n then the reduction will only be valid for values that are already minimal! For a value of seven, \n\n\n\nm\n=\n\u230a\n\n2\n\nk\n\n\n\n/\n\nn\n\u230b\n=\n\u230a\n128\n\n/\n\n101\n\u230b\n=\n1\n\n\n{\\displaystyle m=\\lfloor 2^{k}/n\\rfloor =\\lfloor 128/101\\rfloor =1}\n\n. For a value of eight \n\n\n\nm\n=\n\u230a\n256\n\n/\n\n101\n\u230b\n=\n2\n\n\n{\\displaystyle m=\\lfloor 256/101\\rfloor =2}\n\n. Thus \n\n\n\nk\n=\n8\n\n\n{\\displaystyle k=8}\n\n provides no advantage because the approximation of \n\n\n\n1\n\n/\n\n101\n\n\n{\\displaystyle 1/101}\n\n in that case (\n\n\n\n2\n\n/\n\n256\n\n\n{\\displaystyle 2/256}\n\n) is exactly the same as \n\n\n\n1\n\n/\n\n128\n\n\n{\\displaystyle 1/128}\n\n. For \n\n\n\nk\n\n\n{\\displaystyle k}\n\n equal to nine, \n\n\n\nm\n=\n512\n\n/\n\n101\n=\n5\n\n\n{\\displaystyle m=512/101=5}\n\n, which is a better approximation.\nNow we consider the valid input ranges for \n\n\n\nk\n=\n7\n\n\n{\\displaystyle k=7}\n\n and \n\n\n\nk\n=\n9\n\n\n{\\displaystyle k=9}\n\n. In the first case, \n\n\n\ne\n=\n1\n\n/\n\nn\n\u2212\nx\n\n/\n\n\n2\n\nk\n\n\n=\n1\n\n/\n\n101\n\u2212\n1\n\n/\n\n128\n=\n27\n\n/\n\n12928\n\n\n{\\displaystyle e=1/n-x/2^{k}=1/101-1/128=27/12928}\n\n so \n\n\n\na\n<\n1\n\n/\n\ne\n\n\n{\\displaystyle a<1/e}\n\n implies \n\n\n\na\n<\n478.81\n\n\n{\\displaystyle a<478.81}\n\n. Since \n\n\n\na\n\n\n{\\displaystyle a}\n\n is an integer, effectively the maximum value is 478. (In practice the function happens to work for values up to 504.)\nIf we take \n\n\n\nk\n=\n9\n\n\n{\\displaystyle k=9}\n\n then \n\n\n\ne\n=\n1\n\n/\n\n101\n\u2212\n5\n\n/\n\n512\n=\n7\n\n/\n\n51712\n\n\n{\\displaystyle e=1/101-5/512=7/51712}\n\n and so the maximum value of \n\n\n\na\n\n\n{\\displaystyle a}\n\n is 7387. (In practice the function happens to work until 7473.)\nThe next value of \n\n\n\nk\n\n\n{\\displaystyle k}\n\n that results in a better approximation is 13, giving \n\n\n\n81\n\n/\n\n8192\n\n\n{\\displaystyle 81/8192}\n\n. However, note that the intermediate value \n\n\n\na\nx\n\n\n{\\displaystyle ax}\n\n in the calculation will then overflow an unsigned 16-bit value when \n\n\n\n810\n\u2264\na\n\n\n{\\displaystyle 810\\leq a}\n\n, thus \n\n\n\nk\n=\n7\n\n\n{\\displaystyle k=7}\n\n works better in this situation.\nLet \n\n\n\n\nk\n\n0\n\n\n\n\n{\\displaystyle k_{0}}\n\n be the smallest integer such that \n\n\n\n\n2\n\n\nk\n\n0\n\n\n\n\n>\nn\n\n\n{\\displaystyle 2^{k_{0}}>n}\n\n. Take \n\n\n\n\nk\n\n0\n\n\n+\n1\n\n\n{\\displaystyle k_{0}+1}\n\n as a reasonable value for \n\n\n\nk\n\n\n{\\displaystyle k}\n\n in the above equations. As in the code snippets above, let\nBecause of the floor function, \n\n\n\nq\n\n\n{\\displaystyle q}\n\n is an integer and \n\n\n\nr\n\u2261\na\n\n\n(\nmod\n\nn\n)\n\n\n\n{\\displaystyle r\\equiv a{\\pmod {n}}}\n\n. Also, if \n\n\n\na\n<\n\n2\n\nk\n\n\n\n\n{\\displaystyle a<2^{k}}\n\n then \n\n\n\nr\n<\n2\nn\n\n\n{\\displaystyle r<2n}\n\n. In that case, writing the snippets above as an expression:\nThe proof that \n\n\n\nr\n<\n2\nn\n\n\n{\\displaystyle r<2n}\n\n follows:\nIf \n\n\n\na\n<\n\n2\n\nk\n\n\n\n\n{\\displaystyle a<2^{k}}\n\n, then\nSince \n\n\n\nn\n\u22c5\n\n\n\nm\na\n\nmod\n\n\n\n2\n\nk\n\n\n\n\n2\n\nk\n\n\n\n\n<\nn\n\n\n{\\displaystyle n\\cdot {\\frac {ma\\mod 2^{k}}{2^{k}}}<n}\n\n regardless of \n\n\n\na\n\n\n{\\displaystyle a}\n\n, it follows that\nBarrett's primary motivation for considering reduction was the implementation of RSA, where the values in question will almost certainly exceed the size of a machine word. In this situation, Barrett provided an algorithm that approximates the single-word version above but for multi-word values. For details see section 14.3.3 of the Handbook of Applied Cryptography.[2]\nMontgomery reduction is another similar algorithm.", 
    "dbpedia_url": "http://dbpedia.org/resource/Barrett_reduction", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Barrett_reduction\n"
}
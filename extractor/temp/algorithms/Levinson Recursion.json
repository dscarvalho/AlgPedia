{
    "about": "Levinson recursion or Levinson\u2013Durbin recursion is a procedure in linear algebra to recursively calculate the solution to an equation involving a Toeplitz matrix. The algorithm runs in \u0398(n2) time, which is a strong improvement over Gauss\u2013Jordan elimination, which runs in \u0398(n3).", 
    "name": "Levinson Recursion", 
    "classification": "Numerical Analysis", 
    "full_text": "Levinson recursion or Levinson\u2013Durbin recursion is a procedure in linear algebra to recursively calculate the solution to an equation involving a Toeplitz matrix. The algorithm runs in \u0398(n2) time, which is a strong improvement over Gauss\u2013Jordan elimination, which runs in \u0398(n3).\nThe Levinson\u2013Durbin algorithm was proposed first by Norman Levinson in 1947, improved by James Durbin in 1960, and subsequently improved to 4n2 and then 3n2 multiplications by W. F. Trench and S. Zohar, respectively.\nOther methods to process data include Schur decomposition and Cholesky decomposition. In comparison to these, Levinson recursion (particularly split Levinson recursion) tends to be faster computationally, but more sensitive to computational inaccuracies like round-off errors.\nThe Bareiss algorithm for Toeplitz matrices (not to be confused with the general Bareiss algorithm) runs about as fast as Levinson recursion, but it uses O(n2) space, whereas Levinson recursion uses only O(n) space. The Bareiss algorithm, though, is numerically stable,[1][2] whereas Levinson recursion is at best only weakly stable (i.e. it exhibits numerical stability for well-conditioned linear systems).[3]\nNewer algorithms, called asymptotically fast or sometimes superfast Toeplitz algorithms, can solve in \u0398(n logpn) for various p (e.g. p = 2,[4][5] p = 3 [6]). Levinson recursion remains popular for several reasons; for one, it is relatively easy to understand in comparison; for another, it can be faster than a superfast algorithm for small n (usually n\u00a0<\u00a0256).[7]\n\n\nMatrix equations follow the form:\nThe Levinson\u2013Durbin algorithm may be used for any such equation, as long as M is a known Toeplitz matrix with a nonzero main diagonal. Here \n\n\n\n\n\n\ny\n\u2192\n\n\n\n\n\n{\\displaystyle {\\vec {y}}}\n\n is a known vector, and \n\n\n\n\n\n\nx\n\u2192\n\n\n\n\n\n{\\displaystyle {\\vec {x}}}\n\n is an unknown vector of numbers xi yet to be determined.\nFor the sake of this article, \u00eai is a vector made up entirely of zeroes, except for its ith place, which holds the value one. Its length will be implicitly determined by the surrounding context. The term N refers to the width of the matrix above \u2013 M is an N\u00d7N matrix. Finally, in this article, superscripts refer to an inductive index, whereas subscripts denote indices. For example (and definition), in this article, the matrix Tn is an n\u00d7n matrix which copies the upper left n\u00d7n block from M \u2013 that is, Tnij = Mij.\nTn is also a Toeplitz matrix; meaning that it can be written as:\nThe algorithm proceeds in two steps. In the first step, two sets of vectors, called the forward and backward vectors, are established. The forward vectors are used to help get the set of backward vectors; then they can be immediately discarded. The backwards vectors are necessary for the second step, where they are used to build the solution desired.\nLevinson\u2013Durbin recursion defines the nth \"forward vector\", denoted \n\n\n\n\n\n\n\nf\n\u2192\n\n\n\n\nn\n\n\n\n\n{\\displaystyle {\\vec {f}}^{n}}\n\n, as the vector of length n which satisfies:\nThe nth \"backward vector\" \n\n\n\n\n\n\n\nb\n\u2192\n\n\n\n\nn\n\n\n\n\n{\\displaystyle {\\vec {b}}^{n}}\n\n is defined similarly; it is the vector of length n which satisfies:\nAn important simplification can occur when M is a symmetric matrix; then the two vectors are related by bni = fnn+1\u2212i\u2014that is, they are row-reversals of each other. This can save some extra computation in that special case.\nEven if the matrix is not symmetric, then the nth forward and backward vector may be found from the vectors of length n\u00a0\u2212\u00a01 as follows. First, the forward vector may be extended with a zero to obtain:\nIn going from Tn\u22121 to Tn, the extra column added to the matrix does not perturb the solution when a zero is used to extend the forward vector. However, the extra row added to the matrix has perturbed the solution; and it has created an unwanted error term \u03b5f which occurs in the last place. The above equation gives it the value of:\nThis error will be returned to shortly and eliminated from the new forward vector; but first, the backwards vector must be extended in a similar (albeit reversed) fashion. For the backwards vector,\nAs before, the extra column added to the matrix does not perturb this new backwards vector; but the extra row does. Here we have another unwanted error \u03b5b with value:\nThese two error terms can be used to eliminate each other. Using the linearity of matrices,\nIf \u03b1 and \u03b2 are chosen so that the right hand side yields \u00ea1 or \u00ean, then the quantity in the parentheses will fulfill the definition of the nth forward or backward vector, respectively. With those alpha and beta chosen, the vector sum in the parentheses is simple and yields the desired result.\nTo find these coefficients, \n\n\n\n\n\u03b1\n\nf\n\n\nn\n\n\n\n\n{\\displaystyle \\alpha _{f}^{n}}\n\n, \n\n\n\n\n\u03b2\n\nf\n\n\nn\n\n\n\n\n{\\displaystyle \\beta _{f}^{n}}\n\n are such that\u00a0:\nand respectively \n\n\n\n\n\u03b1\n\nb\n\n\nn\n\n\n\n\n{\\displaystyle \\alpha _{b}^{n}}\n\n, \n\n\n\n\n\u03b2\n\nb\n\n\nn\n\n\n\n\n{\\displaystyle \\beta _{b}^{n}}\n\n are such that\u00a0:\nBy multiplying both previous equations by \n\n\n\n\n\n\nT\n\n\n\nn\n\n\n\n\n{\\displaystyle {\\mathbf {T} }^{n}}\n\n one gets the following equation:\nNow, all the zeroes in the middle of the two vectors above being disregarded and collapsed, only the following equation is left:\nWith these solved for (by using the Cramer 2\u00d72 matrix inverse formula), the new forward and backward vectors are:\nPerforming these vector summations, then, gives the nth forward and backward vectors from the prior ones. All that remains is to find the first of these vectors, and then some quick sums and multiplications give the remaining ones. The first forward and backward vectors are simply:\nThe above steps give the N backward vectors for M. From there, a more arbitrary equation is:\nThe solution can be built in the same recursive way that the backwards vectors were built. Accordingly, \n\n\n\n\n\n\nx\n\u2192\n\n\n\n\n\n{\\displaystyle {\\vec {x}}}\n\n must be generalized to a sequence \n\n\n\n\n\n\n\nx\n\u2192\n\n\n\n\nn\n\n\n\n\n{\\displaystyle {\\vec {x}}^{n}}\n\n, from which \n\n\n\n\n\n\n\nx\n\u2192\n\n\n\n\nN\n\n\n=\n\n\n\nx\n\u2192\n\n\n\n\n\n{\\displaystyle {\\vec {x}}^{N}={\\vec {x}}}\n\n.\nThe solution is then built recursively by noticing that if\nThen, extending with a zero again, and defining an error constant where necessary:\nWe can then use the nth backward vector to eliminate the error term and replace it with the desired formula as follows:\nExtending this method until n = N yields the solution \n\n\n\n\n\n\nx\n\u2192\n\n\n\n\n\n{\\displaystyle {\\vec {x}}}\n\n.\nIn practice, these steps are often done concurrently with the rest of the procedure, but they form a coherent unit and deserve to be treated as their own step.\nIf M is not strictly Toeplitz, but block Toeplitz, the Levinson recursion can be derived in much the same way by regarding the block Toeplitz matrix as a Toeplitz matrix with matrix elements (Musicus 1988). Block Toeplitz matrices arise naturally in signal processing algorithms when dealing with multiple signal streams (e.g., in MIMO systems) or cyclo-stationary signals.\nDefining sources\nFurther work\nSummaries", 
    "dbpedia_url": "http://dbpedia.org/resource/Levinson_recursion", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Levinson_recursion\n"
}
{
    "about": "In mathematical optimization, the criss-cross algorithm is any of a family of algorithms for linear programming. Variants of the criss-cross algorithm also solve more general problems with linear inequality constraints and nonlinear objective functions; there are criss-cross algorithms for linear-fractional programming problems,[1][2] quadratic-programming problems, and linear complementarity problems.[3]", 
    "classification": "Optimization Algorithms And Methods", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Criss-cross_algorithm\n", 
    "full_text": "In mathematical optimization, the criss-cross algorithm is any of a family of algorithms for linear programming. Variants of the criss-cross algorithm also solve more general problems with linear inequality constraints and nonlinear objective functions; there are criss-cross algorithms for linear-fractional programming problems,[1][2] quadratic-programming problems, and linear complementarity problems.[3]\nLike the simplex algorithm of George B. Dantzig, the criss-cross algorithm is not a polynomial-time algorithm for linear programming. Both algorithms visit all\u00a02D\u00a0corners of a (perturbed) cube in dimension\u00a0D, the Klee\u2013Minty cube (after Victor Klee and George J. Minty), in the worst case.[4][5] However, when it is started at a random corner, the criss-cross algorithm on\u00a0average visits only\u00a0D additional corners.[6][7][8] Thus, for the three-dimensional cube, the algorithm visits all\u00a08 corners in the worst case and exactly\u00a03 additional corners on\u00a0average.\n\n\nThe criss-cross algorithm was published independently by Tam\u00e1s Terlaky[9] and by Zhe-Min Wang;[10] related algorithms appeared in unpublished reports by other authors.[3]\nIn linear programming, the criss-cross algorithm pivots between a sequence of bases but differs from the simplex algorithm of George Dantzig. The simplex algorithm first finds a (primal-) feasible basis by solving a \"phase-one problem\"; in \"phase two\", the simplex algorithm pivots between a sequence of basic feasible solutions so that the objective function is non-decreasing with each pivot, terminating when with an optimal solution (also finally finding a \"dual feasible\" solution).[3][11]\nThe criss-cross algorithm is simpler than the simplex algorithm, because the criss-cross algorithm only has one phase. Its pivoting rules are similar to the least-index pivoting rule of Bland.[12] Bland's rule uses only signs of coefficients rather than their (real-number) order when deciding eligible pivots. Bland's rule selects an entering variables by comparing values of reduced costs, using the real-number ordering of the eligible pivots.[12][13] Unlike Bland's rule, the criss-cross algorithm is \"purely combinatorial\", selecting an entering variable and a leaving variable by considering only the signs of coefficients rather than their real-number ordering.[3][11] The criss-cross algorithm has been applied to furnish constructive proofs of basic results in real linear algebra, such as the lemma of Farkas.[14]\nWhile most simplex variants are monotonic in the objective (strictly in the non-degenerate case), most variants of the criss-cross algorithm lack a monotone merit function which can be a disadvantage in practice.\nThe criss-cross algorithm works on a standard pivot tableau (or on-the-fly calculated parts of a tableau, if implemented like the revised simplex method). In a general step, if the tableau is primal or dual infeasible, it selects one of the infeasible rows / columns as the pivot row / column using an index selection rule. An important property is that the selection is made on the union of the infeasible indices and the standard version of the algorithm does not distinguish column and row indices (that is, the column indices basic in the rows). If a row is selected then the algorithm uses the index selection rule to identify a position to a dual type pivot, while if a column is selected then it uses the index selection rule to find a row position and carries out a primal type pivot.\nThe time complexity of an algorithm counts the number of arithmetic operations sufficient for the algorithm to solve the problem. For example, Gaussian elimination requires on the order\u00a0of\u00a0D3 operations, and so it is said to have polynomial time-complexity, because its complexity is bounded by a cubic polynomial. There are examples of algorithms that do not have polynomial-time complexity. For example, a generalization of Gaussian elimination called Buchberger's algorithm has for its complexity an exponential function of the problem data (the degree of the polynomials and the number of variables of the multivariate polynomials). Because exponential functions eventually grow much faster than polynomial functions, an exponential complexity implies that an algorithm has slow performance on large problems.\nSeveral algorithms for linear programming\u2014Khachiyan's ellipsoidal algorithm, Karmarkar's projective algorithm, and central-path algorithms\u2014have polynomial time-complexity (in the worst case and thus on\u00a0average). The ellipsoidal and projective algorithms were published before the criss-cross algorithm.\nHowever, like the simplex algorithm of Dantzig, the criss-cross algorithm is not a polynomial-time algorithm for linear programming. Terlaky's criss-cross algorithm visits all the\u00a02D\u00a0corners of a (perturbed) cube in dimension\u00a0D, according to a paper of Roos; Roos's paper modifies the Klee\u2013Minty construction of a cube on which the simplex algorithm takes\u00a02D\u00a0steps.[3][4][5] Like the simplex algorithm, the criss-cross algorithm visits all\u00a08 corners of the three-dimensional cube in the worst case.\nWhen it is initialized at a random corner of the cube, the criss-cross algorithm visits only\u00a0D additional corners, however, according to a\u00a01994 paper by Fukuda and Namiki.[6][7] Trivially, the simplex algorithm takes on average\u00a0D steps for a cube.[8][15] Like the simplex algorithm, the criss-cross algorithm visits exactly\u00a03 additional corners of the three-dimensional cube on\u00a0average.\nThe criss-cross algorithm has been extended to solve more general problems than linear programming problems.\nThere are variants of the criss-cross algorithm for linear programming, for quadratic programming, and for the linear-complementarity problem with \"sufficient matrices\";[3][6][16][17][18][19] conversely, for linear complementarity problems, the criss-cross algorithm terminates finitely only if the matrix is a sufficient matrix.[18][19] A sufficient\u00a0matrix is a generalization both of a positive-definite matrix and of a P-matrix, whose principal\u00a0minors are each positive.[18][19][20] The criss-cross algorithm has been adapted also for linear-fractional programming.[1][2]\nThe criss-cross algorithm was used in an algorithm for enumerating all the vertices of a polytope, which was published by David Avis and Komei Fukuda in\u00a01992.[21] Avis and Fukuda presented an algorithm which finds the\u00a0v vertices of a polyhedron defined by a nondegenerate system of\u00a0n linear inequalities in\u00a0D dimensions (or, dually, the\u00a0v facets of the convex hull of\u00a0n points in\u00a0D dimensions, where each facet contains exactly\u00a0D given points) in time\u00a0O(nDv) and\u00a0O(nD) space.[22]\nThe criss-cross algorithm is often studied using the theory of oriented matroids (OMs), which is a combinatorial abstraction of linear-optimization theory.[17][23] Indeed, Bland's pivoting rule was based on his previous papers on oriented-matroid theory. However, Bland's rule exhibits cycling on some oriented-matroid linear-programming problems.[17] The first purely combinatorial algorithm for linear programming was devised by Michael\u00a0J. Todd.[17][24] Todd's algorithm was developed not only for linear-programming in the setting of oriented matroids, but also for quadratic-programming problems and linear-complementarity problems.[17][24] Todd's algorithm is complicated even to state, unfortunately, and its finite-convergence proofs are somewhat complicated.[17]\nThe criss-cross algorithm and its proof of finite termination can be simply stated and readily extend the setting of oriented matroids. The algorithm can be further simplified for linear feasibility problems, that is for linear systems with nonnegative variables; these problems can be formulated for oriented matroids.[14] The criss-cross algorithm has been adapted for problems that are more complicated than linear programming: There are oriented-matroid variants also for the quadratic-programming problem and for the linear-complementarity problem.[3][16][17]\nThe criss-cross algorithm is a simply stated algorithm for linear programming. It was the second fully combinatorial algorithm for linear programming. The partially combinatorial simplex algorithm of Bland cycles on some (nonrealizable) oriented matroids. The first fully combinatorial algorithm was published by Todd, and it is also like the simplex algorithm in that it preserves feasibility after the first feasible basis is generated; however, Todd's rule is complicated. The criss-cross algorithm is not a simplex-like algorithm, because it need not maintain feasibility. The criss-cross algorithm does not have polynomial time-complexity, however.\nResearchers have extended the criss-cross algorithm for many optimization-problems, including linear-fractional programming. The criss-cross algorithm can solve quadratic programming problems and linear complementarity problems, even in the setting of oriented matroids. Even when generalized, the criss-cross algorithm remains simply stated.\nRockafellar, R.\u00a0T. (1969). \"The elementary vectors of a subspace of \n\n\n\n\nR\n\nN\n\n\n\n\n{\\displaystyle R^{N}}\n\n (1967)\". In R. C. Bose and T.\u00a0A. Dowling. Combinatorial Mathematics and its Applications (PDF). The University of North Carolina Monograph Series in Probability and Statistics. Chapel Hill, North Carolina: University of North Carolina Press. pp.\u00a0104\u2013127. MR\u00a0278972. PDF reprint.\u00a0\nRockafellar was influenced by the earlier studies of Albert W. Tucker and George J. Minty. Tucker and Minty had studied the sign patterns of the matrices arising through the pivoting operations of Dantzig's simplex algorithm.", 
    "name": "Criss Cross Algorithm"
}
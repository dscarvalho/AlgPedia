{
    "about": "In numerical analysis, one or more guard digits can be used to reduce the amount of roundoff error.", 
    "name": "Guard Digit", 
    "classification": "Numerical Analysis", 
    "full_text": "In numerical analysis, one or more guard digits can be used to reduce the amount of roundoff error.\nFor example, suppose that the final result of a long, multi-step calculation can be safely rounded off to N decimal places. That is to say, the roundoff error introduced by this final roundoff makes a negligible contribution to the overall uncertainty.\nHowever, it is quite likely that it is not safe to round off the intermediate steps in the calculation to the same number of digits. Be aware that roundoff errors can accumulate. If M decimal places are used in the intermediate calculation, we say there are M\u2212N guard digits.\nGuard digits are also used in floating point operations in most computer systems. Given \n\n\n\n\n2\n\n1\n\n\n\u00d7\n\n0.100\n\n2\n\n\n\u2212\n\n2\n\n0\n\n\n\u00d7\n\n0.111\n\n2\n\n\n\n\n{\\displaystyle 2^{1}\\times 0.100_{2}-2^{0}\\times 0.111_{2}}\n\n we have to line up the binary points. This means we must add an extra digit to the first operand\u2014a guard digit. This gives us \n\n\n\n\n2\n\n1\n\n\n\u00d7\n\n0.1000\n\n2\n\n\n\u2212\n\n2\n\n1\n\n\n\u00d7\n\n0.0111\n\n2\n\n\n\n\n{\\displaystyle 2^{1}\\times 0.1000_{2}-2^{1}\\times 0.0111_{2}}\n\n. Performing this operation gives us \n\n\n\n\n2\n\n1\n\n\n\u00d7\n\n0.0001\n\n2\n\n\n\n\n{\\displaystyle 2^{1}\\times 0.0001_{2}}\n\n or \n\n\n\n\n2\n\n\u2212\n2\n\n\n\u00d7\n\n0.100\n\n2\n\n\n\n\n{\\displaystyle 2^{-2}\\times 0.100_{2}}\n\n. Without using a guard digit we have \n\n\n\n\n2\n\n1\n\n\n\u00d7\n\n0.100\n\n2\n\n\n\u2212\n\n2\n\n1\n\n\n\u00d7\n\n0.011\n\n2\n\n\n\n\n{\\displaystyle 2^{1}\\times 0.100_{2}-2^{1}\\times 0.011_{2}}\n\n, yielding \n\n\n\n\n2\n\n1\n\n\n\u00d7\n\n0.001\n\n2\n\n\n=\n\n\n{\\displaystyle 2^{1}\\times 0.001_{2}=}\n\n or \n\n\n\n\n2\n\n\u2212\n1\n\n\n\u00d7\n\n0.100\n\n2\n\n\n\n\n{\\displaystyle 2^{-1}\\times 0.100_{2}}\n\n. This gives us a relative error of 1. Therefore, we can see how important guard digits can be.\nAn example of the error caused by floating point roundoff is illustrated in the following C code.\nIt appears that the program should not terminate. Yet the output is\u00a0:\nAnother example is:\nTake 2 numbers:\n\n\n\n\n2.56\n\u2217\n\n10\n\n0\n\n\n\n\n{\\displaystyle 2.56*10^{0}}\n\n and \n\n\n\n2.34\n\u2217\n\n10\n\n2\n\n\n\n\n{\\displaystyle 2.34*10^{2}}\n\n\nwe bring the first number to the same power of \n\n\n\n10\n\n\n{\\displaystyle 10}\n\n as the second one:\n\n\n\n\n0.0256\n\u2217\n\n10\n\n2\n\n\n\n\n{\\displaystyle 0.0256*10^{2}}\n\n\nThe addition of the 2 numbers is:\nAfter padding the second number (i.e., \n\n\n\n2.34\n\u2217\n\n10\n\n2\n\n\n\n\n{\\displaystyle 2.34*10^{2}}\n\n) with two \n\n\n\n0\n\n\n{\\displaystyle 0}\n\ns, the bit after \n\n\n\n4\n\n\n{\\displaystyle 4}\n\n is the guard digit, and the bit after is the round digit. The result after rounding is \n\n\n\n2.37\n\n\n{\\displaystyle 2.37}\n\n as opposed to \n\n\n\n2.36\n\n\n{\\displaystyle 2.36}\n\n, without the extra bits (guard and round bits), i.e., by considering only \n\n\n\n0.02\n+\n2.34\n=\n2.36\n\n\n{\\displaystyle 0.02+2.34=2.36}\n\n. The error therefore is \n\n\n\n0.01\n\n\n{\\displaystyle 0.01}\n\n.\n", 
    "dbpedia_url": "http://dbpedia.org/resource/Guard_digit", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Guard_digit\n"
}
{
    "about": "In cryptography, ciphertext stealing (CTS) is a general method of using a block cipher mode of operation that allows for processing of messages that are not evenly divisible into blocks without resulting in any expansion of the ciphertext, at the cost of slightly increased complexity.", 
    "name": "Ciphertext Stealing", 
    "classification": "Cryptographic Algorithms", 
    "full_text": "In cryptography, ciphertext stealing (CTS) is a general method of using a block cipher mode of operation that allows for processing of messages that are not evenly divisible into blocks without resulting in any expansion of the ciphertext, at the cost of slightly increased complexity.\n\n\nCiphertext stealing is a technique for encrypting plaintext using a block cipher, without padding the message to a multiple of the block size, so the ciphertext is the same size as the plaintext.\nIt does this by altering processing of the last two blocks of the message. The processing of all but the last two blocks is unchanged, but a portion of the second-last block's ciphertext is \"stolen\" to pad the last plaintext block. The padded final block is then encrypted as usual.\nThe final ciphertext, for the last two blocks, consists of the partial penultimate block (with the \"stolen\" portion omitted) plus the full final block, which are the same size as the original plaintext.\nDecryption requires decrypting the final block first, then restoring the stolen ciphertext to the penultimate block, which can then be decrypted as usual.\nIn principle any block-oriented block cipher mode of operation can be used, but stream-cipher-like modes can already be applied to messages of arbitrary length without padding, so they do not benefit from this technique. The common modes of operation that are coupled with ciphertext stealing are Electronic Codebook (ECB) and Cipher Block Chaining (CBC).\nCiphertext stealing for ECB mode requires the plaintext to be longer than one block. A possible workaround is to use a stream cipher-like block cipher mode of operation when the plaintext length is one block or less, such as the CTR, CFB or OFB modes.\nCiphertext stealing for CBC mode doesn't necessarily require the plaintext to be longer than one block. In the case where the plaintext is one block long or less, the Initialization vector (IV) can act as the prior block of ciphertext. In this case a modified IV must be sent to the receiver. This may not be possible in situations where the IV can not be freely chosen by the sender when the ciphertext is sent (e.g., when the IV is a derived or pre-established value), and in this case ciphertext stealing for CBC mode can only occur in plaintexts longer than one block.\nTo implement CTS encryption or decryption for data of unknown length, the implementation must delay processing (and buffer) the two most recent blocks of data, so that they can be properly processed at the end of the data stream.\nThere are several different ways to arrange the ciphertext for transmission. The ciphertext bits are the same in all cases, just transmitted in a different order, so the choice has no security implications; it is purely one of implementation convenience.\nThe numbering here is taken from Dworkin, who describes them all. The third is the most popular, and described by Daemen and Schneier; Meyer describes a related, but incompatible scheme (with respect to bit ordering and key use).\nArguably the most obvious way to arrange the ciphertext is to transmit the truncated penultimate block, followed by the full final block. This is not convenient for the receiver for two reasons:\nThis does have the advantage that, if the final plaintext block happens to be a multiple of the block size, the ciphertext is identical to that of the original mode of operation without ciphertext stealing.\nIt is often more convenient to swap the final two ciphertext blocks, so the ciphertext ends with the full final block, followed by the truncated penultimate block. This results in naturally aligned ciphertext blocks.\nIn order to maintain compatibility with the non-stealing modes, option CS2 performs this swap only if the amount of stolen ciphertext is non-zero, i.e. the original message was not a multiple of the block size.\nThis maintains natural alignment, and compatibility with the non-stealing modes, but requires treating the cases of aligned and unaligned message size differently.\nThe most popular alternative swaps the final two ciphertext blocks unconditionally. This is the ordering used in the descriptions below.\nIn order to encrypt or decrypt data, use the standard block cipher mode of operation on all but the last two blocks of data.\nThe following steps describe how to handle the last two blocks of the plaintext, called Pn\u22121 and Pn, where the length of Pn\u22121 equals the block size of the cipher in bits, B; the length of the last block, Pn, is M bits; and K is the key that is in use. M can range from 1 to B, inclusive, so Pn could possibly be a complete block. The CBC mode description also makes use of the ciphertext block just previous to the blocks concerned, Cn\u22122, which may in fact be the IV if the plaintext fits within two blocks.\nFor this description, the following functions and operators are used:\nCiphertext stealing in ECB mode introduces an inter-block dependency within the last two blocks, resulting in altered error propagation behavior for the last two blocks.\nA bit error in the transmission of Cn\u22121 would result in the block-wide corruption of both Pn\u22121 and Pn. A bit error in the transmission of Cn would result in the block-wide corruption of Pn\u22121. This is a significant change from ECB's error propagation behavior.\nIn CBC, there is already interaction between processing of different adjacent blocks, so CTS has less conceptual impact in this mode. Error propagation is affected.\nFor CBC ciphertext stealing, there is a clever (but opaque) method of implementing the described ciphertext stealing process using a standard CBC interface. Using this method imposes a performance penalty in the decryption stage of one extra block decryption operation over what would be necessary using a dedicated implementation.\nA bit error in the transmission of Cn\u22121 would result in the block-wide corruption of both Pn\u22121 and Pn. A bit error in the transmission of Cn would result in a corresponding bit error in Pn, and in the block-wide corruption of Pn\u22121.", 
    "dbpedia_url": "http://dbpedia.org/resource/Ciphertext_stealing", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Ciphertext_stealing\n"
}
{
    "about": "In bioinformatics, neighbor joining is a bottom-up (agglomerative) clustering method for the creation of phylogenetic trees, created by Naruya Saitou and Masatoshi Nei in 1987.[2] Usually used for trees based on DNA or protein sequence data, the algorithm requires knowledge of the distance between each pair of taxa (e.g., species or sequences) to form the tree.[3]", 
    "name": "Neighbor Joining", 
    "classification": "Bioinformatics Algorithms", 
    "full_text": "In bioinformatics, neighbor joining is a bottom-up (agglomerative) clustering method for the creation of phylogenetic trees, created by Naruya Saitou and Masatoshi Nei in 1987.[2] Usually used for trees based on DNA or protein sequence data, the algorithm requires knowledge of the distance between each pair of taxa (e.g., species or sequences) to form the tree.[3]\n\n\nNeighbor joining takes as input a distance matrix specifying the distance between each pair of taxa. The algorithm starts with a completely unresolved tree, whose topology corresponds to that of a star network, and iterates over the following steps until the tree is completely resolved and all branch lengths are known:\nBased on a distance matrix relating the \n\n\n\nn\n\n\n{\\displaystyle n}\n\n taxa, calculate \n\n\n\nQ\n\n\n{\\displaystyle Q}\n\n as follows:\n\n\n\n\nQ\n(\ni\n,\nj\n)\n=\n(\nn\n\u2212\n2\n)\nd\n(\ni\n,\nj\n)\n\u2212\n\n\u2211\n\nk\n=\n1\n\n\nn\n\n\nd\n(\ni\n,\nk\n)\n\u2212\n\n\u2211\n\nk\n=\n1\n\n\nn\n\n\nd\n(\nj\n,\nk\n)\n\n\n{\\displaystyle Q(i,j)=(n-2)d(i,j)-\\sum _{k=1}^{n}d(i,k)-\\sum _{k=1}^{n}d(j,k)}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(1)\nwhere \n\n\n\nd\n(\ni\n,\nj\n)\n\n\n{\\displaystyle d(i,j)}\n\n is the distance between taxa \n\n\n\ni\n\n\n{\\displaystyle i}\n\n and \n\n\n\nj\n\n\n{\\displaystyle j}\n\n.\nFor each of the taxa in the pair being joined, use the following formula to calculate the distance to the new node:\n\n\n\n\n\u03b4\n(\nf\n,\nu\n)\n=\n\n\n1\n2\n\n\nd\n(\nf\n,\ng\n)\n+\n\n\n1\n\n2\n(\nn\n\u2212\n2\n)\n\n\n\n\n[\n\n\u2211\n\nk\n=\n1\n\n\nn\n\n\nd\n(\nf\n,\nk\n)\n\u2212\n\n\u2211\n\nk\n=\n1\n\n\nn\n\n\nd\n(\ng\n,\nk\n)\n]\n\n\n\n\n{\\displaystyle \\delta (f,u)={\\frac {1}{2}}d(f,g)+{\\frac {1}{2(n-2)}}\\left[\\sum _{k=1}^{n}d(f,k)-\\sum _{k=1}^{n}d(g,k)\\right]\\quad }\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(2)\nand:\nTaxa \n\n\n\nf\n\n\n{\\displaystyle f}\n\n and \n\n\n\ng\n\n\n{\\displaystyle g}\n\n are the paired taxa and \n\n\n\nu\n\n\n{\\displaystyle u}\n\n is the newly created node. The branches joining \n\n\n\nf\n\n\n{\\displaystyle f}\n\n and \n\n\n\nu\n\n\n{\\displaystyle u}\n\n and \n\n\n\ng\n\n\n{\\displaystyle g}\n\n and \n\n\n\nu\n\n\n{\\displaystyle u}\n\n, and their lengths, \n\n\n\n\u03b4\n(\nf\n,\nu\n)\n\n\n{\\displaystyle \\delta (f,u)}\n\n and \n\n\n\n\u03b4\n(\ng\n,\nu\n)\n\n\n{\\displaystyle \\delta (g,u)}\n\n are part of the tree which is gradually being created; they neither affect nor are affected by later neighbor-joining steps.\nFor each taxon not considered in the previous step, we calculate the distance to the new node as follows:\n\n\n\n\nd\n(\nu\n,\nk\n)\n=\n\n\n1\n2\n\n\n[\nd\n(\nf\n,\nk\n)\n+\nd\n(\ng\n,\nk\n)\n\u2212\nd\n(\nf\n,\ng\n)\n]\n\n\n{\\displaystyle d(u,k)={\\frac {1}{2}}[d(f,k)+d(g,k)-d(f,g)]}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(3)\nwhere \n\n\n\nu\n\n\n{\\displaystyle u}\n\n is the new node, \n\n\n\nk\n\n\n{\\displaystyle k}\n\n is the node which we want to calculate the distance to and \n\n\n\nf\n\n\n{\\displaystyle f}\n\n and \n\n\n\ng\n\n\n{\\displaystyle g}\n\n are the members of the pair just joined.\nNeighbor joining on a set of \n\n\n\nn\n\n\n{\\displaystyle n}\n\n taxa requires \n\n\n\nn\n\u2212\n3\n\n\n{\\displaystyle n-3}\n\n iterations. At each step one has to build and search a \n\n\n\nQ\n\n\n{\\displaystyle Q}\n\n matrix. Initially the \n\n\n\nQ\n\n\n{\\displaystyle Q}\n\n matrix is size \n\n\n\nn\n\u00d7\nn\n\n\n{\\displaystyle n\\times n}\n\n, then the next step it is \n\n\n\n(\nn\n\u2212\n1\n)\n\u00d7\n(\nn\n\u2212\n1\n)\n\n\n{\\displaystyle (n-1)\\times (n-1)}\n\n, etc. Implementing this in a straightforward way leads to an algorithm with a time complexity of \n\n\n\nO\n(\n\nn\n\n3\n\n\n)\n\n\n{\\displaystyle O(n^{3})}\n\n; implementations exist which use heuristics to do much better than this on average.\n\nLet us assume that we have five taxa \n\n\n\n(\na\n,\nb\n,\nc\n,\nd\n,\ne\n)\n\n\n{\\displaystyle (a,b,c,d,e)}\n\n and the following distance matrix \n\n\n\nD\n\n\n{\\displaystyle D}\n\n:\nWe calculate the \n\n\n\n\nQ\n\n1\n\n\n\n\n{\\displaystyle Q_{1}}\n\n values by equation (1). For example:\nWe obtain the following values for the \n\n\n\n\nQ\n\n1\n\n\n\n\n{\\displaystyle Q_{1}}\n\n matrix (the diagonal elements of the matrix are not used and are omitted here):\nIn the example above, \n\n\n\n\nQ\n\n1\n\n\n(\na\n,\nb\n)\n=\n\u2212\n50\n\n\n{\\displaystyle Q_{1}(a,b)=-50}\n\n. This is the smallest value of \n\n\n\n\nQ\n\n1\n\n\n\n\n{\\displaystyle Q_{1}}\n\n, so we join elements \n\n\n\na\n\n\n{\\displaystyle a}\n\n and \n\n\n\nb\n\n\n{\\displaystyle b}\n\n.\nLet \n\n\n\nu\n\n\n{\\displaystyle u}\n\n denote the new node. By equation (2), above, the branches joining \n\n\n\na\n\n\n{\\displaystyle a}\n\n and \n\n\n\nb\n\n\n{\\displaystyle b}\n\n to \n\n\n\nu\n\n\n{\\displaystyle u}\n\n then have lengths:\nWe then proceed to update the initial distance matrix \n\n\n\nD\n\n\n{\\displaystyle D}\n\n into a new distance matrix \n\n\n\n\nD\n\n1\n\n\n\n\n{\\displaystyle D_{1}}\n\n (see below), reduced in size by one row and one column because of the joining of \n\n\n\na\n\n\n{\\displaystyle a}\n\n with \n\n\n\nb\n\n\n{\\displaystyle b}\n\n into their neighbor \n\n\n\nu\n\n\n{\\displaystyle u}\n\n. Using equation (3) above, we compute the distance from \n\n\n\nu\n\n\n{\\displaystyle u}\n\n to each of the other nodes besides \n\n\n\na\n\n\n{\\displaystyle a}\n\n and \n\n\n\nb\n\n\n{\\displaystyle b}\n\n. In this case, we obtain:\nThe resulting distance matrix \n\n\n\n\nD\n\n1\n\n\n\n\n{\\displaystyle D_{1}}\n\n is:\nBold values in \n\n\n\n\nD\n\n1\n\n\n\n\n{\\displaystyle D_{1}}\n\n correspond to the newly calculated distances, whereas italicized values are not affected by the matrix update as they correspond to distances between elements not involved in the first joining of taxa.\nThe corresponding \n\n\n\n\nQ\n\n2\n\n\n\n\n{\\displaystyle Q_{2}}\n\n matrix is:\nWe may choose either to join \n\n\n\nu\n\n\n{\\displaystyle u}\n\n and \n\n\n\nc\n\n\n{\\displaystyle c}\n\n, or to join \n\n\n\nd\n\n\n{\\displaystyle d}\n\n and \n\n\n\ne\n\n\n{\\displaystyle e}\n\n; both pairs have the minimal \n\n\n\n\nQ\n\n2\n\n\n\n\n{\\displaystyle Q_{2}}\n\n value of \n\n\n\n\u2212\n28\n\n\n{\\displaystyle -28}\n\n, and either choice leads to the same result. For concreteness, let us join \n\n\n\nu\n\n\n{\\displaystyle u}\n\n and \n\n\n\nc\n\n\n{\\displaystyle c}\n\n and call the new node \n\n\n\nv\n\n\n{\\displaystyle v}\n\n.\nThe lengths of the branches joining \n\n\n\nu\n\n\n{\\displaystyle u}\n\n and \n\n\n\nc\n\n\n{\\displaystyle c}\n\n to \n\n\n\nv\n\n\n{\\displaystyle v}\n\n can be calculated:\nThe joining of the elements and the branch length calculation help drawing the neighbor joining tree as shown in the figure.\nThe updated distance matrix \n\n\n\n\nD\n\n2\n\n\n\n\n{\\displaystyle D_{2}}\n\n for the remaining 3 nodes, \n\n\n\nv\n\n\n{\\displaystyle v}\n\n, \n\n\n\nd\n\n\n{\\displaystyle d}\n\n, and \n\n\n\ne\n\n\n{\\displaystyle e}\n\n, is now computed:\nThe tree topology is fully resolved at this point. However, for clarity, we can calculate the \n\n\n\n\nQ\n\n3\n\n\n\n\n{\\displaystyle Q_{3}}\n\n matrix. For example:\nFor concreteness, let us join \n\n\n\nv\n\n\n{\\displaystyle v}\n\n and \n\n\n\nd\n\n\n{\\displaystyle d}\n\n and call the last node \n\n\n\nw\n\n\n{\\displaystyle w}\n\n. The lengths of the three remaining branches can be calculated:\nThe neighbor joining tree is now complete, as shown in the figure.\nThis example represents an idealized case: note that if we move from any taxon to any other along the branches of the tree, and sum the lengths of the branches traversed, the result is equal to the distance between those taxa in the input distance matrix. For example, going from \n\n\n\nd\n\n\n{\\displaystyle d}\n\n to \n\n\n\nb\n\n\n{\\displaystyle b}\n\n we have \n\n\n\n2\n+\n2\n+\n3\n+\n3\n=\n10\n\n\n{\\displaystyle 2+2+3+3=10}\n\n. A distance matrix whose distances agree in this way with some tree is said to be 'additive', a property which is rare in practice. Nonetheless it is important to note that, given an additive distance matrix as input, neighbor joining is guaranteed to find the tree whose distances between taxa agree with it.\nNeighbor joining may be viewed as a greedy algorithm for optimizing a tree according to the 'balanced minimum evolution'[4] (BME) criterion. For each topology, BME defines the tree length (sum of branch lengths) to be a particular weighted sum of the distances in the distance matrix, with the weights depending on the topology. The BME optimal topology is the one which minimizes this tree length. Neighbor joining at each step greedily joins that pair of taxa which will give the greatest decrease in the estimated tree length. This procedure is not guaranteed to find the topology which is optimal by the BME criterion, although it often does and is usually quite close.\nThe main virtue of NJ is that it is fast[5]:466 as compared to least squares, maximum parsimony and maximum likelihood methods.[5] This makes it practical for analyzing large data sets (hundreds or thousands of taxa) and for bootstrapping, for which purposes other means of analysis (e.g. maximum parsimony, maximum likelihood) may be computationally prohibitive.\nNeighbor joining has the property that if the input distance matrix is correct, then the output tree will be correct. Furthermore, the correctness of the output tree topology is guaranteed as long as the distance matrix is 'nearly additive', specifically if each entry in the distance matrix differs from the true distance by less than half of the shortest branch length in the tree.[6] In practice the distance matrix rarely satisfies this condition, but neighbor joining often constructs the correct tree topology anyway.[7] The correctness of neighbor joining for nearly additive distance matrices implies that it is statistically consistent under many models of evolution; given data of sufficient length, neighbor joining will reconstruct the true tree with high probability. Compared with UPGMA and WPGMA, neighbor joining has the advantage that it does not assume all lineages evolve at the same rate (molecular clock hypothesis).\nNevertheless, neighbor joining has been largely superseded by phylogenetic methods that do not rely on distance measures and offer superior accuracy under most conditions.[citation needed] Neighbor joining has the undesirable feature that it often assigns negative lengths to some of the branches.\nThere are many programs available implementing neighbor joining. RapidNJ and NINJA are fast implementations with typical run times proportional to approximately the square of the number of taxa. BIONJ and Weighbor are variants of neighbor joining which improve on its accuracy by making use of the fact that the shorter distances in the distance matrix are generally better known than the longer distances. FastME is an implementation of the closely related balanced minimum evolution method.", 
    "dbpedia_url": "http://dbpedia.org/resource/Neighbor_joining", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Neighbor_joining\n"
}
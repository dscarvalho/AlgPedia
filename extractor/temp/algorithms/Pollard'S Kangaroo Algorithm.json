{
    "about": "In computational number theory and computational algebra, Pollard's kangaroo algorithm (also Pollard's lambda algorithm, see Naming below) is an algorithm for solving the discrete logarithm problem. The algorithm was introduced in 1978 by the number theorist J. M. Pollard, in the same paper [1] as his better-known \u03c1 algorithm for solving the same problem. Although Pollard described the application of his algorithm to the discrete logarithm problem in the multiplicative group of units modulo a prime p, it is in fact a generic discrete logarithm algorithm\u2014it will work in any finite cyclic group.", 
    "name": "Pollard'S Kangaroo Algorithm", 
    "classification": "Computer Algebra", 
    "full_text": "In computational number theory and computational algebra, Pollard's kangaroo algorithm (also Pollard's lambda algorithm, see Naming below) is an algorithm for solving the discrete logarithm problem. The algorithm was introduced in 1978 by the number theorist J. M. Pollard, in the same paper [1] as his better-known \u03c1 algorithm for solving the same problem. Although Pollard described the application of his algorithm to the discrete logarithm problem in the multiplicative group of units modulo a prime p, it is in fact a generic discrete logarithm algorithm\u2014it will work in any finite cyclic group.\n\n\nSuppose \n\n\n\nG\n\n\n{\\displaystyle G}\n\n is a finite cyclic group of order \n\n\n\nn\n\n\n{\\displaystyle n}\n\n which is generated by the element \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n, and we seek to find the discrete logarithm \n\n\n\nx\n\n\n{\\displaystyle x}\n\n of the element \n\n\n\n\u03b2\n\n\n{\\displaystyle \\beta }\n\n to the base \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n. In other words, we seek \n\n\n\nx\n\u2208\n\nZ\n\nn\n\n\n\n\n{\\displaystyle x\\in Z_{n}}\n\n such that \n\n\n\n\n\u03b1\n\nx\n\n\n=\n\u03b2\n\n\n{\\displaystyle \\alpha ^{x}=\\beta }\n\n. The lambda algorithm allows us to search for \n\n\n\nx\n\n\n{\\displaystyle x}\n\n in some subset \n\n\n\n{\na\n,\n\u2026\n,\nb\n}\n\u2282\n\nZ\n\nn\n\n\n\n\n{\\displaystyle \\{a,\\ldots ,b\\}\\subset Z_{n}}\n\n. We may search the entire range of possible logarithms by setting \n\n\n\na\n=\n0\n\n\n{\\displaystyle a=0}\n\n and \n\n\n\nb\n=\nn\n\u2212\n1\n\n\n{\\displaystyle b=n-1}\n\n, although in this case Pollard's rho algorithm is more efficient. We proceed as follows:\n1. Choose a set \n\n\n\nS\n\n\n{\\displaystyle S}\n\n of integers and define a pseudorandom map \n\n\n\nf\n:\nG\n\u2192\nS\n\n\n{\\displaystyle f:G\\rightarrow S}\n\n.\n2. Choose an integer \n\n\n\nN\n\n\n{\\displaystyle N}\n\n and compute a sequence of group elements \n\n\n\n{\n\nx\n\n0\n\n\n,\n\nx\n\n1\n\n\n,\n\u2026\n,\n\nx\n\nN\n\n\n}\n\n\n{\\displaystyle \\{x_{0},x_{1},\\ldots ,x_{N}\\}}\n\n according to:\n3. Compute\nObserve that:\n4. Begin computing a second sequence of group elements \n\n\n\n{\n\ny\n\n0\n\n\n,\n\ny\n\n1\n\n\n,\n\u2026\n}\n\n\n{\\displaystyle \\{y_{0},y_{1},\\ldots \\}}\n\n according to:\nand a corresponding sequence of integers \n\n\n\n{\n\nd\n\n0\n\n\n,\n\nd\n\n1\n\n\n,\n\u2026\n}\n\n\n{\\displaystyle \\{d_{0},d_{1},\\ldots \\}}\n\n according to:\nObserve that:\n5. Stop computing terms of \n\n\n\n{\n\ny\n\ni\n\n\n}\n\n\n{\\displaystyle \\{y_{i}\\}}\n\n and \n\n\n\n{\n\nd\n\ni\n\n\n}\n\n\n{\\displaystyle \\{d_{i}\\}}\n\n when either of the following conditions are met:\nPollard gives the time complexity of the algorithm as \n\n\n\n\n\nO\n(\n\n\nb\n\u2212\na\n\n\n)\n\n\n\n\n{\\displaystyle {\\scriptstyle O({\\sqrt {b-a}})}}\n\n, based on a probabilistic argument which follows from the assumption that f acts pseudorandomly. Note that when the size of the set {a,\u00a0\u2026,\u00a0b} to be searched is measured in bits, as is normal in complexity theory, the set has size log(b\u2009\u2212\u2009a), and so the algorithm's complexity is \n\n\n\n\n\nO\n(\n\n\nb\n\u2212\na\n\n\n)\n=\nO\n(\n\n2\n\n\n\n1\n2\n\n\nlog\n\u2061\n(\nb\n\u2212\na\n)\n\n\n)\n\n\n\n\n{\\displaystyle {\\scriptstyle O({\\sqrt {b-a}})=O(2^{{\\frac {1}{2}}\\log(b-a)})}}\n\n, which is exponential in the problem size. For this reason, Pollard's lambda algorithm is considered an exponential time algorithm. For an example of a subexponential time discrete logarithm algorithm, see the index calculus algorithm.\nThe algorithm is well known by two names.\nThe first is \"Pollard's kangaroo algorithm\". This name is a reference to an analogy used in the paper presenting the algorithm, where the algorithm is explained in terms of using a tame kangaroo to trap a wild kangaroo. Pollard has explained[2] that this analogy was inspired by a \"fascinating\" article published in the same issue of Scientific American as an exposition of the RSA public key cryptosystem. The article[3] described an experiment in which a kangaroo's \"energetic cost of locomotion, measured in terms of oxygen consumption at various speeds, was determined by placing kangaroos on a treadmill\".\nThe second is \"Pollard's lambda algorithm\". Much like the name of another of Pollard's discrete logarithm algorithms, Pollard's rho algorithm, this name refers to the similarity between a visualisation of the algorithm and the Greek letter lambda (\n\n\n\n\u03bb\n\n\n{\\displaystyle \\lambda }\n\n). The shorter stroke of the letter lambda corresponds to the sequence \n\n\n\n{\n\nx\n\ni\n\n\n}\n\n\n{\\displaystyle \\{x_{i}\\}}\n\n, since it starts from the position b to the right of x. Accordingly, the longer stroke corresponds to the sequence \n\n\n\n{\n\ny\n\ni\n\n\n}\n\n\n{\\displaystyle \\{y_{i}\\}}\n\n, which \"collides with\" the first sequence (just like the strokes of a lambda intersect) and then follows it subsequently.\nPollard has expressed a preference for the name \"kangaroo algorithm\",[4] as this avoids confusion with some parallel versions of his rho algorithm, which have also been called \"lambda algorithms\".", 
    "dbpedia_url": "http://dbpedia.org/resource/Pollard's_kangaroo_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Pollard's_kangaroo_algorithm\n"
}
{
    "about": "In digital communications, a turbo equalizer is a type of receiver used to receive a message corrupted by a communication channel with intersymbol interference (ISI). It approaches the performance of a maximum a posteriori (MAP) receiver via iterative message passing between a soft-in soft-out (SISO) equalizer and a SISO decoder.[1] It is related to turbo codes in that a turbo equalizer may be considered a type of iterative decoder if the channel is viewed as a non-redundant convolutional code. The turbo equalizer is different from classic a turbo-like code, however, in that the 'channel code' adds no redundancy and therefore can only be used to remove non-gaussian noise.", 
    "name": "Turbo Equalizer", 
    "classification": "Signal Processing", 
    "full_text": "In digital communications, a turbo equalizer is a type of receiver used to receive a message corrupted by a communication channel with intersymbol interference (ISI). It approaches the performance of a maximum a posteriori (MAP) receiver via iterative message passing between a soft-in soft-out (SISO) equalizer and a SISO decoder.[1] It is related to turbo codes in that a turbo equalizer may be considered a type of iterative decoder if the channel is viewed as a non-redundant convolutional code. The turbo equalizer is different from classic a turbo-like code, however, in that the 'channel code' adds no redundancy and therefore can only be used to remove non-gaussian noise.\n\n\nTurbo codes were invented by Claude Berrou in 1990\u20131991. In 1993, turbo codes were introduced publicly via a paper listing authors Berrou, Glavieux, and Thitimajshima.[2] In 1995 a novel extension of the turbo principle was applied to an equalizer by Douillard, J\u00e9z\u00e9quel, and Berrou.[3] In particular, they formulated the ISI receiver problem as a turbo code decoding problem, where the channel is thought of as a rate 1 convolutional code and the error correction coding is the second code. In 1997, Glavieux, Laot, and Labat demonstrated that a linear equalizer could be used in a turbo equalizer framework.[4] This discovery made turbo equalization computationally efficient enough to be applied to a wide range of applications.[5]\nBefore discussing turbo equalizers, it is necessary to understand the basic receiver in the context of a communication system. This is the topic of this section.\nAt the transmitter, information bits are encoded. Encoding adds redundancy by mapping the information bits \n\n\n\na\n\n\n{\\displaystyle a}\n\n to a longer bit vector \u2013 the code bit vector \n\n\n\nb\n\n\n{\\displaystyle b}\n\n. The encoded bits \n\n\n\nb\n\n\n{\\displaystyle b}\n\n are then interleaved. Interleaving permutes the order of the code bits \n\n\n\nb\n\n\n{\\displaystyle b}\n\n resulting in bits \n\n\n\nc\n\n\n{\\displaystyle c}\n\n. The main reason for doing this is to insulate the information bits from bursty noise. Next, the symbol mapper maps the bits \n\n\n\nc\n\n\n{\\displaystyle c}\n\n into complex symbols \n\n\n\nx\n\n\n{\\displaystyle x}\n\n. These digital symbols are then converted into analog symbols with a D/A converter. Typically the signal is then up-converted to pass band frequencies by mixing it with a carrier signal. This is a necessary step for complex symbols. The signal is then ready to be transmitted through the channel.\nAt the receiver, the operations performed by the transmitter are reversed to recover \n\n\n\n\n\n\na\n^\n\n\n\n\n\n{\\displaystyle {\\hat {a}}}\n\n, an estimate of the information bits. The down-converter mixes the signal back down to baseband. The A/D converter then samples the analog signal, making it digital. At this point, \n\n\n\ny\n\n\n{\\displaystyle y}\n\n is recovered. The signal \n\n\n\ny\n\n\n{\\displaystyle y}\n\n is what would be received if \n\n\n\nx\n\n\n{\\displaystyle x}\n\n were transmitted through the digital baseband equivalent of the channel plus noise. The signal is then equalized. The equalizer attempts to unravel the ISI in the received signal to recover the transmitted symbols. It then outputs the bits \n\n\n\n\n\n\nc\n^\n\n\n\n\n\n{\\displaystyle {\\hat {c}}}\n\n associated with those symbols. The vector \n\n\n\n\n\n\nc\n^\n\n\n\n\n\n{\\displaystyle {\\hat {c}}}\n\n may represent hard decisions on the bits or soft decisions. If the equalizer makes soft decisions, it outputs information relating to the probability of the bit being a 0 or a 1. If the equalizer makes hard decisions on the bits, it quantizes the soft bit decisions and outputs either a 0 or a 1. Next, the signal is deinterleaved which is a simple permutation transformation that undoes the transformation the interleaver executed. Finally, the bits are decoded by the decoder. The decoder estimates \n\n\n\n\n\n\na\n^\n\n\n\n\n\n{\\displaystyle {\\hat {a}}}\n\n from \n\n\n\n\n\n\nb\n^\n\n\n\n\n\n{\\displaystyle {\\hat {b}}}\n\n.\nA diagram of the communication system is shown below. In this diagram, the channel is the equivalent baseband channel, meaning that it encompasses the D/A, the up converter, the channel, the down converter, and the A/D.\nThe block diagram of a communication system employing a turbo equalizer is shown below. The turbo equalizer encompasses the equalizer, the decoder, and the blocks in between.\nThe difference between a turbo equalizer and a standard equalizer is the feedback loop from the decoder to the equalizer. Due to the structure of the code, the decoder not only estimates the information bits \n\n\n\na\n\n\n{\\displaystyle a}\n\n, but it also discovers new information about the coded bits \n\n\n\nb\n\n\n{\\displaystyle b}\n\n. The decoder is therefore able to output extrinsic information, \n\n\n\n\n\n\nb\n~\n\n\n\n\n\n{\\displaystyle {\\tilde {b}}}\n\n about the likelihood that a certain code bit stream was transmitted. Extrinsic information is new information that is not derived from information input to the block. This extrinsic information is then mapped back into information about the transmitted symbols \n\n\n\nx\n\n\n{\\displaystyle x}\n\n for use in the equalizer. These extrinsic symbol likelihoods, \n\n\n\n\n\n\nx\n~\n\n\n\n\n\n{\\displaystyle {\\tilde {x}}}\n\n, are fed into the equalizer as a priori symbol probabilities. The equalizer uses this a priori information as well as the input signal \n\n\n\ny\n\n\n{\\displaystyle y}\n\n to estimate extrinsic probability information about the transmitted symbols. The a priori information fed to the equalizer is initialized to 0, meaning that the initial estimate \n\n\n\n\n\n\na\n^\n\n\n\n\n\n{\\displaystyle {\\hat {a}}}\n\n made by the turbo equalizer is identical to the estimate made by the standard receiver. The information \n\n\n\n\n\n\nx\n^\n\n\n\n\n\n{\\displaystyle {\\hat {x}}}\n\n is then mapped back into information about \n\n\n\nb\n\n\n{\\displaystyle b}\n\n for use by the decoder. The turbo equalizer repeats this iterative process until a stopping criterion is reached.\nIn practical turbo equalization implementations, an additional issue need to be considered. The channel state information (CSI) that the equalizer operates on comes from some channel estimation technique, and hence un-reliable. Firstly, in order to improve the reliability of the CSI, it is desirable to include the channel estimation block also into the turbo equalization loop, and parse soft or hard decision directed channel estimation within each turbo equalization iteration.[6][7] Secondly, incorporating the presence of CSI uncertainty into the turbo equalizer design leads to a more robust approach with significant performance gains in practical scenarios.[8][9]", 
    "dbpedia_url": "http://dbpedia.org/resource/Turbo_equalizer", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Turbo_equalizer\n"
}
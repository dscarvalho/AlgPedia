{
    "about": "Multipath routing is the routing technique of using multiple alternative paths through a network, which can yield a variety of benefits such as fault tolerance, increased bandwidth, or improved security. The multiple paths computed might be overlapped, edge-disjointed or node-disjointed with each other. Extensive research has been done on multipath routing techniques, but multipath routing is not yet widely deployed in practice.[citation needed]", 
    "name": "Multipath Routing", 
    "classification": "Routing Algorithms", 
    "full_text": "Multipath routing is the routing technique of using multiple alternative paths through a network, which can yield a variety of benefits such as fault tolerance, increased bandwidth, or improved security. The multiple paths computed might be overlapped, edge-disjointed or node-disjointed with each other. Extensive research has been done on multipath routing techniques, but multipath routing is not yet widely deployed in practice.[citation needed]\n\n\nTo improve performance or fault tolerance:\nCMR (Concurrent Multipath Routing) is often taken to mean simultaneous management and utilization of multiple available paths for the transmission of streams of data emanating from an application or multiple applications. In this form, each stream is assigned a separate path, uniquely to the extent supported by the number of paths available. If there are more streams than available paths, some streams will share paths. This provides better utilization of available bandwidth by creating multiple active transmission queues. It also provides a measure of fault tolerance in that, should a path fail, only the traffic assigned to that path is affected, the other paths continuing to serve their stream flows; there is also, ideally, an alternative path immediately available upon which to continue or restart the interrupted stream.\nThis method provides better transmission performance and fault tolerance by providing:\nShortcomings of this method are:\nA more powerful form of CMR (true CMR) goes beyond merely presenting paths to applications to which they can bind. True CMR aggregates all available paths into a single, virtual path. All applications offer their packets to this virtual path, which is de-muxed at the Network Layer, the packets then being distributed to the actual paths via some method such as round-robin or weighted fair queuing. Should a link or relay node fail, thus invalidating one or more paths, succeeding packets are not directed to that (/those) path(s). The stream continues uninterrupted, transparently to the application. This method provides significant performance benefits over the former:\nIt is noted that true CMR can, by its nature, cause out-of-order delivery (OOOD) of packets, which is severely debilitating for standard TCP. Standard TCP, however, has been exhaustively proven to be inappropriate for use in challenged wireless environments and must, in any case, be augmented by a facility, such as a TCP gateway, that is designed to meet the challenge. One such gateway tool is SCPS-TP, which, through its Selective Negative Acknowledgement (SNACK) capability, deals successfully with the OOOD problem.\nAnother important benefit of true CMR, desperately needed in wireless network communications, is its support for enhanced security. Simply put, for an exchange to be compromised, multiple of the routes it traverses must be compromised. The reader is referred to the references in the \u201cTo improve network security\u201d section for discussion on this topic.\nIn networking and in graph theory, capillary routing, for a given network, is a multi-path solution between a pair of source and destination nodes. Unlike shortest-path routing or max-flow routing for any network topology only one capillary routing solution exists.\nCapillary routing can be constructed by an iterative linear programming (LP) process transforming a single-path flow into a capillary route. First minimize the maximal value of the load of all links by minimizing an upper bound value applied to all links. The full mass of the flow will be split equally across the possible parallel routes. Find the bottleneck links of the first layer (see below) and fix their load at the found minimum. Minimize similarly the maximal load of all remaining links without the bottleneck links of the first layer. This second iteration further refines the path diversity. Find the bottleneck links of the second layer. Minimize the maximal load of all remaining links, but now without the bottlenecks of the second layer as well. Repeat this iteration until the entire communication footprint is enclosed in the bottlenecks of the constructed layers.\nAt each layer, after minimizing the maximal load of links, the bottlenecks of the layer are discovered in a bottleneck hunting loop. At each iteration of the hunting loop, we minimize the load of the traffic over all links having maximal load and being suspected as bottlenecks. Links not maintaining their load at the maximum are removed from the suspect list. The bottleneck hunting loop stops if there are no more links to remove.\nThe animated image shows capillary routing footprint between a pair of nodes in a mobile ad-hoc network.\nTo improve network security:", 
    "dbpedia_url": "http://dbpedia.org/resource/Multipath_routing", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Multipath_routing\n"
}
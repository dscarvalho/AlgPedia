{
    "about": "The backward propagation of errors or backpropagation, is a common method of training artificial neural networks and used in conjunction with an optimization method such as gradient descent. The algorithm repeats a two phase cycle, propagation and weight update. When an input vector is presented to the network, it is propagated forward through the network, layer by layer, until it reaches the output layer. The output of the network is then compared to the desired output, using a loss function, and an error value is calculated for each of the neurons in the output layer. The error values are then propagated backwards, starting from the output, until each neuron has an associated error value which roughly represents its contribution to the original output.", 
    "name": "Backpropagation", 
    "classification": "Machine Learning Algorithms", 
    "full_text": "The backward propagation of errors or backpropagation, is a common method of training artificial neural networks and used in conjunction with an optimization method such as gradient descent. The algorithm repeats a two phase cycle, propagation and weight update. When an input vector is presented to the network, it is propagated forward through the network, layer by layer, until it reaches the output layer. The output of the network is then compared to the desired output, using a loss function, and an error value is calculated for each of the neurons in the output layer. The error values are then propagated backwards, starting from the output, until each neuron has an associated error value which roughly represents its contribution to the original output.\nBackpropagation uses these error values to calculate the gradient of the loss function with respect to the weights in the network. In the second phase, this gradient is fed to the optimization method, which in turn uses it to update the weights, in an attempt to minimize the loss function.\nThe importance of this process is that, as the network is trained, the neurons in the intermediate layers organize themselves in such a way that the different neurons learn to recognize different characteristics of the total input space. After training, when an arbitrary input pattern is present which contains noise or is incomplete, neurons in the hidden layer of the network will respond with an active output if the new input contains a pattern that resembles a feature that the individual neurons have learned to recognize during their training.\nBackpropagation requires a known, desired output for each input value in order to calculate the loss function gradient \u2013 it is therefore usually considered to be a supervised learning method; nonetheless, it is also used in some unsupervised networks such as autoencoders. It is a generalization of the delta rule to multi-layered feedforward networks, made possible by using the chain rule to iteratively compute gradients for each layer. Backpropagation requires that the activation function used by the artificial neurons (or \"nodes\") be differentiable.\n\n\nThe goal of any supervised learning algorithm is to find a function that best maps a set of inputs to its correct output. An example would be a classification task, where the input is an image of an animal, and the correct output would be the name of the animal.\nThe motivation for developing the backpropagation algorithm was to find a way to train a multi-layered neural network such that it can learn the appropriate internal representations to allow it to learn any arbitrary mapping of input to output.[1] The goal of backpropagation is to compute the partial derivative, or gradient, \n\n\n\n\u2202\nE\n\n/\n\n\u2202\nw\n\n\n{\\textstyle \\partial E/\\partial w}\n\n of a loss function \n\n\n\nE\n\n\n{\\textstyle E}\n\n with respect to any weight \n\n\n\nw\n\n\n{\\displaystyle w}\n\n in the network.[2]\nSometimes referred to as the cost function or error function (not to be confused with the Gauss error function), the loss function is a function that maps values of one or more variables onto a real number intuitively representing some \"cost\" associated with the event. For backpropagation, the loss function calculates the difference between the input training example and its expected output, after the example has been propagated through the network.\nFor backpropagation to work, two assumptions are made about the form of the error function.[2] The first is that it can be written as an average \n\n\n\nE\n=\n\n\n1\nn\n\n\n\n\u2211\n\nx\n\n\n\nE\n\nx\n\n\n\n\n{\\textstyle E={\\frac {1}{n}}\\sum _{x}E_{x}}\n\n over error functions \n\n\n\n\nE\n\nx\n\n\n\n\n{\\textstyle E_{x}}\n\n, for individual training examples, \n\n\n\nx\n\n\n{\\textstyle x}\n\n. The reason for this assumption is that the backpropagation algorithm calculates the gradient of the error function for a single training example, which needs to be generalized to the overall error function. In practice, training examples are placed in batches, and the error is averaged at the end of the batch, which is then used to update the weights. The second assumption is that it can be written as a function of the outputs from the neural network.\nLet \n\n\n\ny\n,\n\ny\n\u2032\n\n\n\n{\\displaystyle y,y'}\n\n be vectors in \n\n\n\n\n\nR\n\n\nn\n\n\n\n\n{\\displaystyle \\mathbb {R} ^{n}}\n\n.\nSelect an error function \n\n\n\nE\n(\ny\n,\n\ny\n\u2032\n\n)\n\n\n{\\displaystyle E(y,y')}\n\n measuring the difference between two outputs. The standard choice is \n\n\n\nE\n(\ny\n,\n\ny\n\u2032\n\n)\n=\n\n\n\n1\n2\n\n\n\n\n|\n\ny\n\u2212\n\ny\n\u2032\n\n\n\n|\n\n\n2\n\n\n\n\n{\\displaystyle E(y,y')={\\tfrac {1}{2}}|y-y'|^{2}}\n\n, the square of the Euclidean distance between the vectors \n\n\n\ny\n\n\n{\\displaystyle y}\n\n and \n\n\n\n\ny\n\u2032\n\n\n\n{\\displaystyle y'}\n\n. The factor of \n\n\n\n\n\n\n1\n2\n\n\n\n\n\n{\\displaystyle {\\tfrac {1}{2}}}\n\n conveniently cancels the exponent when the error function is subsequently differentiated. The error function over \n\n\n\nn\n\n\n{\\textstyle n}\n\n training examples can be written as an average:\n\n\n\nE\n=\n\n\n1\n\n2\nn\n\n\n\n\n\u2211\n\nx\n\n\n\u2225\n(\ny\n(\nx\n)\n\u2212\n\ny\n\u2032\n\n(\nx\n)\n)\n\n\u2225\n\n2\n\n\n\n\n{\\displaystyle E={\\frac {1}{2n}}\\sum _{x}\\lVert (y(x)-y'(x))\\rVert ^{2}}\n\nAnd the partial derivative with respect to the outputs:\n\n\n\n\n\n\n\u2202\nE\n\n\n\u2202\n\ny\n\u2032\n\n\n\n\n=\n(\n\ny\n\u2032\n\n\u2212\ny\n)\n\n\n{\\displaystyle {\\frac {\\partial E}{\\partial y'}}=(y'-y)}\n\n\nLet \n\n\n\nN\n\n\n{\\displaystyle N}\n\n be a neural network with \n\n\n\ne\n\n\n{\\displaystyle e}\n\n connections.\nBelow, \n\n\n\nx\n,\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n,\n\u2026\n\n\n{\\displaystyle x,x_{1},x_{2},\\dots }\n\n will denote vectors in \n\n\n\n\n\nR\n\n\nm\n\n\n\n\n{\\displaystyle \\mathbb {R} ^{m}}\n\n, \n\n\n\ny\n,\n\ny\n\u2032\n\n,\n\ny\n\n1\n\n\n,\n\ny\n\n2\n\n\n,\n\u2026\n\n\n{\\displaystyle y,y',y_{1},y_{2},\\dots }\n\n vectors in \n\n\n\n\n\nR\n\n\nn\n\n\n\n\n{\\displaystyle \\mathbb {R} ^{n}}\n\n, and \n\n\n\nw\n,\n\nw\n\n0\n\n\n,\n\nw\n\n1\n\n\n,\n\u2026\n\n\n{\\displaystyle w,w_{0},w_{1},\\ldots }\n\n vectors in \n\n\n\n\n\nR\n\n\ne\n\n\n\n\n{\\displaystyle \\mathbb {R} ^{e}}\n\n. These are called inputs, outputs and weights respectively. The neural network corresponds to a function \n\n\n\ny\n=\n\nf\n\nN\n\n\n(\nw\n,\nx\n)\n\n\n{\\displaystyle y=f_{N}(w,x)}\n\n which, given a weight \n\n\n\nw\n\n\n{\\displaystyle w}\n\n, maps an input \n\n\n\nx\n\n\n{\\displaystyle x}\n\n to an output \n\n\n\ny\n\n\n{\\displaystyle y}\n\n.\nThe backpropagation algorithm takes as input a sequence of training examples \n\n\n\n(\n\nx\n\n1\n\n\n,\n\ny\n\n1\n\n\n)\n,\n\u2026\n,\n(\n\nx\n\np\n\n\n,\n\ny\n\np\n\n\n)\n\n\n{\\displaystyle (x_{1},y_{1}),\\dots ,(x_{p},y_{p})}\n\n and produces a sequence of weights \n\n\n\n\nw\n\n0\n\n\n,\n\nw\n\n1\n\n\n,\n\u2026\n,\n\nw\n\np\n\n\n\n\n{\\displaystyle w_{0},w_{1},\\dots ,w_{p}}\n\n starting from some initial weight \n\n\n\n\nw\n\n0\n\n\n\n\n{\\displaystyle w_{0}}\n\n, usually chosen at random. These weights are computed in turn: first compute \n\n\n\n\nw\n\ni\n\n\n\n\n{\\displaystyle w_{i}}\n\n using only \n\n\n\n(\n\nx\n\ni\n\n\n,\n\ny\n\ni\n\n\n,\n\nw\n\ni\n\u2212\n1\n\n\n)\n\n\n{\\displaystyle (x_{i},y_{i},w_{i-1})}\n\n for \n\n\n\ni\n=\n1\n,\n\u2026\n,\np\n\n\n{\\displaystyle i=1,\\dots ,p}\n\n. The output of the backpropagation algorithm is then \n\n\n\n\nw\n\np\n\n\n\n\n{\\displaystyle w_{p}}\n\n, giving us a new function \n\n\n\nx\n\u21a6\n\nf\n\nN\n\n\n(\n\nw\n\np\n\n\n,\nx\n)\n\n\n{\\displaystyle x\\mapsto f_{N}(w_{p},x)}\n\n. The computation is the same in each step, hence only the case \n\n\n\ni\n=\n1\n\n\n{\\displaystyle i=1}\n\n is described.\nCalculating \n\n\n\n\nw\n\n1\n\n\n\n\n{\\displaystyle w_{1}}\n\n from \n\n\n\n(\n\nx\n\n1\n\n\n,\n\ny\n\n1\n\n\n,\n\nw\n\n0\n\n\n)\n\n\n{\\displaystyle (x_{1},y_{1},w_{0})}\n\n is done by considering a variable weight \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and applying gradient descent to the function \n\n\n\nw\n\u21a6\nE\n(\n\nf\n\nN\n\n\n(\nw\n,\n\nx\n\n1\n\n\n)\n,\n\ny\n\n1\n\n\n)\n\n\n{\\displaystyle w\\mapsto E(f_{N}(w,x_{1}),y_{1})}\n\n to find a local minimum, starting at \n\n\n\nw\n=\n\nw\n\n0\n\n\n\n\n{\\displaystyle w=w_{0}}\n\n.\nThis makes \n\n\n\n\nw\n\n1\n\n\n\n\n{\\displaystyle w_{1}}\n\n the minimizing weight found by gradient descent.\nTo implement the algorithm above, explicit formulas are required for the gradient of the function \n\n\n\nw\n\u21a6\nE\n(\n\nf\n\nN\n\n\n(\nw\n,\nx\n)\n,\ny\n)\n\n\n{\\displaystyle w\\mapsto E(f_{N}(w,x),y)}\n\n where the function \n\n\n\nE\n(\ny\n,\n\ny\n\u2032\n\n)\n=\n\n|\n\ny\n\u2212\n\ny\n\u2032\n\n\n\n|\n\n\n2\n\n\n\n\n{\\displaystyle E(y,y')=|y-y'|^{2}}\n\n.\nThe backpropagation learning algorithm can be divided into two phases: propagation and weight update.\nEach propagation involves the following steps:\nFor each weight, the following steps must be followed:\nThis ratio (percentage) influences the speed and quality of learning; it is called the learning rate. The greater the ratio, the faster the neuron trains, but the lower the ratio, the more accurate the training is. The sign of the gradient of a weight indicates whether the error varies directly with, or inversely to, the weight. Therefore, the weight must be updated in the opposite direction, \"descending\" the gradient.\nPhases 1 and 2 are repeated until the performance of the network is satisfactory.\nThe following is pseudocode for a stochastic gradient descent algorithm for training a three-layer network (only one hidden layer):\nThe lines labeled \"backward pass\" can be implemented using the backpropagation algorithm, which calculates the gradient of the error of the network regarding the network's modifiable weights.[3] Often the term \"backpropagation\" is used in a more general sense, to refer to the entire procedure encompassing both the calculation of the gradient and its use in stochastic gradient descent, but backpropagation properties can be used with any gradient-based optimizer, such as L-BFGS or truncated Newton.\nBackpropagation networks are necessarily multilayer perceptrons (usually with one input, multiple hidden, and one output layer). In order for the hidden layer to serve any useful function, multilayer networks must have non-linear activation functions for the multiple layers: a multilayer network using only linear activation functions is equivalent to some single layer, linear network. Non-linear activation functions that are commonly used include the rectifier, logistic function, the softmax function, and the gaussian function.\nThe backpropagation algorithm for calculating a gradient has been rediscovered a number of times, and is a special case of a more general technique called automatic differentiation in the reverse accumulation mode.\nIt is also closely related to the Gauss\u2013Newton algorithm, and is also part of continuing research in neural backpropagation.\nBefore showing the mathematical derivation of the backpropagation algorithm, it helps to develop some intuitions about the relationship between the actual output of a neuron and the correct output for a particular training case. Consider a simple neural network with two input units, one output unit and no hidden units. Each neuron uses a linear output[note 1] that is the weighted sum of its input.\nInitially, before training, the weights will be set randomly. Then the neuron learns from training examples, which in this case consists of a set of tuples (\n\n\n\n\nx\n\n1\n\n\n\n\n{\\displaystyle x_{1}}\n\n, \n\n\n\n\nx\n\n2\n\n\n\n\n{\\displaystyle x_{2}}\n\n, \n\n\n\nt\n\n\n{\\displaystyle t}\n\n) where \n\n\n\n\nx\n\n1\n\n\n\n\n{\\displaystyle x_{1}}\n\n and \n\n\n\n\nx\n\n2\n\n\n\n\n{\\displaystyle x_{2}}\n\n are the inputs to the network and \n\n\n\nt\n\n\n{\\displaystyle t}\n\n is the correct output (the output the network should eventually produce given the identical inputs). The network given \n\n\n\n\nx\n\n1\n\n\n\n\n{\\displaystyle x_{1}}\n\n and \n\n\n\n\nx\n\n2\n\n\n\n\n{\\displaystyle x_{2}}\n\n will compute an output \n\n\n\ny\n\n\n{\\displaystyle y}\n\n which very likely differs from \n\n\n\nt\n\n\n{\\displaystyle t}\n\n (since the weights are initially random). A common method for measuring the discrepancy between the expected output \n\n\n\nt\n\n\n{\\displaystyle t}\n\n and the actual output \n\n\n\ny\n\n\n{\\displaystyle y}\n\n is using the squared error measure:\nwhere \n\n\n\nE\n\n\n{\\displaystyle E}\n\n is the discrepancy or error.\nAs an example, consider the network on a single training case: \n\n\n\n(\n1\n,\n1\n,\n0\n)\n\n\n{\\displaystyle (1,1,0)}\n\n, thus the input \n\n\n\n\nx\n\n1\n\n\n\n\n{\\displaystyle x_{1}}\n\n and \n\n\n\n\nx\n\n2\n\n\n\n\n{\\displaystyle x_{2}}\n\n are 1 and 1 respectively and the correct output, \n\n\n\nt\n\n\n{\\displaystyle t}\n\n is 0. Now if the actual output \n\n\n\ny\n\n\n{\\displaystyle y}\n\n is plotted on the x-axis against the error \n\n\n\nE\n\n\n{\\displaystyle E}\n\n on the \n\n\n\ny\n\n\n{\\displaystyle y}\n\n-axis, the result is a parabola. The minimum of the parabola corresponds to the output \n\n\n\ny\n\n\n{\\displaystyle y}\n\n which minimizes the error \n\n\n\nE\n\n\n{\\displaystyle E}\n\n. For a single training case, the minimum also touches the \n\n\n\nx\n\n\n{\\displaystyle x}\n\n-axis, which means the error will be zero and the network can produce an output \n\n\n\ny\n\n\n{\\displaystyle y}\n\n that exactly matches the expected output \n\n\n\nt\n\n\n{\\displaystyle t}\n\n. Therefore, the problem of mapping inputs to outputs can be reduced to an optimization problem of finding a function that will produce the minimal error.\nHowever, the output of a neuron depends on the weighted sum of all its inputs:\nwhere \n\n\n\n\nw\n\n1\n\n\n\n\n{\\displaystyle w_{1}}\n\n and \n\n\n\n\nw\n\n2\n\n\n\n\n{\\displaystyle w_{2}}\n\n are the weights on the connection from the input units to the output unit. Therefore, the error also depends on the incoming weights to the neuron, which is ultimately what needs to be changed in the network to enable learning. If each weight is plotted on a separate horizontal axis and the error on the vertical axis, the result is a parabolic bowl. For a neuron with \n\n\n\nk\n\n\n{\\displaystyle k}\n\n weights, the same plot would require an elliptic paraboloid of \n\n\n\nk\n+\n1\n\n\n{\\displaystyle k+1}\n\n dimensions.\nThe backpropagation algorithm aims to find the set of weights that minimizes the error. There are several methods for finding the minima of a parabola or any function in any dimension. One way is analytically by solving systems of equations, however this relies on the network being a linear system, and the goal is to be able to also train multi-layer, non-linear networks (since a multi-layered linear network is equivalent to a single-layer network). The method used in backpropagation is gradient descent.\nThe basic intuition behind gradient descent can be illustrated by a hypothetical scenario. A person is stuck in the mountains and is trying to get down (i.e. trying to find the minima). There is heavy fog such that visibility is extremely low. Therefore, the path down the mountain is not visible, so he must use local information to find the minima. He can use the method of gradient descent, which involves looking at the steepness of the hill at his current position, then proceeding in the direction with the steepest descent (i.e. downhill). If he was trying to find the top of the mountain (i.e. the maxima), then he would proceed in the direction steepest ascent (i.e. uphill). Using this method, he would eventually find his way down the mountain. However, assume also that the steepness of the hill is not immediately obvious with simple observation, but rather it requires a sophisticated instrument to measure, which the person happens to have at the moment. It takes quite some time to measure the steepness of the hill with the instrument, thus he should minimize his use of the instrument if he wanted to get down the mountain before sunset. The difficulty then is choosing the frequency at which he should measure the steepness of the hill so not to go off track.\nIn this analogy, the person represents the backpropagation algorithm, and the path taken down the mountain represents the sequence of parameter settings that the algorithm will explore. The steepness of the hill represents the slope of the error surface at that point. The instrument used to measure steepness is differentiation (the slope of the error surface can be calculated by taking the derivative of the squared error function at that point). The direction he chooses to travel in aligns with the gradient of the error surface at that point. The amount of time he travels before taking another measurement is the learning rate of the algorithm. See the limitation section for a discussion of the limitations of this type of \"hill climbing\" algorithm.\nSince backpropagation uses the gradient descent method, one needs to calculate the derivative of the squared error function with respect to the weights of the network. Assuming one output neuron,[note 2] the squared error function is:\nwhere\nThe factor of \n\n\n\n\n\n\n1\n2\n\n\n\n\n\n{\\displaystyle \\textstyle {\\frac {1}{2}}}\n\n is included to cancel the exponent when differentiating. Later, the expression will be multiplied with an arbitrary learning rate, so that it doesn't matter if a constant coefficient is introduced now.\nFor each neuron \n\n\n\nj\n\n\n{\\displaystyle j}\n\n, its output \n\n\n\n\no\n\nj\n\n\n\n\n{\\displaystyle o_{j}}\n\n is defined as\nThe input \n\n\n\n\n\nnet\n\n\nj\n\n\n\n\n{\\displaystyle {\\mbox{net}}_{j}}\n\n to a neuron is the weighted sum of outputs \n\n\n\n\no\n\nk\n\n\n\n\n{\\displaystyle o_{k}}\n\n of previous neurons. If the neuron is in the first layer after the input layer, the \n\n\n\n\no\n\nk\n\n\n\n\n{\\displaystyle o_{k}}\n\n of the input layer are simply the inputs \n\n\n\n\nx\n\nk\n\n\n\n\n{\\displaystyle x_{k}}\n\n to the network. The number of input units to the neuron is \n\n\n\nn\n\n\n{\\displaystyle n}\n\n. The variable \n\n\n\n\nw\n\ni\nj\n\n\n\n\n{\\displaystyle w_{ij}}\n\n denotes the weight between neurons \n\n\n\ni\n\n\n{\\displaystyle i}\n\n and \n\n\n\nj\n\n\n{\\displaystyle j}\n\n.\nThe activation function \n\n\n\n\u03c6\n\n\n{\\displaystyle \\varphi }\n\n is in general non-linear and differentiable. A commonly used activation function is the logistic function:\nwhich has a nice derivative of:\nCalculating the partial derivative of the error with respect to a weight \n\n\n\n\nw\n\ni\nj\n\n\n\n\n{\\displaystyle w_{ij}}\n\n is done using the chain rule twice:\nIn the last factor of the right-hand side of the above, only one term in the sum \n\n\n\n\nn\ne\n\nt\n\nj\n\n\n\n\n\n{\\displaystyle \\mathrm {net_{j}} }\n\n depends on \n\n\n\n\nw\n\ni\nj\n\n\n\n\n{\\displaystyle w_{ij}}\n\n, so that\nIf the neuron is in the first layer after the input layer, \n\n\n\n\no\n\ni\n\n\n\n\n{\\displaystyle o_{i}}\n\n is just \n\n\n\n\nx\n\ni\n\n\n\n\n{\\displaystyle x_{i}}\n\n.\nThe derivative of the output of neuron \n\n\n\nj\n\n\n{\\displaystyle j}\n\n with respect to its input is simply the partial derivative of the activation function (assuming here that the logistic function is used):\nThis is the reason why backpropagation requires the activation function to be differentiable.\nThe first factor is straightforward to evaluate if the neuron is in the output layer, because then \n\n\n\n\no\n\nj\n\n\n=\ny\n\n\n{\\displaystyle o_{j}=y}\n\n and\nHowever, if \n\n\n\nj\n\n\n{\\displaystyle j}\n\n is in an arbitrary inner layer of the network, finding the derivative \n\n\n\nE\n\n\n{\\displaystyle E}\n\n with respect to \n\n\n\n\no\n\nj\n\n\n\n\n{\\displaystyle o_{j}}\n\n is less obvious.\nConsidering \n\n\n\nE\n\n\n{\\displaystyle E}\n\n as a function of the inputs of all neurons \n\n\n\nL\n=\n\nu\n,\nv\n,\n\u2026\n,\nw\n\n\n\n{\\displaystyle L={u,v,\\dots ,w}}\n\n receiving input from neuron \n\n\n\nj\n\n\n{\\displaystyle j}\n\n,\nand taking the total derivative with respect to \n\n\n\n\no\n\nj\n\n\n\n\n{\\displaystyle o_{j}}\n\n, a recursive expression for the derivative is obtained:\nTherefore, the derivative with respect to \n\n\n\n\no\n\nj\n\n\n\n\n{\\displaystyle o_{j}}\n\n can be calculated if all the derivatives with respect to the outputs \n\n\n\n\no\n\nl\n\n\n\n\n{\\displaystyle o_{l}}\n\n of the next layer \u2013 the one closer to the output neuron \u2013 are known.\nPutting it all together:\nwith\nTo update the weight \n\n\n\n\nw\n\ni\nj\n\n\n\n\n{\\displaystyle w_{ij}}\n\n using gradient descent, one must choose a learning rate, \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n. The change in weight, which is added to the old weight, is equal to the product of the learning rate and the gradient, multiplied by \n\n\n\n\u2212\n1\n\n\n{\\displaystyle -1}\n\n:\nThe \n\n\n\n\n\u2212\n1\n\n\n\n{\\displaystyle \\textstyle -1}\n\n is required in order to update in the direction of a minimum, not a maximum, of the error function.\nFor a single-layer network, this expression becomes the Delta Rule. To better understand how backpropagation works, here is an example to illustrate it: The Back Propagation Algorithm, page 20.\nThe choice of learning rate \n\n\n\n\u03b7\n\n\n{\\textstyle \\eta }\n\n is important for the method, since a high value can cause too strong a change, causing the minimum to be missed, while a too low learning rate slows the training unnecessarily.\nVarious optimizations of backpropagation, such as Quickprop, are primarily aimed at speeding up the error minimization; other improvements mainly try to increase reliability.\nIn order to avoid oscillation inside the network, such as alternating connection weights, and to improve the rate of convergence, there are refinements of this algorithm that use an adaptive learning rate.[4]\nBy using a variable inertia term (Momentum) \n\n\n\n\u03b1\n\n\n{\\textstyle \\alpha }\n\n the gradient and the last change can be weighted such that the weight adjustment additionally depends on the previous change. If the Momentum \n\n\n\n\u03b1\n\n\n{\\textstyle \\alpha }\n\n is equal to 0, the change depends solely on the gradient, and a value of 1 will only depend on the last change.\nSimilar to a ball rolling down a mountain, whose current speed is determined not only by the current slope of the mountain but also by its own inertia, inertia can be added to backpropagation:\n\n\n\n\u0394\n\nw\n\ni\nj\n\n\n(\nt\n+\n1\n)\n=\n(\n1\n\u2212\n\u03b1\n)\n\u03b7\n\n\u03b4\n\nj\n\n\n\nx\n\ni\n\n\n+\n\u03b1\n\u0394\n\nw\n\ni\nj\n\n\n(\nt\n)\n\n\n{\\displaystyle \\Delta w_{ij}(t+1)=(1-\\alpha )\\eta \\delta _{j}x_{i}+\\alpha \\Delta w_{ij}(t)}\n\nwhere:\nThis will depend on the current weight change \n\n\n\n(\nt\n+\n1\n)\n\n\n{\\textstyle (t+1)}\n\n both from the current gradient of the error function (slope of the mountain, 1st summand), as well as from the weight change from the previous point in time (inertia, 2nd summand).\nWith inertia, the previous problems of the backpropagation getting stuck in steep ravines and flat plateaus are avoided. Since, for example, the gradient of the error function becomes very small in flat plateaus, it would immediately lead to a \"deceleration\" of the gradient descent. This \"deceleration\" is delayed by the addition of the inertia term so that a flat plateau can be overcome more quickly.\nThere are two modes of learning to choose from: stochastic and batch. In stochastic learning, each propagation is followed immediately by a weight update. In batch learning many propagations occur before updating the weights, accumulating errors over the samples within a batch. Stochastic learning introduces \"noise\" into the gradient descent process, using the local gradient calculated from one data point; this reduces the chance of the network getting stuck in a local minima. Yet batch learning typically yields a faster, more stable descent to a local minima, since each update is performed in the direction of the average error of the batch samples. In modern applications a common compromise choice is to use \"mini-batches\", meaning batch learning but with a batch of small size and with stochastically selected samples.\nOnline learning is used for dynamic environments that provide a continuous stream of new training data patterns. Offline learning makes use of a training set of static patterns.\nAccording to various sources,[7][8][9][10] basics of continuous backpropagation were derived in the context of control theory by Henry J. Kelley[11] in 1960 and by Arthur E. Bryson in 1961,[12] using principles of dynamic programming. In 1962, Stuart Dreyfus published a simpler derivation based only on the chain rule.[13] Vapnik cites reference[14] in his book on Support Vector Machines. Arthur E. Bryson and Yu-Chi Ho described it as a multi-stage dynamic system optimization method in 1969.[15][16]\nIn 1970, Seppo Linnainmaa finally published the general method for automatic differentiation (AD) of discrete connected networks of nested differentiable functions.[17][18] This corresponds to the modern version of backpropagation which is efficient even when the networks are sparse.[9][10][19][20]\nIn 1973, Stuart Dreyfus used backpropagation to adapt parameters of controllers in proportion to error gradients.[21] In 1974, Paul Werbos mentioned the possibility of applying this principle to artificial neural networks,[22] and in 1982, he applied Linnainmaa's AD method to neural networks in the way that is widely used today.[10][23]\nIn 1986, David E. Rumelhart, Geoffrey E. Hinton and Ronald J. Williams showed through computer experiments that this method can generate useful internal representations of incoming data in hidden layers of neural networks.[1] [24] In 1993, Eric A. Wan was the first[9] to win an international pattern recognition contest through backpropagation.[25]\nDuring the 2000s it fell out of favour but has returned again in the 2010s, now able to train much larger networks using huge modern computing power such as GPUs. In the context of this new hardware it is sometimes referred to as deep learning, though this is often seen[by whom?] as marketing hype. For example, in 2014, backpropagation was used to train a deep neural network for state of the art speech recognition.[26]", 
    "dbpedia_url": "http://dbpedia.org/resource/Backpropagation", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Backpropagation\n"
}
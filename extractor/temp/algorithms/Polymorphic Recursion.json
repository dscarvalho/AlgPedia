{
    "about": "In computer science, polymorphic recursion (also referred to as Milner\u2013Mycroft typability or the Milner\u2013Mycroft calculus) refers to a recursive parametrically polymorphic function where the type parameter changes with each recursive invocation made instead of staying constant. Type inference for polymorphic recursion is equivalent to semi-unification and therefore undecidable and requires the use of a semi-algorithm or programmer supplied type annotations.[1]", 
    "name": "Polymorphic Recursion", 
    "classification": "Recursion", 
    "full_text": "In computer science, polymorphic recursion (also referred to as Milner\u2013Mycroft typability or the Milner\u2013Mycroft calculus) refers to a recursive parametrically polymorphic function where the type parameter changes with each recursive invocation made instead of staying constant. Type inference for polymorphic recursion is equivalent to semi-unification and therefore undecidable and requires the use of a semi-algorithm or programmer supplied type annotations.[1]\n\n\nConsider the following nested datatype:\nA length function defined over this datatype will be polymorphically recursive, as the type of the argument changes from Nested a to Nested [a] in the recursive call:\nNote that Haskell normally infers the type signature for a function as simple-looking as this, but here it cannot be omitted without triggering a type error.\nIn type-based program analysis polymorphic recursion is often essential in gaining high precision of the analysis. Notable examples of systems employing polymorphic recursion include Dussart, Henglein and Mossin's binding-time analysis[2] and the Tofte\u2013Talpin region-based memory management system.[3] As these systems assume the expressions have already been typed in an underlying type system (not necessary employing polymorphic recursion), inference can be made decidable again.\nFunctional programming data structures often use polymorphic recursion to simplify type error checks and solve problems with nasty \"middle\" temporary solutions that devour memory in more traditional data structures such as trees. In the two citations that follow, Okasaki (pp. 144-146) gives a CONS example in Haskell wherein the polymorphic type system automatically flags programmer errors.[4] The recursive aspect is that the type definition assures that the outermost constructor has a single element, the second a pair, the third a pair of pairs, etc. recursively, setting an automatic error finding pattern in the data type. Roberts (p. 171) gives a related example in Java, using a Class to represent a stack frame. The example given is a solution to the Tower of Hanoi problem wherein a stack simulates polymorphic recursion with a beginning, temporary and ending nested stack substitution structure.[5]", 
    "dbpedia_url": "http://dbpedia.org/resource/Polymorphic_recursion", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Polymorphic_recursion\n"
}
{
    "about": "The Goertzel algorithm is a technique in digital signal processing (DSP) that provides a means for efficient evaluation of individual terms of the discrete Fourier transform (DFT), thus making it useful in certain practical applications, such as recognition of DTMF tones produced by the buttons pushed on a telephone keypad. The algorithm was first described by Gerald Goertzel in 1958.[1]", 
    "name": "Goertzel Algorithm", 
    "classification": "Digital Signal Processing", 
    "full_text": "The Goertzel algorithm is a technique in digital signal processing (DSP) that provides a means for efficient evaluation of individual terms of the discrete Fourier transform (DFT), thus making it useful in certain practical applications, such as recognition of DTMF tones produced by the buttons pushed on a telephone keypad. The algorithm was first described by Gerald Goertzel in 1958.[1]\nLike the DFT, the Goertzel algorithm analyses one selectable frequency component from a discrete signal.[2][3][4] Unlike direct DFT calculations, the Goertzel algorithm applies a single real-valued coefficient at each iteration, using real-valued arithmetic for real-valued input sequences. For covering a full spectrum, the Goertzel algorithm has a higher order of complexity than fast Fourier transform (FFT) algorithms, but for computing a small number of selected frequency components, it is more numerically efficient. The simple structure of the Goertzel algorithm makes it well suited to small processors and embedded applications, though not limited to these.\nThe Goertzel algorithm can also be used \"in reverse\" as a sinusoid synthesis function, which requires only 1 multiplication and 1 subtraction per generated sample.[5]\n\n\nThe main calculation in the Goertzel algorithm has the form of a digital filter, and for this reason the algorithm is often called a Goertzel filter. The filter operates on an input sequence \n\n\n\nx\n[\nn\n]\n\n\n{\\displaystyle x[n]}\n\n in a cascade of two stages with a parameter \n\n\n\n\n\u03c9\n\n0\n\n\n\n\n{\\displaystyle \\omega _{0}}\n\n, giving the frequency to be analysed, normalised to radians per sample.\nThe first stage calculates an intermediate sequence, \n\n\n\ns\n[\nn\n]\n\n\n{\\displaystyle s[n]}\n\n:\n\n\n\n\ns\n[\nn\n]\n=\nx\n[\nn\n]\n+\n2\ncos\n\u2061\n(\n\n\u03c9\n\n0\n\n\n)\ns\n[\nn\n\u2212\n1\n]\n\u2212\ns\n[\nn\n\u2212\n2\n]\n.\n\n\n{\\displaystyle s[n]=x[n]+2\\cos(\\omega _{0})s[n-1]-s[n-2].}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(1)\nThe second stage applies the following filter to \n\n\n\ns\n[\nn\n]\n\n\n{\\displaystyle s[n]}\n\n, producing output sequence \n\n\n\ny\n[\nn\n]\n\n\n{\\displaystyle y[n]}\n\n:\n\n\n\n\ny\n[\nn\n]\n=\ns\n[\nn\n]\n\u2212\n\ne\n\n\u2212\nj\n\n\u03c9\n\n0\n\n\n\n\ns\n[\nn\n\u2212\n1\n]\n.\n\n\n{\\displaystyle y[n]=s[n]-e^{-j\\omega _{0}}s[n-1].}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(2)\nThe first filter stage can be observed to be a second-order IIR filter with a direct-form structure. This particular structure has the property that its internal state variables equal the past output values from that stage. Input values \n\n\n\nx\n[\nn\n]\n\n\n{\\displaystyle x[n]}\n\n for \n\n\n\nn\n<\n0\n\n\n{\\displaystyle n<0}\n\n are presumed all equal to 0. To establish the initial filter state so that evaluation can begin at sample \n\n\n\nx\n[\n0\n]\n\n\n{\\displaystyle x[0]}\n\n, the filter states are assigned initial values \n\n\n\ns\n[\n\u2212\n2\n]\n=\ns\n[\n\u2212\n1\n]\n=\n0\n\n\n{\\displaystyle s[-2]=s[-1]=0}\n\n. To avoid aliasing hazards, frequency \n\n\n\n\n\u03c9\n\n0\n\n\n\n\n{\\displaystyle \\omega _{0}}\n\n is often restricted to the range 0 to \u03c0 (see Nyquist\u2013Shannon sampling theorem); using a value outside this range is not meaningless, but is equivalent to using an aliased frequency inside this range, since the exponential function is periodic with a period of 2\u03c0 in \n\n\n\n\n\u03c9\n\n0\n\n\n\n\n{\\displaystyle \\omega _{0}}\n\n.\nThe second-stage filter can be observed to be a FIR filter, since its calculations do not use any of its past outputs.\nZ-transform methods can be applied to study the properties of the filter cascade. The Z transform of the first filter stage given in equation (1) is\n\n\n\n\n\n\n\n\n\n\n\nS\n(\nz\n)\n\n\nX\n(\nz\n)\n\n\n\n\n\n\n=\n\n\n1\n\n1\n\u2212\n2\ncos\n\u2061\n(\n\n\u03c9\n\n0\n\n\n)\n\nz\n\n\u2212\n1\n\n\n+\n\nz\n\n\u2212\n2\n\n\n\n\n\n\n\n\n\n\n\n=\n\n\n1\n\n(\n1\n\u2212\n\ne\n\n+\nj\n\n\u03c9\n\n0\n\n\n\n\n\nz\n\n\u2212\n1\n\n\n)\n(\n1\n\u2212\n\ne\n\n\u2212\nj\n\n\u03c9\n\n0\n\n\n\n\n\nz\n\n\u2212\n1\n\n\n)\n\n\n\n.\n\n\n\n\n\n\n{\\displaystyle {\\begin{aligned}{\\frac {S(z)}{X(z)}}&={\\frac {1}{1-2\\cos(\\omega _{0})z^{-1}+z^{-2}}}\\\\&={\\frac {1}{(1-e^{+j\\omega _{0}}z^{-1})(1-e^{-j\\omega _{0}}z^{-1})}}.\\end{aligned}}}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(3)\nThe Z transform of the second filter stage given in equation (2) is\n\n\n\n\n\n\n\nY\n(\nz\n)\n\n\nS\n(\nz\n)\n\n\n\n=\n1\n\u2212\n\ne\n\n\u2212\nj\n\n\u03c9\n\n0\n\n\n\n\n\nz\n\n\u2212\n1\n\n\n.\n\n\n{\\displaystyle {\\frac {Y(z)}{S(z)}}=1-e^{-j\\omega _{0}}z^{-1}.}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(4)\nThe combined transfer function of the cascade of the two filter stages is then\n\n\n\n\n\n\n\n\n\n\n\nS\n(\nz\n)\n\n\nX\n(\nz\n)\n\n\n\n\n\n\nY\n(\nz\n)\n\n\nS\n(\nz\n)\n\n\n\n=\n\n\n\nY\n(\nz\n)\n\n\nX\n(\nz\n)\n\n\n\n\n\n\n=\n\n\n\n(\n1\n\u2212\n\ne\n\n\u2212\nj\n\n\u03c9\n\n0\n\n\n\n\n\nz\n\n\u2212\n1\n\n\n)\n\n\n(\n1\n\u2212\n\ne\n\n+\nj\n\n\u03c9\n\n0\n\n\n\n\n\nz\n\n\u2212\n1\n\n\n)\n(\n1\n\u2212\n\ne\n\n\u2212\nj\n\n\u03c9\n\n0\n\n\n\n\n\nz\n\n\u2212\n1\n\n\n)\n\n\n\n\n\n\n\n\n\n=\n\n\n1\n\n1\n\u2212\n\ne\n\n+\nj\n\n\u03c9\n\n0\n\n\n\n\n\nz\n\n\u2212\n1\n\n\n\n\n\n.\n\n\n\n\n\n\n{\\displaystyle {\\begin{aligned}{\\frac {S(z)}{X(z)}}{\\frac {Y(z)}{S(z)}}={\\frac {Y(z)}{X(z)}}&={\\frac {(1-e^{-j\\omega _{0}}z^{-1})}{(1-e^{+j\\omega _{0}}z^{-1})(1-e^{-j\\omega _{0}}z^{-1})}}\\\\&={\\frac {1}{1-e^{+j\\omega _{0}}z^{-1}}}.\\end{aligned}}}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(5)\nThis can be transformed back to an equivalent time-domain sequence, and the terms unrolled back to the first input term at index \n\n\n\nn\n=\n0\n\n\n{\\displaystyle n=0}\n\n:[citation needed]\n\n\n\n\n\n\n\n\ny\n[\nn\n]\n\n\n\n=\nx\n[\nn\n]\n+\n\ne\n\n+\nj\n\n\u03c9\n\n0\n\n\n\n\ny\n[\nn\n\u2212\n1\n]\n\n\n\n\n\n\n=\n\n\u2211\n\nk\n=\n\u2212\n\u221e\n\n\nn\n\n\nx\n[\nk\n]\n\ne\n\n+\nj\n\n\u03c9\n\n0\n\n\n(\nn\n\u2212\nk\n)\n\n\n\n\n\n\n\n\n=\n\ne\n\nj\n\n\u03c9\n\n0\n\n\nn\n\n\n\n\u2211\n\nk\n=\n0\n\n\nn\n\n\nx\n[\nk\n]\n\ne\n\n\u2212\nj\n\n\u03c9\n\n0\n\n\nk\n\n\n\n\nsince\u00a0\n\n\u2200\nk\n<\n0\n,\nx\n[\nk\n]\n=\n0.\n\n\n\n\n\n\n{\\displaystyle {\\begin{aligned}y[n]&=x[n]+e^{+j\\omega _{0}}y[n-1]\\\\&=\\sum _{k=-\\infty }^{n}x[k]e^{+j\\omega _{0}(n-k)}\\\\&=e^{j\\omega _{0}n}\\sum _{k=0}^{n}x[k]e^{-j\\omega _{0}k}\\qquad {\\text{since }}\\forall k<0,x[k]=0.\\end{aligned}}}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(6)\nIt can be observed that the poles of the filter's Z transform are located at \n\n\n\n\ne\n\n+\nj\n\n\u03c9\n\n0\n\n\n\n\n\n\n{\\displaystyle e^{+j\\omega _{0}}}\n\n and \n\n\n\n\ne\n\n\u2212\nj\n\n\u03c9\n\n0\n\n\n\n\n\n\n{\\displaystyle e^{-j\\omega _{0}}}\n\n, on a circle of unit radius centered on the origin of the complex Z-transform plane. This property indicates that the filter process is marginally stable and vulnerable to numerical-error accumulation when computed using low-precision arithmetic and long input sequences.[6] A numerically stable version was proposed by Christian Reinsch.[7]\nFor the important case of computing a DFT term, the following special restrictions are applied.\n\n\n\n\n\n\u03c9\n\n0\n\n\n=\n2\n\u03c0\n\n\nk\nN\n\n\n.\n\n\n{\\displaystyle \\omega _{0}=2\\pi {\\frac {k}{N}}.}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(7)\n\n\n\n\nk\n\u2208\n{\n0\n,\n1\n,\n2\n,\n.\n.\n.\n,\nN\n\u2212\n1\n}\n.\n\n\n{\\displaystyle k\\in \\{0,1,2,...,N-1\\}.}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(8)\nMaking these substitutions into equation (6) and observing that the term \n\n\n\n\ne\n\n+\nj\n2\n\u03c0\nk\n\n\n=\n1\n\n\n{\\displaystyle e^{+j2\\pi k}=1}\n\n, equation (6) then takes the following form:\n\n\n\n\ny\n[\nN\n]\n=\n\n\u2211\n\nn\n=\n0\n\n\nN\n\n\nx\n[\nn\n]\n\ne\n\n\u2212\nj\n2\n\u03c0\n\n\n\nn\nk\n\nN\n\n\n\n\n.\n\n\n{\\displaystyle y[N]=\\sum _{n=0}^{N}x[n]e^{-j2\\pi {\\frac {nk}{N}}}.}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(9)\nWe can observe that the right side of equation (9) is extremely similar to the defining formula for DFT term \n\n\n\nX\n[\nk\n]\n\n\n{\\displaystyle X[k]}\n\n, the DFT term for index number \n\n\n\nk\n\n\n{\\displaystyle k}\n\n, but not exactly the same. The summation shown in equation (9) requires \n\n\n\nN\n+\n1\n\n\n{\\displaystyle N+1}\n\n input terms, but only \n\n\n\nN\n\n\n{\\displaystyle N}\n\n input terms are available when evaluating a DFT. A simple but inelegant expedient is to extend the input sequence \n\n\n\nx\n[\nn\n]\n\n\n{\\displaystyle x[n]}\n\n with one more artificial value \n\n\n\nx\n[\nN\n]\n=\n0\n\n\n{\\displaystyle x[N]=0}\n\n.[8] We can see from equation (9) that the mathematical effect on the final result is the same as removing term \n\n\n\nx\n[\nN\n]\n\n\n{\\displaystyle x[N]}\n\n from the summation, thus delivering the intended DFT value.\nHowever, there is a more elegant approach that avoids the extra filter pass. From equation (1), we can note that when the extended input term \n\n\n\nx\n[\nN\n]\n=\n0\n\n\n{\\displaystyle x[N]=0}\n\n is used in the final step,\n\n\n\n\ns\n[\nN\n]\n=\n2\ncos\n\u2061\n(\n\n\u03c9\n\n0\n\n\n)\ns\n[\nN\n\u2212\n1\n]\n\u2212\ns\n[\nN\n\u2212\n2\n]\n.\n\n\n{\\displaystyle s[N]=2\\cos(\\omega _{0})s[N-1]-s[N-2].}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(10)\nThus, the algorithm can be completed as follows:\nThe last two mathematical operations are simplified by combining them algebraically:\n\n\n\n\n\n\n\n\ny\n[\nN\n]\n\n\n\n=\ns\n[\nN\n]\n\u2212\n\ne\n\n\u2212\nj\n2\n\u03c0\n\n\nk\nN\n\n\n\n\ns\n[\nN\n\u2212\n1\n]\n\n\n\n\n\n\n=\n(\n2\ncos\n\u2061\n(\n\n\u03c9\n\n0\n\n\n)\ns\n[\nN\n\u2212\n1\n]\n\u2212\ns\n[\nN\n\u2212\n2\n]\n)\n\u2212\n\ne\n\n\u2212\nj\n2\n\u03c0\n\n\nk\nN\n\n\n\n\ns\n[\nN\n\u2212\n1\n]\n\n\n\n\n\n\n=\n\ne\n\nj\n2\n\u03c0\n\n\nk\nN\n\n\n\n\ns\n[\nN\n\u2212\n1\n]\n\u2212\ns\n[\nN\n\u2212\n2\n]\n.\n\n\n\n\n\n\n{\\displaystyle {\\begin{aligned}y[N]&=s[N]-e^{-j2\\pi {\\frac {k}{N}}}s[N-1]\\\\&=(2\\cos(\\omega _{0})s[N-1]-s[N-2])-e^{-j2\\pi {\\frac {k}{N}}}s[N-1]\\\\&=e^{j2\\pi {\\frac {k}{N}}}s[N-1]-s[N-2].\\end{aligned}}}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(11)\nNote that stopping the filter updates at term \n\n\n\nN\n\u2212\n1\n\n\n{\\displaystyle N-1}\n\n and immediately applying equation (2) rather than equation (11) misses the final filter state updates, yielding a result with incorrect phase.[9]\nThe particular filtering structure chosen for the Goertzel algorithm is the key to its efficient DFT calculations. We can observe that only one output value \n\n\n\ny\n[\nN\n]\n\n\n{\\displaystyle y[N]}\n\n is used for calculating the DFT, so calculations for all the other output terms are omitted. Since the FIR filter is not calculated, the IIR stage calculations \n\n\n\ns\n[\n0\n]\n,\ns\n[\n1\n]\n\n\n{\\displaystyle s[0],s[1]}\n\n, etc. can be discarded immediately after updating the first stage's internal state.\nThis seems to leave a paradox: to complete the algorithm, the FIR filter stage must be evaluated once using the final two outputs from the IIR filter stage, while for computational efficiency the IIR filter iteration discards its output values. This is where the properties of the direct-form filter structure are applied. The two internal state variables of the IIR filter provide the last two values of the IIR filter output, which are the terms required to evaluate the FIR filter stage.\nExamining equation (6), a final IIR filter pass to calculate term \n\n\n\ny\n[\nN\n]\n\n\n{\\displaystyle y[N]}\n\n using a supplemental input value \n\n\n\nx\n[\nN\n]\n=\n0\n\n\n{\\displaystyle x[N]=0}\n\n applies a complex multiplier of magnitude 1 to the previous term \n\n\n\ny\n[\nN\n\u2212\n1\n]\n\n\n{\\displaystyle y[N-1]}\n\n. Consequently, \n\n\n\ny\n[\nN\n]\n\n\n{\\displaystyle y[N]}\n\n and \n\n\n\ny\n[\nN\n\u2212\n1\n]\n\n\n{\\displaystyle y[N-1]}\n\n represent equivalent signal power. It is equally valid to apply equation (11) and calculate the signal power from term \n\n\n\ny\n[\nN\n]\n\n\n{\\displaystyle y[N]}\n\n or to apply equation (2) and calculate the signal power from term \n\n\n\ny\n[\nN\n\u2212\n1\n]\n\n\n{\\displaystyle y[N-1]}\n\n. Both cases lead to the following expression for the signal power represented by DFT term \n\n\n\nX\n[\nk\n]\n\n\n{\\displaystyle X[k]}\n\n:\n\n\n\n\n\n\n\n\nX\n[\nk\n]\n\n\nX\n\u2032\n\n[\nk\n]\n\n\n\n=\ny\n[\nN\n]\n\n\ny\n\u2032\n\n[\nN\n]\n=\ny\n[\nN\n\u2212\n1\n]\n\n\ny\n\u2032\n\n[\nN\n\u2212\n1\n]\n\n\n\n\n\n\n=\n\ns\n\n2\n\n\n[\nN\n\u2212\n1\n]\n+\n\ns\n\n2\n\n\n[\nN\n\u2212\n2\n]\n\u2212\n2\ncos\n\u2061\n\n(\n2\n\u03c0\n\n\nk\nN\n\n\n)\n\n\ns\n[\nN\n\u2212\n1\n]\n\ns\n[\nN\n\u2212\n2\n]\n.\n\n\n\n\n\n\n{\\displaystyle {\\begin{aligned}X[k]\\,X'[k]&=y[N]\\,y'[N]=y[N-1]\\,y'[N-1]\\\\&=s^{2}[N-1]+s^{2}[N-2]-2\\cos \\left(2\\pi {\\frac {k}{N}}\\right)\\,s[N-1]\\,s[N-2].\\end{aligned}}}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(12)\nIn the pseudocode below, the variables sprev and sprev2 temporarily store output history from the IIR filter, while x[n] is an indexed element of the array x, which stores the input.\nIt is possible[10] to organise the computations so that incoming samples are delivered singly to a software object that maintains the filter state between updates, with the final power result accessed after the other processing is done.\nThe case of real-valued input data arises frequently, especially in embedded systems where the input streams result from direct measurements of physical processes. Comparing to the illustration in the previous section, when the input data are real-valued, the filter internal state variables sprev and sprev2 can be observed also to be real-valued, consequently, no complex arithmetic is required in the first IIR stage. Optimizing for real-valued arithmetic typically is as simple as applying appropriate real-valued data types for the variables.\nAfter the calculations using input term \n\n\n\nx\n[\nN\n\u2212\n1\n]\n\n\n{\\displaystyle x[N-1]}\n\n, and filter iterations are terminated, equation (11) must be applied to evaluate the DFT term. The final calculation uses complex-valued arithmetic, but this can be converted into real-valued arithmetic by separating real and imaginary terms:\n\n\n\n\n\n\n\n\n\nc\n\nr\n\n\n\n\n\n=\ncos\n\u2061\n(\n2\n\u03c0\n\n\n\nk\nN\n\n\n\n)\n,\n\n\n\n\n\nc\n\ni\n\n\n\n\n\n=\nsin\n\u2061\n(\n2\n\u03c0\n\n\n\nk\nN\n\n\n\n)\n,\n\n\n\n\ny\n[\nN\n]\n\n\n\n=\n\nc\n\nr\n\n\ns\n[\nN\n\u2212\n1\n]\n\u2212\ns\n[\nN\n\u2212\n2\n]\n+\nj\n\nc\n\ni\n\n\ns\n[\nN\n\u2212\n1\n]\n.\n\n\n\n\n\n\n{\\displaystyle {\\begin{aligned}c_{r}&=\\cos(2\\pi {\\tfrac {k}{N}}),\\\\c_{i}&=\\sin(2\\pi {\\tfrac {k}{N}}),\\\\y[N]&=c_{r}s[N-1]-s[N-2]+jc_{i}s[N-1].\\end{aligned}}}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(13)\nComparing to the power-spectrum application, the only difference are the calculation used to finish:\nThis application requires the same evaluation of DFT term \n\n\n\nX\n[\nk\n]\n\n\n{\\displaystyle X[k]}\n\n, as discussed in the previous section, using a real-valued or complex-valued input stream. Then the signal phase can be evaluated as\n\n\n\n\n\u03d5\n=\n\ntan\n\n\u2212\n1\n\n\n\u2061\n\n\n\n\u2111\n(\nX\n[\nk\n]\n)\n\n\n\u211c\n(\nX\n[\nk\n]\n)\n\n\n\n,\n\n\n{\\displaystyle \\phi =\\tan ^{-1}{\\frac {\\Im (X[k])}{\\Re (X[k])}},}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(14)\ntaking appropriate precautions for singularities, quadrant, and so forth when computing the inverse tangent function.\nSince complex signals decompose linearly into real and imaginary parts, the Goertzel algorithm can be computed in real arithmetic separately over the sequence of real parts, yielding \n\n\n\n\ny\n\nr\n\n\n[\nn\n]\n\n\n{\\displaystyle y_{\\text{r}}[n]}\n\n, and over the sequence of imaginary parts, yielding \n\n\n\n\ny\n\ni\n\n\n[\nn\n]\n\n\n{\\displaystyle y_{\\text{i}}[n]}\n\n. After that, the two complex-valued partial results can be recombined:\n\n\n\n\ny\n[\nn\n]\n=\n\ny\n\nr\n\n\n[\nn\n]\n+\nj\n\ny\n\ni\n\n\n[\nn\n]\n.\n\n\n{\\displaystyle y[n]=y_{\\text{r}}[n]+jy_{\\text{i}}[n].}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(15)\nIn the complexity order expressions, when the number of calculated terms \n\n\n\nM\n\n\n{\\displaystyle M}\n\n is smaller than \n\n\n\nlog\n\u2061\nN\n\n\n{\\displaystyle \\log N}\n\n, the advantage of the Goertzel algorithm is clear. But because FFT code is comparatively complex, the \"cost per unit of work\" factor \n\n\n\nK\n\n\n{\\displaystyle K}\n\n is often larger for an FFT, and the practical advantage favours the Goertzel algorithm even for \n\n\n\nM\n\n\n{\\displaystyle M}\n\n several times larger than \n\n\n\n\nlog\n\n2\n\n\n\u2061\n(\nN\n)\n\n\n{\\displaystyle \\log _{2}(N)}\n\n.\nAs a rule-of-thumb for determining whether a radix-2 FFT or a Goertzel algorithm is more efficient, adjust the number of terms \n\n\n\nN\n\n\n{\\displaystyle N}\n\n in the data set upward to the nearest exact power of 2, calling this \n\n\n\n\nN\n\n2\n\n\n\n\n{\\displaystyle N_{2}}\n\n, and the Goertzel algorithm is likely to be faster if\nFFT implementations and processing platforms have a significant impact on the relative performance. Some FFT implementations[11] perform internal complex-number calculations to generate coefficients on-the-fly, significantly increasing their \"cost K per unit of work.\" FFT and DFT algorithms can use tables of pre-computed coefficient values for better numerical efficiency, but this requires more accesses to coefficient values buffered in external memory, which can lead to increased cache contention that counters some of the numerical advantage.\nBoth algorithms gain approximately a factor of 2 efficiency when using real-valued rather than complex-valued input data. However, these gains are natural for the Goertzel algorithm but will not be achieved for the FFT without using certain algorithm variants[which?] specialised for transforming real-valued data.", 
    "dbpedia_url": "http://dbpedia.org/resource/Goertzel_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Goertzel_algorithm\n"
}
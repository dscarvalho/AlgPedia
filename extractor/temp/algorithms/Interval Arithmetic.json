{
    "about": "Interval arithmetic, interval mathematics, interval analysis, or interval computation, is a method developed by mathematicians since the 1950s and 1960s, as an approach to putting bounds on rounding errors and measurement errors in mathematical computation and thus developing numerical methods that yield reliable results. Very simply put, it represents each value as a range of possibilities. For example, instead of estimating the height of someone using standard arithmetic as 2.0 metres, using interval arithmetic we might be certain that that person is somewhere between 1.97 and 2.03 metres.", 
    "name": "Interval Arithmetic", 
    "classification": "Numerical Analysis", 
    "full_text": "Interval arithmetic, interval mathematics, interval analysis, or interval computation, is a method developed by mathematicians since the 1950s and 1960s, as an approach to putting bounds on rounding errors and measurement errors in mathematical computation and thus developing numerical methods that yield reliable results. Very simply put, it represents each value as a range of possibilities. For example, instead of estimating the height of someone using standard arithmetic as 2.0 metres, using interval arithmetic we might be certain that that person is somewhere between 1.97 and 2.03 metres.\nThis concept is suitable for a variety of purposes. The most common use is to keep track of and handle rounding errors directly during the calculation and of uncertainties in the knowledge of the exact values of physical and technical parameters. The latter often arise from measurement errors and tolerances for components or due to limits on computational accuracy. Interval arithmetic also helps find reliable and guaranteed solutions to equations and optimization problems.\nMathematically, instead of working with an uncertain real \n\n\n\nx\n\n\n{\\displaystyle x}\n\n we work with the two ends of the interval \n\n\n\n[\na\n,\nb\n]\n\n\n{\\displaystyle [a,b]}\n\n that contains \n\n\n\nx\n\n\n{\\displaystyle x}\n\n. In interval arithmetic, any variable \n\n\n\nx\n\n\n{\\displaystyle x}\n\n lies between \n\n\n\na\n\n\n{\\displaystyle a}\n\n and \n\n\n\nb\n\n\n{\\displaystyle b}\n\n, or could be one of them. A function \n\n\n\nf\n\n\n{\\displaystyle f}\n\n when applied to \n\n\n\nx\n\n\n{\\displaystyle x}\n\n is also uncertain. In interval arithmetic \n\n\n\nf\n\n\n{\\displaystyle f}\n\n produces an interval \n\n\n\n[\nc\n,\nd\n]\n\n\n{\\displaystyle [c,d]}\n\n that is all the possible values for \n\n\n\nf\n(\nx\n)\n\n\n{\\displaystyle f(x)}\n\n for all \n\n\n\nx\n\u2208\n[\na\n,\nb\n]\n\n\n{\\displaystyle x\\in [a,b]}\n\n.\n\n\nThe main focus of interval arithmetic is the simplest way to calculate upper and lower endpoints for the range of values of a function in one or more variables. These endpoints are not necessarily the supremum or infimum, since the precise calculation of those values can be difficult or impossible.\nTreatment is typically limited to real intervals, so quantities of form\nwhere \n\n\n\na\n=\n\n\u2212\n\u221e\n\n\n\n{\\displaystyle a={-\\infty }}\n\n and \n\n\n\nb\n=\n\n\u221e\n\n\n\n{\\displaystyle b={\\infty }}\n\n are allowed; with one of them infinite we would have an unbounded interval, while with both infinite we would have the extended real number line.\nAs with traditional calculations with real numbers, simple arithmetic operations and functions on elementary intervals must first be defined.[1] More complicated functions can be calculated from these basic elements.[1]\nTake as an example the calculation of body mass index (BMI). The BMI is the body weight in kilograms divided by the square of height in metres. A bathroom scale may have a resolution of one kilogram. We do not know intermediate values\u00a0\u2013  about 79.6\u00a0kg or 80.3\u00a0kg\u00a0\u2013  but information rounded to the nearest whole number. It is unlikely that when the scale reads 80\u00a0kg, someone really weighs exactly 80.0\u00a0kg. In normal rounding to the nearest value, the scales showing 80\u00a0kg indicates a weight between 79.5\u00a0kg and 80.5\u00a0kg. The relevant range is that of all real numbers that are greater than or equal to 79.5, while less than or equal to 80.5, or in other words the interval [79.5,80.5].\nFor a man who weighs 80\u00a0kg and is 1.80\u00a0m tall, the BMI is about 24.7. With a weight of 79.5\u00a0kg and the same height the value is 24.5, while 80.5 kilograms gives almost 24.9. So the actual BMI is in the range [24.5,24.9]. The error in this case does not affect the conclusion (normal weight), but this is not always the position. For example, weight fluctuates in the course of a day so that the BMI can vary between 24 (normal weight) and 25 (overweight). Without detailed analysis it is not possible to always exclude questions as to whether an error ultimately is large enough to have significant influence.\nInterval arithmetic states the range of possible outcomes explicitly. Simply put, results are no longer stated as numbers, but as intervals that represent imprecise values. The size of the intervals are similar to error bars to a metric in expressing the extent of uncertainty. Simple arithmetic operations, such as basic arithmetic and trigonometric functions, enable the calculation of outer limits of intervals.\nReturning to the earlier BMI example, in determining the body mass index, height and body weight both affect the result. For height, measurements are usually in round centimetres: a recorded measurement of 1.80 metres actually means a height somewhere between 1.795\u00a0m and 1.805\u00a0m. This uncertainty must be combined with the fluctuation range in weight between 79.5\u00a0kg and 80.5\u00a0kg. The BMI is defined as the weight in kilograms divided by the square of height in metre. Using either 79.5\u00a0kg and 1.795\u00a0m or 80.5\u00a0kg and 1.805\u00a0m gives approximately 24.7. But the person in question may only be 1.795\u00a0m tall, with a weight of 80.5 kilograms\u00a0\u2013  or 1.805\u00a0m and 79.5 kilograms: all combinations of all possible intermediate values must be considered. Using the interval arithmetic methods described below, the BMI lies in the interval\nAn operation \n\n\n\n\n\u27e8\n\n\no\np\n\n\n\u27e9\n\n\n\n{\\displaystyle {\\langle \\!\\mathrm {op} \\!\\rangle }}\n\n, such as addition or multiplication, on two intervals is defined by\nFor the four basic arithmetic operations this can become\nprovided that \n\n\n\nx\n\n\n\u27e8\n\n\no\np\n\n\n\u27e9\n\n\ny\n\n\n{\\displaystyle x{\\,\\langle \\!\\mathrm {op} \\!\\rangle \\,}y}\n\n is allowed for all \n\n\n\nx\n\u2208\n[\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n]\n\n\n{\\displaystyle x\\in [x_{1},x_{2}]}\n\n and \n\n\n\ny\n\u2208\n[\n\ny\n\n1\n\n\n,\n\ny\n\n2\n\n\n]\n\n\n{\\displaystyle y\\in [y_{1},y_{2}]}\n\n.\nFor practical applications this can be simplified further:\nFor division by an interval including zero, first define\nFor \n\n\n\n\ny\n\n1\n\n\n<\n0\n<\n\ny\n\n2\n\n\n\n\n{\\displaystyle y_{1}<0<y_{2}}\n\n, we get \n\n\n\n1\n\n/\n\n[\n\ny\n\n1\n\n\n,\n\ny\n\n2\n\n\n]\n=\n[\n\u2212\n\u221e\n,\n1\n\n/\n\n\ny\n\n1\n\n\n]\n\u222a\n[\n1\n\n/\n\n\ny\n\n2\n\n\n,\n\u221e\n]\n\n\n{\\displaystyle 1/[y_{1},y_{2}]=[-\\infty ,1/y_{1}]\\cup [1/y_{2},\\infty ]}\n\n, which as a single interval gives \n\n\n\n1\n\n/\n\n[\n\ny\n\n1\n\n\n,\n\ny\n\n2\n\n\n]\n=\n[\n\u2212\n\u221e\n,\n\u221e\n]\n\n\n{\\displaystyle 1/[y_{1},y_{2}]=[-\\infty ,\\infty ]}\n\n. This loses useful information about \n\n\n\n(\n1\n\n/\n\n\ny\n\n1\n\n\n,\n1\n\n/\n\n\ny\n\n2\n\n\n)\n\n\n{\\displaystyle (1/y_{1},1/y_{2})}\n\n. So typically it is common to work with \n\n\n\n[\n\u2212\n\u221e\n,\n1\n\n/\n\n\ny\n\n1\n\n\n]\n\n\n{\\displaystyle [-\\infty ,1/y_{1}]}\n\n and \n\n\n\n[\n1\n\n/\n\n\ny\n\n2\n\n\n,\n\u221e\n]\n\n\n{\\displaystyle [1/y_{2},\\infty ]}\n\n as separate intervals.\nBecause several such divisions may occur in an interval arithmetic calculation, it is sometimes useful to do the calculation with so-called multi-intervals of the form \n\n\n\n\n\n\u22c3\n\ni\n=\n1\n\n\nl\n\n\n[\n\nx\n\ni\n1\n\n\n,\n\nx\n\ni\n2\n\n\n]\n\n\n\n{\\displaystyle \\textstyle \\bigcup _{i=1}^{l}[x_{i1},x_{i2}]}\n\n. The corresponding multi-interval arithmetic maintains a disjoint set of intervals and also provides for overlapping intervals to unite.[2][page\u00a0needed]\nSince a real number \n\n\n\nr\n\u2208\n\nR\n\n\n\n{\\displaystyle r\\in \\mathbb {R} }\n\n can be interpreted as the interval \n\n\n\n[\nr\n,\nr\n]\n\n\n{\\displaystyle [r,r]}\n\n, intervals and real numbers can be freely and easily combined.\nWith the help of these definitions, it is already possible to calculate the range of simple functions, such as \n\n\n\nf\n(\na\n,\nb\n,\nx\n)\n=\na\n\u22c5\nx\n+\nb\n\n\n{\\displaystyle f(a,b,x)=a\\cdot x+b}\n\n. If, for example, \n\n\n\na\n=\n[\n1\n,\n2\n]\n\n\n{\\displaystyle a=[1,2]}\n\n, \n\n\n\nb\n=\n[\n5\n,\n7\n]\n\n\n{\\displaystyle b=[5,7]}\n\n and \n\n\n\nx\n=\n[\n2\n,\n3\n]\n\n\n{\\displaystyle x=[2,3]}\n\n, it is clear\nInterpreting this as a function \n\n\n\nf\n(\na\n,\nb\n,\nx\n)\n\n\n{\\displaystyle f(a,b,x)}\n\n of the variable \n\n\n\nx\n\n\n{\\displaystyle x}\n\n with interval parameters \n\n\n\na\n\n\n{\\displaystyle a}\n\n and \n\n\n\nb\n\n\n{\\displaystyle b}\n\n, then it is possible to find the roots of this function. It is then\nthe possible zeros are in the interval \n\n\n\n[\n\u2212\n7\n,\n\n\u2212\n2.5\n\n]\n\n\n{\\displaystyle [-7,{-2.5}]}\n\n.\nAs in the above example, the multiplication of intervals often only requires two multiplications. It is in fact\nThe multiplication can be seen as a destination area of a rectangle with varying edges. The result interval covers all levels from the smallest to the largest.\nThe same applies when one of the two intervals is non-positive and the other non-negative. Generally, multiplication can produce results as wide as \n\n\n\n[\n\u2212\n\u221e\n,\n\u221e\n]\n\n\n{\\displaystyle [-\\infty ,\\infty ]}\n\n, for example if \n\n\n\n0\n\u22c5\n\u221e\n\n\n{\\displaystyle 0\\cdot \\infty }\n\n is squared. This also occurs, for example, in a division, if the numerator and denominator both contain zero.\nTo make the notation of intervals smaller in formulae, brackets can be used.\nSo we can use \n\n\n\n[\nx\n]\n\u2261\n[\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n]\n\n\n{\\displaystyle [x]\\equiv [x_{1},x_{2}]}\n\n to represent an interval. For the set of all finite intervals, we can use\nas an abbreviation. For a vector of intervals \n\n\n\n\n\n(\n\n\n[\nx\n\n]\n\n1\n\n\n,\n\u2026\n,\n[\nx\n\n]\n\nn\n\n\n\n\n)\n\n\n\u2208\n[\n\nR\n\n\n]\n\nn\n\n\n\n\n{\\displaystyle {\\big (}[x]_{1},\\ldots ,[x]_{n}{\\big )}\\in [\\mathbb {R} ]^{n}}\n\n we can also use a bold font: \n\n\n\n[\n\nx\n\n]\n\n\n{\\displaystyle [\\mathbf {x} ]}\n\n.\nNote that in such a compact notation, \n\n\n\n[\nx\n]\n\n\n{\\displaystyle [x]}\n\n should not be confused between a so-called improper or single point interval \n\n\n\n[\n\nx\n\n1\n\n\n,\n\nx\n\n1\n\n\n]\n\n\n{\\displaystyle [x_{1},x_{1}]}\n\n and the lower and upper limit.\nInterval methods can also apply to functions that do not just use simple arithmetic, and we must also use other basic functions to redefine intervals, using already known monotonicity properties.\nFor monotonic functions in one variable, the range of values is also easy. If \n\n\n\nf\n:\n\nR\n\n\u2192\n\nR\n\n\n\n{\\displaystyle f:\\mathbb {R} \\rightarrow \\mathbb {R} }\n\n is monotonically rising or falling in the interval \n\n\n\n[\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n]\n\n\n{\\displaystyle [x_{1},x_{2}]}\n\n, then for all values in the interval \n\n\n\n\ny\n\n1\n\n\n,\n\ny\n\n2\n\n\n\u2208\n[\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n]\n\n\n{\\displaystyle y_{1},y_{2}\\in [x_{1},x_{2}]}\n\n such that \n\n\n\n\ny\n\n1\n\n\n\u2264\n\ny\n\n2\n\n\n\n\n{\\displaystyle y_{1}\\leq y_{2}}\n\n, one of the following inequalities applies:\nThe range corresponding to the interval \n\n\n\n[\n\ny\n\n1\n\n\n,\n\ny\n\n2\n\n\n]\n\u2286\n[\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n]\n\n\n{\\displaystyle [y_{1},y_{2}]\\subseteq [x_{1},x_{2}]}\n\n can be calculated by applying the function to the endpoints \n\n\n\n\ny\n\n1\n\n\n\n\n{\\displaystyle y_{1}}\n\n and \n\n\n\n\ny\n\n2\n\n\n\n\n{\\displaystyle y_{2}}\n\n:\nFrom this the following basic features for interval functions can easily be defined:\nFor even powers, the range of values being considered is important, and needs to be dealt with before doing any multiplication. For example, \n\n\n\n\nx\n\nn\n\n\n\n\n{\\displaystyle x^{n}}\n\n for \n\n\n\nx\n\u2208\n[\n\u2212\n1\n,\n1\n]\n\n\n{\\displaystyle x\\in [-1,1]}\n\n should produce the interval \n\n\n\n[\n0\n,\n1\n]\n\n\n{\\displaystyle [0,1]}\n\n when \n\n\n\nn\n=\n2\n,\n4\n,\n6\n,\n\u2026\n\n\n{\\displaystyle n=2,4,6,\\ldots }\n\n. But if \n\n\n\n[\n\u2212\n1\n,\n1\n\n]\n\nn\n\n\n\n\n{\\displaystyle [-1,1]^{n}}\n\n is taken by applying interval multiplication of form \n\n\n\n[\n\u2212\n1\n,\n1\n]\n\u22c5\n\u2026\n\u22c5\n[\n\u2212\n1\n,\n1\n]\n\n\n{\\displaystyle [-1,1]\\cdot \\ldots \\cdot [-1,1]}\n\n then the result appears to be \n\n\n\n[\n\u2212\n1\n,\n1\n]\n\n\n{\\displaystyle [-1,1]}\n\n, wider than necessary.\nInstead consider the function \n\n\n\n\nx\n\nn\n\n\n\n\n{\\displaystyle x^{n}}\n\n as a monotonically decreasing function for \n\n\n\nx\n<\n0\n\n\n{\\displaystyle x<0}\n\n and a monotonically increasing function for \n\n\n\nx\n>\n0\n\n\n{\\displaystyle x>0}\n\n. So for even \n\n\n\nn\n\u2208\n\nN\n\n\n\n{\\displaystyle n\\in \\mathbb {N} }\n\n:\nMore generally, one can say that for piecewise monotonic functions it is sufficient to consider the endpoints \n\n\n\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n\n\n{\\displaystyle x_{1},x_{2}}\n\n of the interval \n\n\n\n[\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n]\n\n\n{\\displaystyle [x_{1},x_{2}]}\n\n, together with the so-called critical points within the interval being those points where the monotonicity of the function changes direction.\nFor the sine and cosine functions, the critical points are at \n\n\n\n\n(\n\n\n\n\n1\n\n\n\n\n\n/\n\n\n\n\n\n\n2\n\n\n+\n\nn\n\n)\n\n\u22c5\n\u03c0\n\n\n{\\displaystyle \\left({}^{1}\\!\\!/\\!{}_{2}+{n}\\right)\\cdot \\pi }\n\n or \n\n\n\n\nn\n\n\u22c5\n\u03c0\n\n\n{\\displaystyle {n}\\cdot \\pi }\n\n for all \n\n\n\nn\n\u2208\n\nZ\n\n\n\n{\\displaystyle n\\in \\mathbb {Z} }\n\n respectively. Only up to five points matter as the resulting interval is \n\n\n\n[\n\u2212\n1\n,\n1\n]\n\n\n{\\displaystyle [-1,1]}\n\n if the interval includes at least two extrema. For sine and cosine, only the endpoints need full evaluation as the critical points lead to easily pre-calculated values \u2013 namely -1, 0, +1.\nIn general, it may not be easy to find such a simple description of the output interval for many functions. But it may still be possible to extend functions to interval arithmetic. If \n\n\n\nf\n:\n\n\nR\n\n\nn\n\n\n\u2192\n\nR\n\n\n\n{\\displaystyle f:\\mathbb {R} ^{n}\\rightarrow \\mathbb {R} }\n\n is a function from a real vector to a real number, then \u00a0\n\n\n\n[\nf\n]\n:\n[\n\nR\n\n\n]\n\nn\n\n\n\u2192\n[\n\nR\n\n]\n\n\n{\\displaystyle [f]:[\\mathbb {R} ]^{n}\\rightarrow [\\mathbb {R} ]}\n\n is called an interval extension of \n\n\n\nf\n\n\n{\\displaystyle f}\n\n if\nThis definition of the interval extension does not give a precise result. For example, both \n\n\n\n[\nf\n]\n(\n[\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n]\n)\n=\n[\n\ne\n\n\nx\n\n1\n\n\n\n\n,\n\ne\n\n\nx\n\n2\n\n\n\n\n]\n\n\n{\\displaystyle [f]([x_{1},x_{2}])=[e^{x_{1}},e^{x_{2}}]}\n\n and \n\n\n\n[\ng\n]\n(\n[\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n]\n)\n=\n[\n\n\u2212\n\u221e\n\n,\n\n\u221e\n\n]\n\n\n{\\displaystyle [g]([x_{1},x_{2}])=[{-\\infty },{\\infty }]}\n\n are allowable extensions of the exponential function. Extensions as tight as possible are desirable, taking into the relative costs of calculation and imprecision; in this case \n\n\n\n[\nf\n]\n\n\n{\\displaystyle [f]}\n\n should be chosen as it give the tightest possible result.\nThe natural interval extension is achieved by combining the function rule \n\n\n\nf\n(\n\nx\n\n1\n\n\n,\n\u22ef\n,\n\nx\n\nn\n\n\n)\n\n\n{\\displaystyle f(x_{1},\\cdots ,x_{n})}\n\n with the equivalents of the basic arithmetic and elementary functions.\nThe Taylor interval extension (of degree \n\n\n\nk\n\n\n{\\displaystyle k}\n\n ) is a \n\n\n\nk\n+\n1\n\n\n{\\displaystyle k+1}\n\n times differentiable function \n\n\n\nf\n\n\n{\\displaystyle f}\n\n defined by\nfor some \n\n\n\n\ny\n\n\u2208\n[\n\nx\n\n]\n\n\n{\\displaystyle \\mathbf {y} \\in [\\mathbf {x} ]}\n\n, where \n\n\n\n\n\nD\n\n\ni\n\n\nf\n(\n\ny\n\n)\n\n\n{\\displaystyle \\mathrm {D} ^{i}f(\\mathbf {y} )}\n\n is the \n\n\n\ni\n\n\n{\\displaystyle i}\n\nth order differential of \n\n\n\nf\n\n\n{\\displaystyle f}\n\n at the point \n\n\n\n\ny\n\n\n\n{\\displaystyle \\mathbf {y} }\n\n and \n\n\n\n[\nr\n]\n\n\n{\\displaystyle [r]}\n\n is an interval extension of the Taylor remainder\nThe vector \n\n\n\n\u03be\n\n\n{\\displaystyle \\xi }\n\n lies between \n\n\n\n\nx\n\n\n\n{\\displaystyle \\mathbf {x} }\n\n and \n\n\n\n\ny\n\n\n\n{\\displaystyle \\mathbf {y} }\n\n with \n\n\n\n\nx\n\n,\n\ny\n\n\u2208\n[\n\nx\n\n]\n\n\n{\\displaystyle \\mathbf {x} ,\\mathbf {y} \\in [\\mathbf {x} ]}\n\n, \n\n\n\n\u03be\n\n\n{\\displaystyle \\xi }\n\n is protected by \n\n\n\n[\n\nx\n\n]\n\n\n{\\displaystyle [\\mathbf {x} ]}\n\n. Usually one chooses \n\n\n\n\ny\n\n\n\n{\\displaystyle \\mathbf {y} }\n\n to be the midpoint of the interval and uses the natural interval extension to assess the remainder.\nThe special case of the Taylor interval extension of degree \n\n\n\nk\n=\n0\n\n\n{\\displaystyle k=0}\n\n is also referred to as the mean value form. For an interval extension of the Jacobian \n\n\n\n[\n\nJ\n\nf\n\n\n]\n(\n\n[\nx\n]\n\n)\n\n\n{\\displaystyle [J_{f}](\\mathbf {[x]} )}\n\n we get\nA nonlinear function can be defined by linear features.\nAn interval can also be defined as a locus of points at a given distance from the centre, and this definition can be extended from real numbers to complex numbers.[3] As it is the case with computing with real numbers, computing with complex numbers involves uncertain data. So, given the fact that an interval number is a real closed interval and a complex number is an ordered pair of real numbers, there is no reason to limit the application of interval arithmetic to the measure of uncertainties in computations with real numbers.[4] Interval arithmetic can thus be extended, via complex interval numbers, to determine regions of uncertainty in computing with complex numbers.[4]\nThe basic algebraic operations for real interval numbers (real closed intervals) can be extended to complex numbers. It is therefore not surprising that complex interval arithmetic is similar to, but not the same as, ordinary complex arithmetic.[4] It can be shown that, as it is the case with real interval arithmetic, there is no distributivity between addition and multiplication of complex interval numbers except for certain special cases, and inverse elements do not always exist for complex interval numbers.[4] Two other useful properties of ordinary complex arithmetic fail to hold in complex interval arithmetic: the additive and multiplicative properties, of ordinary complex conjugates, do not hold for complex interval conjugates.[4]\nInterval arithmetic can be extended, in an analogous manner, to other multidimensional number systems such as quaternions and octonions, but with the expense that we have to sacrifice other useful properties of ordinary arithmetic.[4]\nThe methods of classical numerical analysis can not be transferred one-to-one into interval-valued algorithms, as dependencies between numerical values are usually not taken into account.\nTo work effectively in a real-life implementation, intervals must be compatible with floating point computing. The earlier operations were based on exact arithmetic, but in general fast numerical solution methods may not be available. The range of values of the function \n\n\n\nf\n(\nx\n,\ny\n)\n=\nx\n+\ny\n\n\n{\\displaystyle f(x,y)=x+y}\n\n for \n\n\n\nx\n\u2208\n[\n0.1\n,\n0.8\n]\n\n\n{\\displaystyle x\\in [0.1,0.8]}\n\n and \n\n\n\ny\n\u2208\n[\n0.06\n,\n0.08\n]\n\n\n{\\displaystyle y\\in [0.06,0.08]}\n\n are for example \n\n\n\n[\n0.16\n,\n0.88\n]\n\n\n{\\displaystyle [0.16,0.88]}\n\n. Where the same calculation is done with single digit precision, the result would normally be \n\n\n\n[\n0.2\n,\n0.9\n]\n\n\n{\\displaystyle [0.2,0.9]}\n\n. But \n\n\n\n[\n0.2\n,\n0.9\n]\n\u2289\n[\n0.16\n,\n0.88\n]\n\n\n{\\displaystyle [0.2,0.9]\\not \\supseteq [0.16,0.88]}\n\n, so this approach would contradict the basic principles of interval arithmetic, as a part of the domain of \n\n\n\nf\n(\n[\n0.1\n,\n0.8\n]\n,\n[\n0.06\n,\n0.08\n]\n)\n\n\n{\\displaystyle f([0.1,0.8],[0.06,0.08])}\n\n would be lost. Instead, the outward rounded solution \n\n\n\n[\n0.1\n,\n0.9\n]\n\n\n{\\displaystyle [0.1,0.9]}\n\n is used.\nThe standard IEEE 754 for binary floating-point arithmetic also sets out procedures for the implementation of rounding. An IEEE 754 compliant system allows programmers to round to the nearest floating point number; alternatives are rounding towards 0 (truncating), rounding toward positive infinity (i.e. up), or rounding towards negative infinity (i.e. down).\nThe required external rounding for interval arithmetic can thus be achieved by changing the rounding settings of the processor in the calculation of the upper limit (up) and lower limit (down). Alternatively, an appropriate small interval \n\n\n\n[\n\n\u03b5\n\n1\n\n\n,\n\n\u03b5\n\n2\n\n\n]\n\n\n{\\displaystyle [\\varepsilon _{1},\\varepsilon _{2}]}\n\n can be added.\nThe so-called dependency problem is a major obstacle to the application of interval arithmetic. Although interval methods can determine the range of elementary arithmetic operations and functions very accurately, this is not always true with more complicated functions. If an interval occurs several times in a calculation using parameters, and each occurrence is taken independently then this can lead to an unwanted expansion of the resulting intervals.\nAs an illustration, take the function \n\n\n\nf\n\n\n{\\displaystyle f}\n\n defined by \n\n\n\nf\n(\nx\n)\n=\n\nx\n\n2\n\n\n+\nx\n\n\n{\\displaystyle f(x)=x^{2}+x}\n\n. The values of this function over the interval \n\n\n\n[\n\u2212\n1\n,\n1\n]\n\n\n{\\displaystyle [-1,1]}\n\n are really \n\n\n\n[\n\u2212\n1\n\n/\n\n4\n,\n2\n]\n\n\n{\\displaystyle [-1/4,2]}\n\n. As the natural interval extension, it is calculated as \n\n\n\n[\n\u2212\n1\n,\n1\n\n]\n\n2\n\n\n+\n[\n\u2212\n1\n,\n1\n]\n=\n[\n0\n,\n1\n]\n+\n[\n\u2212\n1\n,\n1\n]\n=\n[\n\u2212\n1\n,\n2\n]\n\n\n{\\displaystyle [-1,1]^{2}+[-1,1]=[0,1]+[-1,1]=[-1,2]}\n\n, which is slightly larger; we have instead calculated the infimum and supremum of the function \n\n\n\nh\n(\nx\n,\ny\n)\n=\n\nx\n\n2\n\n\n+\ny\n\n\n{\\displaystyle h(x,y)=x^{2}+y}\n\n over \n\n\n\nx\n,\ny\n\u2208\n[\n\u2212\n1\n,\n1\n]\n\n\n{\\displaystyle x,y\\in [-1,1]}\n\n. There is a better expression of \n\n\n\nf\n\n\n{\\displaystyle f}\n\n in which the variable \n\n\n\nx\n\n\n{\\displaystyle x}\n\n only appears once, namely by rewriting \n\n\n\nf\n(\nx\n)\n=\n\nx\n\n2\n\n\n+\nx\n\n\n{\\displaystyle f(x)=x^{2}+x}\n\n as addition and squaring in the quadratic \n\n\n\nf\n(\nx\n)\n=\n\n\n(\nx\n+\n\n\n1\n2\n\n\n)\n\n\n2\n\n\n\u2212\n\n\n1\n4\n\n\n\n\n{\\displaystyle f(x)=\\left(x+{\\frac {1}{2}}\\right)^{2}-{\\frac {1}{4}}}\n\n.\nSo the suitable interval calculation is\nand gives the correct values.\nIn general, it can be shown that the exact range of values can be achieved, if each variable appears only once and if \n\n\n\nf\n\n\n{\\displaystyle f}\n\n is continuous inside the box. However, not every function can be rewritten this way.\nThe dependency of the problem causing over-estimation of the value range can go as far as covering a large range, preventing more meaningful conclusions.\nAn additional increase in the range stems from the solution of areas that do not take the form of an interval vector. The solution set of the linear system\nfor \n\n\n\np\n\u2208\n[\n\u2212\n1\n,\n1\n]\n\n\n{\\displaystyle p\\in [-1,1]}\n\n is precisely the line between the points \n\n\n\n(\n\u2212\n1\n,\n\u2212\n1\n)\n\n\n{\\displaystyle (-1,-1)}\n\n and \n\n\n\n(\n1\n,\n1\n)\n\n\n{\\displaystyle (1,1)}\n\n. Using interval methods results in the unit square, \n\n\n\n[\n\u2212\n1\n,\n1\n]\n\u00d7\n[\n\u2212\n1\n,\n1\n]\n\n\n{\\displaystyle [-1,1]\\times [-1,1]}\n\n. This is known as the wrapping effect.\nA linear interval system consists of a matrix interval extension \n\n\n\n[\n\nA\n\n]\n\u2208\n[\n\nR\n\n\n]\n\nn\n\u00d7\nm\n\n\n\n\n{\\displaystyle [\\mathbf {A} ]\\in [\\mathbb {R} ]^{n\\times m}}\n\n and an interval vector \n\n\n\n[\n\nb\n\n]\n\u2208\n[\n\nR\n\n\n]\n\nn\n\n\n\n\n{\\displaystyle [\\mathbf {b} ]\\in [\\mathbb {R} ]^{n}}\n\n. We want the smallest cuboid \n\n\n\n[\n\nx\n\n]\n\u2208\n[\n\nR\n\n\n]\n\nm\n\n\n\n\n{\\displaystyle [\\mathbf {x} ]\\in [\\mathbb {R} ]^{m}}\n\n, for all vectors \n\n\n\n\nx\n\n\u2208\n\n\nR\n\n\nm\n\n\n\n\n{\\displaystyle \\mathbf {x} \\in \\mathbb {R} ^{m}}\n\n which there is a pair \n\n\n\n(\n\nA\n\n,\n\nb\n\n)\n\n\n{\\displaystyle (\\mathbf {A} ,\\mathbf {b} )}\n\n with \n\n\n\n\nA\n\n\u2208\n[\n\nA\n\n]\n\n\n{\\displaystyle \\mathbf {A} \\in [\\mathbf {A} ]}\n\n and \n\n\n\n\nb\n\n\u2208\n[\n\nb\n\n]\n\n\n{\\displaystyle \\mathbf {b} \\in [\\mathbf {b} ]}\n\n satisfying\nFor quadratic systems \u2013 in other words, for \n\n\n\nn\n=\nm\n\n\n{\\displaystyle n=m}\n\n \u2013 there can be such an interval vector \n\n\n\n[\n\nx\n\n]\n\n\n{\\displaystyle [\\mathbf {x} ]}\n\n, which covers all possible solutions, found simply with the interval Gauss method. This replaces the numerical operations, in that the linear algebra method known as Gaussian elimination becomes its interval version. However, since this method uses the interval entities\n\n\n\n[\n\nA\n\n]\n\n\n{\\displaystyle [\\mathbf {A} ]}\n\n and \n\n\n\n[\n\nb\n\n]\n\n\n{\\displaystyle [\\mathbf {b} ]}\n\n repeatedly in the calculation, it can produce poor results for some problems. Hence using the result of the interval-valued Gauss only provides first rough estimates, since although it contains the entire solution set, it also has a large area outside it.\nA rough solution \n\n\n\n[\n\nx\n\n]\n\n\n{\\displaystyle [\\mathbf {x} ]}\n\n can often be improved by an interval version of the Gauss\u2013Seidel method. The motivation for this is that the \n\n\n\ni\n\n\n{\\displaystyle i}\n\n-th row of the interval extension of the linear equation\ncan be determined by the variable \n\n\n\n\nx\n\ni\n\n\n\n\n{\\displaystyle x_{i}}\n\n if the division \n\n\n\n1\n\n/\n\n[\n\na\n\ni\ni\n\n\n]\n\n\n{\\displaystyle 1/[a_{ii}]}\n\n is allowed. It is therefore simultaneously\nSo we can now replace \n\n\n\n[\n\nx\n\nj\n\n\n]\n\n\n{\\displaystyle [x_{j}]}\n\n by\nand so the vector \n\n\n\n[\n\nx\n\n]\n\n\n{\\displaystyle [\\mathbf {x} ]}\n\n by each element. Since the procedure is more efficient for a diagonally dominant matrix, instead of the system \n\n\n\n[\n\nA\n\n]\n\u22c5\n\nx\n\n=\n[\n\nb\n\n]\n\n,\n\n\n\n{\\displaystyle [\\mathbf {A} ]\\cdot \\mathbf {x} =[\\mathbf {b} ]{\\mbox{,}}}\n\n one can often try multiplying it by an appropriate rational matrix \n\n\n\n\nM\n\n\n\n{\\displaystyle \\mathbf {M} }\n\n with the resulting matrix equation\nleft to solve. If one chooses, for example, \n\n\n\n\nM\n\n=\n\n\nA\n\n\n\u2212\n1\n\n\n\n\n{\\displaystyle \\mathbf {M} =\\mathbf {A} ^{-1}}\n\n for the central matrix \n\n\n\n\nA\n\n\u2208\n[\n\nA\n\n]\n\n\n{\\displaystyle \\mathbf {A} \\in [\\mathbf {A} ]}\n\n, then \n\n\n\n\nM\n\n\u22c5\n[\n\nA\n\n]\n\n\n{\\displaystyle \\mathbf {M} \\cdot [\\mathbf {A} ]}\n\n is outer extension of the identity matrix.\nThese methods only work well if the widths of the intervals occurring are sufficiently small. For wider intervals it can be useful to use an interval-linear system on finite (albeit large) real number equivalent linear systems. If all the matrices \n\n\n\n\nA\n\n\u2208\n[\n\nA\n\n]\n\n\n{\\displaystyle \\mathbf {A} \\in [\\mathbf {A} ]}\n\n are invertible, it is sufficient to consider all possible combinations (upper and lower) of the endpoints occurring in the intervals. The resulting problems can be resolved using conventional numerical methods. Interval arithmetic is still used to determine rounding errors.\nThis is only suitable for systems of smaller dimension, since with a fully occupied \n\n\n\nn\n\u00d7\nn\n\n\n{\\displaystyle n\\times n}\n\n matrix, \n\n\n\n\n2\n\n\nn\n\n2\n\n\n\n\n\n\n{\\displaystyle 2^{n^{2}}}\n\n real matrices need to be inverted, with \n\n\n\n\n2\n\nn\n\n\n\n\n{\\displaystyle 2^{n}}\n\n vectors for the right hand side. This approach was developed by Jiri Rohn and is still being developed.[5]\nAn interval variant of Newton's method for finding the zeros in an interval vector \n\n\n\n[\n\nx\n\n]\n\n\n{\\displaystyle [\\mathbf {x} ]}\n\n can be derived from the average value extension.[6] For an unknown vector \n\n\n\n\nz\n\n\u2208\n[\n\nx\n\n]\n\n\n{\\displaystyle \\mathbf {z} \\in [\\mathbf {x} ]}\n\n applied to \n\n\n\n\ny\n\n\u2208\n[\n\nx\n\n]\n\n\n{\\displaystyle \\mathbf {y} \\in [\\mathbf {x} ]}\n\n, gives\nFor a zero \n\n\n\n\nz\n\n\n\n{\\displaystyle \\mathbf {z} }\n\n, that is \n\n\n\nf\n(\nz\n)\n=\n0\n\n\n{\\displaystyle f(z)=0}\n\n, and thus must satisfy\nThis is equivalent to \n\n\n\n\nz\n\n\u2208\n\ny\n\n\u2212\n[\n\nJ\n\nf\n\n\n]\n(\n\n[\nx\n]\n\n\n)\n\n\u2212\n1\n\n\n\u22c5\nf\n(\n\ny\n\n)\n\n\n{\\displaystyle \\mathbf {z} \\in \\mathbf {y} -[J_{f}](\\mathbf {[x]} )^{-1}\\cdot f(\\mathbf {y} )}\n\n. An outer estimate of \n\n\n\n[\n\nJ\n\nf\n\n\n]\n(\n\n[\nx\n]\n\n\n)\n\n\u2212\n1\n\n\n\u22c5\nf\n(\n\ny\n\n)\n)\n\n\n{\\displaystyle [J_{f}](\\mathbf {[x]} )^{-1}\\cdot f(\\mathbf {y} ))}\n\n can be determined using linear methods.\nIn each step of the interval Newton method, an approximate starting value \n\n\n\n[\n\nx\n\n]\n\u2208\n[\n\nR\n\n\n]\n\nn\n\n\n\n\n{\\displaystyle [\\mathbf {x} ]\\in [\\mathbb {R} ]^{n}}\n\n is replaced by \n\n\n\n[\n\nx\n\n]\n\u2229\n\n(\n\ny\n\n\u2212\n[\n\nJ\n\nf\n\n\n]\n(\n\n[\nx\n]\n\n\n)\n\n\u2212\n1\n\n\n\u22c5\nf\n(\n\ny\n\n)\n)\n\n\n\n{\\displaystyle [\\mathbf {x} ]\\cap \\left(\\mathbf {y} -[J_{f}](\\mathbf {[x]} )^{-1}\\cdot f(\\mathbf {y} )\\right)}\n\n and so the result can be improved iteratively. In contrast to traditional methods, the interval method approaches the result by containing the zeros. This guarantees that the result produces all zeros in the initial range. Conversely, it proves that no zeros of \n\n\n\nf\n\n\n{\\displaystyle f}\n\n were in the initial range \n\n\n\n[\n\nx\n\n]\n\n\n{\\displaystyle [\\mathbf {x} ]}\n\n if a Newton step produces the empty set.\nThe method converges on all zeros in the starting region. Division by zero can lead to separation of distinct zeros, though the separation may not be complete; it can be complemented by the bisection method.\nAs an example, consider the function \n\n\n\nf\n(\nx\n)\n=\n\nx\n\n2\n\n\n\u2212\n2\n\n\n{\\displaystyle f(x)=x^{2}-2}\n\n, the starting range \n\n\n\n[\nx\n]\n=\n[\n\u2212\n2\n,\n2\n]\n\n\n{\\displaystyle [x]=[-2,2]}\n\n, and the point \n\n\n\ny\n=\n0\n\n\n{\\displaystyle y=0}\n\n. We then have \n\n\n\n\nJ\n\nf\n\n\n(\nx\n)\n=\n2\n\nx\n\n\n{\\displaystyle J_{f}(x)=2\\,x}\n\n and the first Newton step gives\nMore Newton steps are used separately on \n\n\n\nx\n\u2208\n[\n\n\u2212\n2\n\n,\n\n\u2212\n0.5\n\n]\n\n\n{\\displaystyle x\\in [{-2},{-0.5}]}\n\n and \n\n\n\n[\n\n0.5\n\n,\n\n2\n\n]\n\n\n{\\displaystyle [{0.5},{2}]}\n\n. These converge to arbitrarily small intervals around \n\n\n\n\u2212\n\n\n2\n\n\n\n\n{\\displaystyle -{\\sqrt {2}}}\n\n and \n\n\n\n+\n\n\n2\n\n\n\n\n{\\displaystyle +{\\sqrt {2}}}\n\n.\nThe Interval Newton method can also be used with thick functions such as \n\n\n\ng\n(\nx\n)\n=\n\nx\n\n2\n\n\n\u2212\n[\n2\n,\n3\n]\n\n\n{\\displaystyle g(x)=x^{2}-[2,3]}\n\n, which would in any case have interval results. The result then produces intervals containing \n\n\n\n\n[\n\u2212\n\n\n3\n\n\n,\n\u2212\n\n\n2\n\n\n]\n\n\u222a\n\n[\n\n\n2\n\n\n,\n\n\n3\n\n\n]\n\n\n\n{\\displaystyle \\left[-{\\sqrt {3}},-{\\sqrt {2}}\\right]\\cup \\left[{\\sqrt {2}},{\\sqrt {3}}\\right]}\n\n.\nThe various interval methods deliver conservative results as dependencies between the sizes of different intervals extensions are not taken into account. However the dependency problem becomes less significant for narrower intervals.\nCovering an interval vector \n\n\n\n[\n\nx\n\n]\n\n\n{\\displaystyle [\\mathbf {x} ]}\n\n by smaller boxes \n\n\n\n[\n\n\nx\n\n\n1\n\n\n]\n,\n\u2026\n,\n[\n\n\nx\n\n\nk\n\n\n]\n\n,\n\n\n\n{\\displaystyle [\\mathbf {x} _{1}],\\dots ,[\\mathbf {x} _{k}]{\\mbox{,}}}\n\n so that \n\n\n\n\n[\n\nx\n\n]\n=\n\n\u22c3\n\ni\n=\n1\n\n\nk\n\n\n[\n\n\nx\n\n\ni\n\n\n]\n\n,\n\n\n\n\n{\\displaystyle \\textstyle [\\mathbf {x} ]=\\bigcup _{i=1}^{k}[\\mathbf {x} _{i}]{\\mbox{,}}}\n\n is then valid for the range of values \n\n\n\n\nf\n(\n[\n\nx\n\n]\n)\n=\n\n\u22c3\n\ni\n=\n1\n\n\nk\n\n\nf\n(\n[\n\n\nx\n\n\ni\n\n\n]\n)\n\n.\n\n\n\n\n{\\displaystyle \\textstyle f([\\mathbf {x} ])=\\bigcup _{i=1}^{k}f([\\mathbf {x} _{i}]){\\mbox{.}}}\n\n So for the interval extensions described above, \n\n\n\n\n[\nf\n]\n(\n[\n\nx\n\n]\n)\n\u2287\n\n\u22c3\n\ni\n=\n1\n\n\nk\n\n\n[\nf\n]\n(\n[\n\n\nx\n\n\ni\n\n\n]\n)\n\n\n\n{\\displaystyle \\textstyle [f]([\\mathbf {x} ])\\supseteq \\bigcup _{i=1}^{k}[f]([\\mathbf {x} _{i}])}\n\n is valid. Since \n\n\n\n[\nf\n]\n(\n[\n\nx\n\n]\n)\n\n\n{\\displaystyle [f]([\\mathbf {x} ])}\n\n is often a genuine superset of the right-hand side, this usually leads to an improved estimate.\nSuch a cover can be generated by the bisection method such as thick elements \n\n\n\n[\n\nx\n\ni\n1\n\n\n,\n\nx\n\ni\n2\n\n\n]\n\n\n{\\displaystyle [x_{i1},x_{i2}]}\n\n of the interval vector \n\n\n\n[\n\nx\n\n]\n=\n(\n[\n\nx\n\n11\n\n\n,\n\nx\n\n12\n\n\n]\n,\n\u2026\n,\n[\n\nx\n\nn\n1\n\n\n,\n\nx\n\nn\n2\n\n\n]\n)\n\n\n{\\displaystyle [\\mathbf {x} ]=([x_{11},x_{12}],\\dots ,[x_{n1},x_{n2}])}\n\n by splitting in the centre into the two intervals \n\n\n\n[\n\nx\n\ni\n1\n\n\n,\n(\n\nx\n\ni\n1\n\n\n+\n\nx\n\ni\n2\n\n\n)\n\n/\n\n2\n]\n\n\n{\\displaystyle [x_{i1},(x_{i1}+x_{i2})/2]}\n\n and \n\n\n\n[\n(\n\nx\n\ni\n1\n\n\n+\n\nx\n\ni\n2\n\n\n)\n\n/\n\n2\n,\n\nx\n\ni\n2\n\n\n]\n\n\n{\\displaystyle [(x_{i1}+x_{i2})/2,x_{i2}]}\n\n. If the result is still not suitable then further gradual subdivision is possible. Note that a cover of \n\n\n\n\n2\n\nr\n\n\n\n\n{\\displaystyle 2^{r}}\n\n intervals results from \n\n\n\nr\n\n\n{\\displaystyle r}\n\n divisions of vector elements, substantially increasing the computation costs.\nWith very wide intervals, it can be helpful to split all intervals into several subintervals with a constant (and smaller) width, a method known as mincing. This then avoids the calculations for intermediate bisection steps. Both methods are only suitable for problems of low dimension.\nInterval arithmetic can be used in various areas (such as set inversion, motion planning, set estimation or stability analysis) to treat estimates with no exact numerical value.[7]\nInterval arithmetic is used with error analysis, to control rounding errors arising from each calculation. The advantage of interval arithmetic is that after each operation there is an interval that reliably includes the true result. The distance between the interval boundaries gives the current calculation of rounding errors directly:\nInterval analysis adds to rather than substituting for traditional methods for error reduction, such as pivoting.\nParameters for which no exact figures can be allocated often arise during the simulation of technical and physical processes. The production process of technical components allows certain tolerances, so some parameters fluctuate within intervals. In addition, many fundamental constants are not known precisely.[2]\nIf the behavior of such a system affected by tolerances satisfies, for example, \n\n\n\nf\n(\n\nx\n\n,\n\np\n\n)\n=\n0\n\n\n{\\displaystyle f(\\mathbf {x} ,\\mathbf {p} )=0}\n\n, for \n\n\n\n\np\n\n\u2208\n[\n\np\n\n]\n\n\n{\\displaystyle \\mathbf {p} \\in [\\mathbf {p} ]}\n\n and unknown \n\n\n\n\nx\n\n\n\n{\\displaystyle \\mathbf {x} }\n\n then the set of possible solutions\ncan be found by interval methods. This provides an alternative to traditional propagation of error analysis. Unlike point methods, such as Monte Carlo simulation, interval arithmetic methodology ensures that no part of the solution area can be overlooked. However, the result is always a worst case analysis for the distribution of error, as other probability-based distributions are not considered.\nInterval arithmetic can also be used with affiliation functions for fuzzy quantities as they are used in fuzzy logic. Apart from the strict statements \n\n\n\nx\n\u2208\n[\nx\n]\n\n\n{\\displaystyle x\\in [x]}\n\n and \n\n\n\nx\n\u2209\n[\nx\n]\n\n\n{\\displaystyle x\\not \\in [x]}\n\n, intermediate values are also possible, to which real numbers \n\n\n\n\u03bc\n\u2208\n[\n0\n,\n1\n]\n\n\n{\\displaystyle \\mu \\in [0,1]}\n\n are assigned. \n\n\n\n\u03bc\n=\n1\n\n\n{\\displaystyle \\mu =1}\n\n corresponds to definite membership while \n\n\n\n\u03bc\n=\n0\n\n\n{\\displaystyle \\mu =0}\n\n is non-membership. A distribution function assigns uncertainty, which can be understood as a further interval.\nFor fuzzy arithmetic[8] only a finite number of discrete affiliation stages \n\n\n\n\n\u03bc\n\ni\n\n\n\u2208\n[\n0\n,\n1\n]\n\n\n{\\displaystyle \\mu _{i}\\in [0,1]}\n\n are considered. The form of such a distribution for an indistinct value can then represented by a sequence of intervals\nThe appropriate distribution for a function \n\n\n\nf\n(\n\nx\n\n1\n\n\n,\n\u22ef\n,\n\nx\n\nn\n\n\n)\n\n\n{\\displaystyle f(x_{1},\\cdots ,x_{n})}\n\n concerning indistinct values \n\n\n\n\nx\n\n1\n\n\n,\n\u22ef\n,\n\nx\n\nn\n\n\n\n\n{\\displaystyle x_{1},\\cdots ,x_{n}}\n\n and the corresponding sequences \n\n\n\n\n[\n\nx\n\n1\n\n\n(\n1\n)\n\n\n]\n\n\u2283\n\u22ef\n\u2283\n\n[\n\nx\n\n1\n\n\n(\nk\n)\n\n\n]\n\n,\n\u22ef\n,\n\n[\n\nx\n\nn\n\n\n(\n1\n)\n\n\n]\n\n\u2283\n\u22ef\n\u2283\n\n[\n\nx\n\nn\n\n\n(\nk\n)\n\n\n]\n\n\n\n{\\displaystyle \\left[x_{1}^{(1)}\\right]\\supset \\cdots \\supset \\left[x_{1}^{(k)}\\right],\\cdots ,\\left[x_{n}^{(1)}\\right]\\supset \\cdots \\supset \\left[x_{n}^{(k)}\\right]}\n\n can be approximated by the sequence \n\n\n\n\n[\n\ny\n\n(\n1\n)\n\n\n]\n\n\u2283\n\u22ef\n\u2283\n\n[\n\ny\n\n(\nk\n)\n\n\n]\n\n\n\n{\\displaystyle \\left[y^{(1)}\\right]\\supset \\cdots \\supset \\left[y^{(k)}\\right]}\n\n. The values \n\n\n\n\n[\n\ny\n\n(\ni\n)\n\n\n]\n\n\n\n{\\displaystyle \\left[y^{(i)}\\right]}\n\n are given by \n\n\n\n\n[\n\ny\n\n(\ni\n)\n\n\n]\n\n=\nf\n\n(\n\n[\n\nx\n\n1\n\n\n(\ni\n)\n\n\n]\n\n,\n\u22ef\n\n[\n\nx\n\nn\n\n\n(\ni\n)\n\n\n]\n\n)\n\n\n\n{\\displaystyle \\left[y^{(i)}\\right]=f\\left(\\left[x_{1}^{(i)}\\right],\\cdots \\left[x_{n}^{(i)}\\right]\\right)}\n\n and can be calculated by interval methods. The value \n\n\n\n\n[\n\ny\n\n(\n1\n)\n\n\n]\n\n\n\n{\\displaystyle \\left[y^{(1)}\\right]}\n\n corresponds to the result of an interval calculation.\nInterval arithmetic is not a completely new phenomenon in mathematics; it has appeared several times under different names in the course of history. For example, Archimedes calculated lower and upper bounds 223/71 < \u03c0 < 22/7 in the 3rd century BC. Actual calculation with intervals has neither been as popular as other numerical techniques, nor been completely forgotten.\nRules for calculating with intervals and other subsets of the real numbers were published in a 1931 work by Rosalind Cicely Young, a doctoral candidate at the University of Cambridge. Arithmetic work on range numbers to improve reliability of digital systems were then published in a 1951 textbook on linear algebra by Paul Dwyer (University of Michigan); intervals were used to measure rounding errors associated with floating-point numbers. A comprehensive paper on interval algebra in numerical analysis was published by Teruo Sunaga (1958).[9]\nThe birth of modern interval arithmetic was marked by the appearance of the book Interval Analysis by Ramon E. Moore in 1966.[10][11] He had the idea in Spring 1958, and a year later he published an article about computer interval arithmetic.[12] Its merit was that starting with a simple principle, it provided a general method for automated error analysis, not just errors resulting from rounding.\nIndependently in 1956, Mieczyslaw Warmus suggested formulae for calculations with intervals,[13] though Moore found the first non-trivial applications.\nIn the following twenty years, German groups of researchers carried out pioneering work around G\u00f6tz Alefeld\u00a0(de)[14] and Ulrich Kulisch\u00a0(de)[1][15] at the University of Karlsruhe and later also at the Bergische University of Wuppertal. For example, Karl Nickel\u00a0(de) explored more effective implementations, while improved containment procedures for the solution set of systems of equations were due to Arnold Neumaier among others. In the 1960s, Eldon R. Hansen dealt with interval extensions for linear equations and then provided crucial contributions to global optimisation, including what is now known as Hansen's method, perhaps the most widely used interval algorithm.[6] Classical methods in this often have the problem of determining the largest (or smallest) global value, but could only find a local optimum and could not find better values; Helmut Ratschek and Jon George Rokne developed branch and bound methods, which until then had only applied to integer values, by using intervals to provide applications for continuous values.\nIn 1988, Rudolf Lohner developed Fortran-based software for reliable solutions for initial value problems using ordinary differential equations.[16]\nThe journal Reliable Computing (originally Interval Computations) has been published since the 1990s, dedicated to the reliability of computer-aided computations. As lead editor, R. Baker Kearfott, in addition to his work on global optimisation, has contributed significantly to the unification of notation and terminology used in interval arithmetic (Web: Kearfott).\nIn recent years work has concentrated in particular on the estimation of preimages of parameterised functions and to robust control theory by the COPRIN working group of INRIA in Sophia Antipolis in France (Web: INRIA).\nThere are many software packages that permit the development of numerical applications using interval arithmetic.[17] These are usually provided in the form of program libraries. There are also C++ and Fortran compilers that handle interval data types and suitable operations as a language extension, so interval arithmetic is supported directly.\nSince 1967, Extensions for Scientific Computation (XSC) have been developed in the University of Karlsruhe for various programming languages, such as C++, Fortran and Pascal.[18] The first platform was a Zuse Z 23, for which a new interval data type with appropriate elementary operators was made available. There followed in 1976, Pascal-SC, a Pascal variant on a Zilog Z80 that it made possible to create fast, complicated routines for automated result verification. Then came the Fortran 77-based ACRITH-XSC for the System/370 architecture (FORTRAN-SC), which was later delivered by IBM. Starting from 1991 one could produce code for C compilers with Pascal-XSC; a year later the C++ class library supported C-XSC on many different computer systems. In 1997, all XSC variants were made available under the GNU General Public License. At the beginning of 2000 C-XSC 2.0 was released under the leadership of the working group for scientific computation at the Bergische University of Wuppertal to correspond to the improved C++ standard.\nAnother C++-class library was created in 1993 at the Hamburg University of Technology called Profil/BIAS (Programmer's Runtime Optimized Fast Interval Library, Basic Interval Arithmetic), which made the usual interval operations more user friendly. It emphasized the efficient use of hardware, portability and independence of a particular presentation of intervals.\nThe Boost collection of C++ libraries contains a template class for intervals. Its authors are aiming to have interval arithmetic in the standard C++ language.[19]\nGaol[20] is another C++ interval arithmetic library that is unique in that it offers the relational interval operators used in interval constraint programming.\nThe Frink programming language has an implementation of interval arithmetic that handles arbitrary-precision numbers. Programs written in Frink can use intervals without rewriting or recompilation.\nIn addition computer algebra systems, such as Mathematica, Maple and MuPAD, can handle intervals. A Matlab extension Intlab builds on BLAS routines, and the Toolbox b4m makes a Profil/BIAS interface.[21] Moreover, the Software Euler Math Toolbox includes an interval arithmetic.\nA library for the functional language OCaml was written in assembly language and C.[22]\nA standard for interval arithmetic has been approved in June 2015.[23] Two reference implementations are freely available.[24] These have been developed by members of the standard's working group: The libieeep1788[25] library for C++, and the interval package[26] for GNU Octave.\nA minimal subset of the standard is currently under development that should be easier to implement and may speed production of implementations.[27]\nSeveral international conferences or workshop take place every year in the world. The main conference is probably SCAN (International Symposium on Scientific Computing, Computer Arithmetic, and Verified Numerical Computation), but there is also SWIM (Small Workshop on Interval Methods), PPAM (International Conference on Parallel Processing and Applied Mathematics), REC (International Workshop on Reliable Engineering Computing).", 
    "dbpedia_url": "http://dbpedia.org/resource/Interval_arithmetic", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Interval_arithmetic\n"
}
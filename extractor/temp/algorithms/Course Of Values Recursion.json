{
    "about": "In computability theory, course-of-values recursion is a technique for defining number-theoretic functions by recursion. In a definition of a function f by course-of-values recursion, the value of f(n+1) is computed from the sequence \n\n\n\n\u27e8\nf\n(\n1\n)\n,\nf\n(\n2\n)\n,\n\u2026\n,\nf\n(\nn\n)\n\u27e9\n\n\n{\\displaystyle \\langle f(1),f(2),\\ldots ,f(n)\\rangle }\n\n.", 
    "classification": "Recursion", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Course-of-values_recursion\n", 
    "full_text": "In computability theory, course-of-values recursion is a technique for defining number-theoretic functions by recursion. In a definition of a function f by course-of-values recursion, the value of f(n+1) is computed from the sequence \n\n\n\n\u27e8\nf\n(\n1\n)\n,\nf\n(\n2\n)\n,\n\u2026\n,\nf\n(\nn\n)\n\u27e9\n\n\n{\\displaystyle \\langle f(1),f(2),\\ldots ,f(n)\\rangle }\n\n.\nThe fact that such definitions can be converted into definitions using a simpler form of recursion is often used to prove that functions defined by course-of-values recursion are primitive recursive. Contrary to course-of-values recursion, in primitive recursion the computation of a value of a function requires only the previous value; for example, for a 1-ary primitive recursive function g the value of g(n+1) is computed only from g(n) and n.\n\n\nThe factorial function n! is recursively defined by the rules\nThis recursion is a primitive recursion because it computes the next value (n+1)! of the function based on the value of n and the previous value n! of the function. On the other hand, the function Fib(n), which returns the nth Fibonacci number, is defined with the recursion equations\nIn order to compute Fib(n+2), the last two values of the Fib function are required. Finally, consider the function g defined with the recursion equations\nTo compute g(n+1) using these equations, all the previous values of g must be computed; no fixed finite number of previous values is sufficient in general for the computation of g. The functions Fib and g are examples of functions defined by course-of-values recursion.\nIn general, a function f is defined by course-of-values recursion if there is a fixed primitive recursive function h such that for all n,\nwhere \n\n\n\n\u27e8\nf\n(\n0\n)\n,\nf\n(\n1\n)\n,\n\u2026\n,\nf\n(\nn\n\u2212\n1\n)\n\u27e9\n\n\n{\\displaystyle \\langle f(0),f(1),\\ldots ,f(n-1)\\rangle }\n\n is a G\u00f6del number encoding the indicated sequence. In particular\nprovides the initial value of the recursion. The function h might test its first argument to provide explicit initial values, for instance for Fib one could use the function defined by\nwhere s[i] denotes extraction of the element i from an encoded sequence s; this is easily seen to be a primitive recursive function (assuming an appropriate G\u00f6del numbering is used).\nIn order to convert a definition by course-of-values recursion into a primitive recursion, an auxiliary (helper) function is used. Suppose that one wants to have\nTo define f using primitive recursion, first define the auxiliary course-of-values function that should satisfy\nwhere the right hand side is taken to be a G\u00f6del numbering for sequences.\nThus \n\n\n\n\n\n\nf\n\u00af\n\n\n\n(\nn\n)\n\n\n{\\displaystyle {\\bar {f}}(n)}\n\n encodes the first n values of f. The function \n\n\n\n\n\n\nf\n\u00af\n\n\n\n\n\n{\\displaystyle {\\bar {f}}}\n\n can be defined by primitive recursion because \n\n\n\n\n\n\nf\n\u00af\n\n\n\n(\nn\n+\n1\n)\n\n\n{\\displaystyle {\\bar {f}}(n+1)}\n\n is obtained by appending to \n\n\n\n\n\n\nf\n\u00af\n\n\n\n(\nn\n)\n\n\n{\\displaystyle {\\bar {f}}(n)}\n\n the new element \n\n\n\nh\n(\nn\n,\n\n\n\nf\n\u00af\n\n\n\n(\nn\n)\n)\n\n\n{\\displaystyle h(n,{\\bar {f}}(n))}\n\n:\nwhere append(n,s,x) computes, whenever s encodes a sequence of length n, a new sequence t of length n + 1 such that t[n] = x and t[i] = s[i] for all i < n. This is a primitive recursive function, under the assumption of an appropriate G\u00f6del numbering; h is assumed primitive recursive to begin with. Thus the recursion relation can be written as primitive recursion:\nwhere g is itself primitive recursive, being the composition of two such functions:\nGiven \n\n\n\n\n\n\nf\n\u00af\n\n\n\n\n\n{\\displaystyle {\\bar {f}}}\n\n, the original function f can be defined by \n\n\n\nf\n(\nn\n)\n=\n\n\n\nf\n\u00af\n\n\n\n(\nn\n+\n1\n)\n[\nn\n]\n\n\n{\\displaystyle f(n)={\\bar {f}}(n+1)[n]}\n\n, which shows that it is also a primitive recursive function.\nIn the context of primitive recursive functions, it is convenient to have a means to represent finite sequences of natural numbers as single natural numbers. One such method, G\u00f6del's encoding, represents a sequence of positive integers \n\n\n\n\u27e8\n\nn\n\n0\n\n\n,\n\nn\n\n1\n\n\n,\n\nn\n\n2\n\n\n,\n\u2026\n,\n\nn\n\nk\n\n\n\u27e9\n\n\n{\\displaystyle \\langle n_{0},n_{1},n_{2},\\ldots ,n_{k}\\rangle }\n\n as\nwhere pi represent the ith prime. It can be shown that, with this representation, the ordinary operations on sequences are all primitive recursive. These operations include\nUsing this representation of sequences, it can be seen that if h(m) is primitive recursive then the function\nis also primitive recursive.\nWhen the sequence \n\n\n\n\u27e8\n\nn\n\n0\n\n\n,\n\nn\n\n1\n\n\n,\n\nn\n\n2\n\n\n,\n\u2026\n,\n\nn\n\nk\n\n\n\u27e9\n\n\n{\\displaystyle \\langle n_{0},n_{1},n_{2},\\ldots ,n_{k}\\rangle }\n\n is allowed to include zeros, it is instead represented as\nwhich makes it possible to distinguish the codes for the sequences \n\n\n\n\u27e8\n0\n\u27e9\n\n\n{\\displaystyle \\langle 0\\rangle }\n\n and \n\n\n\n\u27e8\n0\n,\n0\n\u27e9\n\n\n{\\displaystyle \\langle 0,0\\rangle }\n\n.\nNot every recursive definition can be transformed into a primitive recursive definition. One known example is Ackermann's function, which is of the form A(m,n) and is provably not primitive resursive.\nIndeed, every new value A(m+1, n) depends on the sequence of previously defined values A(i, j), but the i-s and j-s for which values should be included in this sequence depend themselves on previously computed values of the function; namely (i, j) = (m,A(m+1,n)). Thus one cannot encode the previously computed sequence of values in a primitive recursive way in the manner suggested above (or at all, as it turns out this function is not primitive recursive).", 
    "name": "Course Of Values Recursion"
}
{
    "about": "In symbolic computation (or computer algebra), at the intersection of mathematics and computer science, the Risch algorithm is an algorithm for indefinite integration. It is used in some computer algebra systems to find antiderivatives. It is named after the American mathematician Robert Henry Risch, a specialist in computer algebra who developed it in 1968.", 
    "name": "Risch Algorithm", 
    "classification": "Computer Algebra", 
    "full_text": "In symbolic computation (or computer algebra), at the intersection of mathematics and computer science, the Risch algorithm is an algorithm for indefinite integration. It is used in some computer algebra systems to find antiderivatives. It is named after the American mathematician Robert Henry Risch, a specialist in computer algebra who developed it in 1968.\nThe algorithm transforms the problem of integration into a problem in algebra. It is based on the form of the function being integrated and on methods for integrating rational functions, radicals, logarithms, and exponential functions. Risch called it a decision procedure, because it is a method for deciding whether a function has an elementary function as an indefinite integral, and if it does, for determining that indefinite integral.\nThe complete description of the Risch algorithm takes over 100 pages.[1] The Risch\u2013Norman algorithm is a simpler, faster, but less powerful variant that was developed in 1976 by A. C. Norman.\n\n\nThe Risch algorithm is used to integrate elementary functions. These are functions obtained by composing exponentials, logarithms, radicals, trigonometric functions, and the four arithmetic operations (+ \u2212 \u00d7 \u00f7). Laplace solved this problem for the case of rational functions, as he showed that the indefinite integral of a rational function is a rational function and a finite number of constant multiples of logarithms of rational functions. The algorithm suggested by Laplace is usually described in calculus textbooks; as a computer program, it was finally implemented in the 1960s.\nLiouville formulated the problem that is solved by the Risch algorithm. Liouville proved by analytical means that if there is an elementary solution g to the equation g\u2032 = f then there exist constants \u03b1i and functions ui and v in the field generated by f such that the solution is of the form\nRisch developed a method that allows one to consider only a finite set of functions of Liouville's form.\nThe intuition for the Risch algorithm comes from the behavior of the exponential and logarithm functions under differentiation. For the function f eg, where f and g are differentiable functions, we have\nso if eg were in the result of an indefinite integration, it should be expected to be inside the integral. Also, as\nthen if (ln g)n were in the result of an integration, then only a few powers of the logarithm should be expected.\nFinding an elementary antiderivative is very sensitive to details. For instance, the following algebraic function has an elementary antiderivative:[2]\nnamely:\nBut if the coefficient 71 is changed to 72, it is not possible to represent the antiderivative in terms of elementary functions. Some computer algebra systems may here return an antiderivative in terms of non-elementary functions (i.e. elliptic integrals), which however are outside the scope of the Risch algorithm.\nThe following is a more complex example that involves both algebraic and transcendental functions:[3]\nIn fact, the antiderivative of this function has a fairly short form:\nTransforming Risch's theoretical algorithm into an algorithm that can be effectively executed by a computer was a complex task which took a long time.\nThe case of the purely transcendental functions (which do not involve roots of polynomials) is relatively easy and was implemented early in most computer algebra systems. The first implementation was done by Joel Moses in Macsyma soon after the publication of Risch's paper.[4]\nThe case of purely algebraic functions was solved and implemented in Reduce by James H. Davenport.[5]\nThe general case was solved and implemented in Scratchpad, a precursor of Axiom, by Manuel Bronstein.[6]\nThe Risch algorithm applied to general elementary functions is not an algorithm but a semi-algorithm because it needs to check, as a part of its operation, if certain expressions are equivalent to zero (constant problem), in particular in the constant field. For expressions that involve only functions commonly taken to be elementary it is not known whether an algorithm performing such a check exists or not (current computer algebra systems use heuristics); moreover, if one adds the absolute value function to the list of elementary functions, it is known that no such algorithm exists; see Richardson's theorem.\nNote that this issue also arises in the polynomial division algorithm; this algorithm will fail if it cannot correctly determine whether coefficients vanish identically.[7] Virtually every non-trivial algorithm relating to polynomials uses the polynomial division algorithm, the Risch algorithm included. If the constant field is computable, i.e., for elements not dependent on x, the problem of zero-equivalence is decidable, then the Risch algorithm is a complete algorithm. Examples of computable constant fields are \n\n\n\n\nQ\n\n\n\n{\\displaystyle \\mathbb {Q} }\n\n and \n\n\n\n\nQ\n\n(\ny\n)\n\n\n{\\displaystyle \\mathbb {Q} (y)}\n\n, i.e., rational numbers and rational functions in y with rational number coefficients, respectively, where y is an indeterminate that does not depend on x.\nThis is also an issue in the Gaussian elimination matrix algorithm (or any algorithm that can compute the nullspace of a matrix), which is also necessary for many parts of the Risch algorithm. Gaussian elimination will produce incorrect results if it cannot correctly determine if a pivot is identically zero[citation needed].", 
    "dbpedia_url": "http://dbpedia.org/resource/Risch_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Risch_algorithm\n"
}
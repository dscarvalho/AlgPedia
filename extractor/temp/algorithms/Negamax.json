{
    "about": "Negamax search is a variant form of minimax search that relies on the zero-sum property of a two-player game.", 
    "name": "Negamax", 
    "classification": "Optimization Algorithms And Methods", 
    "full_text": "Negamax search is a variant form of minimax search that relies on the zero-sum property of a two-player game.\nThis algorithm relies on the fact that max(a, b) = \u2212min(\u2212a, \u2212b) to simplify the implementation of the minimax algorithm. More precisely, the value of a position to player A in such a game is the negation of the value to player B. Thus, the player on move looks for a move that maximizes the negation of the value resulting from the move: this successor position must by definition have been valued by the opponent. The reasoning of the previous sentence works regardless of whether A or B is on move. This means that a single procedure can be used to value both positions. This is a coding simplification over minimax, which requires that A selects the move with the maximum-valued successor while B selects the move with the minimum-valued successor.\nIt should not be confused with negascout, an algorithm to compute the minimax or negamax value quickly by clever use of alpha-beta pruning discovered in the 1980s. Note that alpha-beta pruning is itself a way to compute the minimax or negamax value of a position quickly by avoiding the search of certain uninteresting positions.\nMost adversarial search engines are coded using some form of negamax search.\n\n\nNegaMax operates on the same game trees as those used with the minimax search algorithm. Each node and root node in the tree are game states (such as game board configuration) of a two player game. Transitions to child nodes represent moves available to a player who's about to play from a given node.\nThe negamax search objective is to find the node score value for the player who is playing at the root node. The pseudocode below shows the negamax base algorithm,[1] with a configurable limit for the maximum search depth:\nThe root node inherits its score from one of its immediate child nodes. The child node that ultimately sets the root node's best score also represents the best move to play. Although the negamax function shown only returns the node's best score as bestValue, practical negamax implementations may also retain and return both best move and best score for the root node. Assuming basic negamax, only the node's best score is essential with non-root nodes. And the node's best move isn't necessary to retain nor return for those nodes.\nWhat can be confusing is how the heuristic value of the current node is calculated. In this implementation, this value is always calculated from the point of view of player A, whose color value is one. In other words, higher heuristic values always represent situations more favorable for player A. This is the same behavior as the normal minimax algorithm. The heuristic value is not necessarily the same as a node's return value, bestValue, due to value negation by negamax and the color parameter. The negamax node's return value is a heuristic score from the point of view of the node's current player.\nNegamax scores match minimax scores for nodes where player A is about to play, and where player A is the maximizing player in the minimax equivalent. Negamax always searches for the maximum value for all its nodes. Hence for player B nodes, the minimax score is a negation of its negamax score. Player B is the minimizing player in the minimax equivalent.\nVariations in negamax implementations may omit the color parameter. In this case, the heuristic evaluation function must return values from the point of view of the node's current player.\nAlgorithm optimizations for minimax are also equally applicable for Negamax. Alpha-beta pruning can decrease the number of nodes the negamax algorithm evaluates in a search tree in a manner similar with its use with the minimax algorithm.\nThe pseudocode for depth-limited negamax search with alpha-beta pruning follows:[1]\nAlpha (\u03b1) and beta (\u03b2) represent lower and upper bounds for child node values at a given tree depth. Negamax sets the arguments \u03b1 and \u03b2 for the root node to the lowest and highest values possible. Other search algorithms, such as negascout and MTD-f, may initialize \u03b1 and \u03b2 with alternate values to further improve tree search performance.\nWhen negamax encounters a child node value outside an alpha/beta range, the negamax search cuts off (pseudocode line 12 break statement) thereby pruning portions of the game tree from exploration. Cut offs are implicit based on the node return value, bestValue. A node value found within the range of its initial \u03b1 and \u03b2 is the node's exact (or true) value. This value is identical to the result the negamax base algorithm would return, without cut offs and without any \u03b1 and \u03b2 bounds. If a node return value is out of range, then the value represents an upper (if value \u2264 \u03b1) or lower (if value \u2265 \u03b2) bound for the node's exact value. Alpha-beta pruning eventually discards any value bound results. Such values do not contribute nor affect the negamax value at its root node.\nThis pseudocode shows the fail-soft variation of alpha-beta pruning. Fail-soft never returns \u03b1 or \u03b2 directly as a node value. Thus, a node value may be outside the initial \u03b1 and \u03b2 range bounds set with a negamax function call. In contrast, fail-hard alpha-beta pruning always limits a node value in the range of \u03b1 and \u03b2.\nThis implementation also shows optional move ordering prior to the foreach loop that evaluates child nodes. Move ordering[2] is an optimization for alpha beta pruning that attempts to guess the most probable child nodes that yield the node's score. The algorithm searches those child nodes first. The result of good guesses is earlier and more frequent alpha/beta cut offs occur, thereby pruning additional game tree branches and remaining child nodes from the search tree.\nTransposition tables selectively memorizes the values of nodes in the game tree. Transposition is a term reference that a given game board position can be reached in more than one way with differing game move sequences.\nWhen negamax searches the game tree, and encounters the same node multiple times, a transposition table can return a previously computed value of the node, skipping potentially lengthy and duplicate re-computation of the node's value. Negamax performance improves particularly for game trees with many paths that lead to a given node in common.\nThe pseudo code that adds transposition table functions to negamax with alpha/beta pruning is given as follows:[1]\nAlpha/beta pruning and maximum search depth constraints in negamax can result in partial, inexact, and entirely skipped evaluation of nodes in a game tree. This complicates adding transposition table optimizations for negamax. It's insufficient to track only the node's bestValue in the table, because bestValue may not be the node's true value. The code therefore must preserve and restore the relationship of bestValue with alpha/beta parameters and the search depth for each transposition table entry.\nTransposition tables are typically lossy and will omit or overwrite previous values of certain game tree nodes in its tables. This is necessary since the number of nodes negamax visits often far exceeds the transposition table size. Lost or omitted table entries are non critical and won't affect the negamax result. However, lost entries may require negamax to re-compute certain game tree node values more frequently, thus affecting performance.", 
    "dbpedia_url": "http://dbpedia.org/resource/Negamax", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Negamax\n"
}
{
    "about": "The Multidelay block frequency domain adaptive filter (MDF) algorithm is a block-based frequency domain implementation of the (normalised) Least mean squares filter (LMS) algorithm.", 
    "name": "Multidelay Block Frequency Domain Adaptive Filter", 
    "classification": "Digital Signal Processing", 
    "full_text": "The Multidelay block frequency domain adaptive filter (MDF) algorithm is a block-based frequency domain implementation of the (normalised) Least mean squares filter (LMS) algorithm.\n\n\nThe MDF algorithm is based on the fact that convolutions may be efficiently computed in the frequency domain (thanks to the Fast Fourier Transform). However, the algorithm differs from the Fast LMS algorithm in that block size it uses may be smaller than the filter length. If both are equal, then MDF reduces to the FLMS algorithm.\nThe advantages of MDF over the (N)LMS algorithm are:\n\nLet \n\n\n\nN\n\n\n{\\displaystyle N}\n\n be the length of the processing blocks, \n\n\n\nK\n\n\n{\\displaystyle K}\n\n be the number of blocks and \n\n\n\n\nF\n\n\n\n{\\displaystyle \\mathbf {F} }\n\n denote the 2Nx2N Fourier transform matrix. The variables are defined as:\nWith normalisation matrices \n\n\n\n\n\nG\n\n\n1\n\n\n\n\n{\\displaystyle \\mathbf {G} _{1}}\n\n and \n\n\n\n\n\nG\n\n\n2\n\n\n\n\n{\\displaystyle \\mathbf {G} _{2}}\n\n:\nIn practice, when multiplying a column vector \n\n\n\n\nx\n\n\n\n{\\displaystyle \\mathbf {x} }\n\n by \n\n\n\n\n\nG\n\n\n1\n\n\n\n\n{\\displaystyle \\mathbf {G} _{1}}\n\n, we take the inverse FFT of \n\n\n\n\nx\n\n\n\n{\\displaystyle \\mathbf {x} }\n\n, set the first \n\n\n\nN\n\n\n{\\displaystyle N}\n\n values in the result to zero and then take the FFT. This is meant to remove the effects of the circular convolution.\nFor each block, the MDF algorithm is computed as:\nIt is worth noting that, while the algorithm is more easily expressed in matrix form, the actual implementation requires no matrix multiplications. For instance the normalisation matrix computation \n\n\n\n\n\n\u03a6\n\n\n\nx\nx\n\n\n\n=\n\n\n\n\nX\n\n_\n\n\n\nH\n\n\n(\n\u2113\n)\n\n\n\nX\n\n_\n\n\n(\n\u2113\n)\n\n\n{\\displaystyle \\mathbf {\\Phi } _{\\mathbf {xx} }={\\underline {\\mathbf {X} }}^{H}(\\ell ){\\underline {\\mathbf {X} }}(\\ell )}\n\n reduces to an element-wise vector multiplication because \n\n\n\n\n\n\nX\n\n_\n\n\n(\n\u2113\n)\n\n\n{\\displaystyle {\\underline {\\mathbf {X} }}(\\ell )}\n\n is block-diagonal. The same goes for other multiplications.", 
    "dbpedia_url": "http://dbpedia.org/resource/Multidelay_block_frequency_domain_adaptive_filter", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Multidelay_block_frequency_domain_adaptive_filter\n"
}
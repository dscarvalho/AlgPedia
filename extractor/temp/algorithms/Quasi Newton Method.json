{
    "about": "Quasi-Newton methods are methods used to either find zeroes or local maxima and minima of functions, as an alternative to Newton's method. They can be used if the Jacobian or Hessian is unavailable or is too expensive to compute at every iteration. The \"full\" Newton's method requires the Jacobian in order to search for zeros, or the Hessian for finding extrema.", 
    "classification": "Optimization Algorithms And Methods", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Quasi-Newton_method\n", 
    "full_text": "Quasi-Newton methods are methods used to either find zeroes or local maxima and minima of functions, as an alternative to Newton's method. They can be used if the Jacobian or Hessian is unavailable or is too expensive to compute at every iteration. The \"full\" Newton's method requires the Jacobian in order to search for zeros, or the Hessian for finding extrema.\n\n\nNewton's method to find zeroes of a function \n\n\n\ng\n\n\n{\\displaystyle g}\n\n of multiple variables is given by: \n\n\n\n\nx\n\nn\n+\n1\n\n\n=\n\nx\n\nn\n\n\n\u2212\n[\n\nJ\n\ng\n\n\n(\n\nx\n\nn\n\n\n)\n\n]\n\n\u2212\n1\n\n\ng\n(\n\nx\n\nn\n\n\n)\n\n\n\n\n{\\displaystyle x_{n+1}=x_{n}-[J_{g}(x_{n})]^{-1}g(x_{n})\\,\\!}\n\n where \n\n\n\n[\n\nJ\n\ng\n\n\n(\n\nx\n\nn\n\n\n)\n\n]\n\n\u2212\n1\n\n\n\n\n{\\displaystyle [J_{g}(x_{n})]^{-1}}\n\n is the left inverse of the Jacobian matrix \n\n\n\n\nJ\n\ng\n\n\n(\n\nx\n\nn\n\n\n)\n\n\n{\\displaystyle J_{g}(x_{n})}\n\n of \n\n\n\ng\n\n\n{\\displaystyle g}\n\n evaluated for \n\n\n\n\nx\n\nn\n\n\n\n\n{\\displaystyle x_{n}}\n\n.\nStrictly speaking, any method that replaces the exact Jacobian \n\n\n\n\nJ\n\ng\n\n\n(\n\nx\n\nn\n\n\n)\n\n\n{\\displaystyle J_{g}(x_{n})}\n\n with an approximation is a quasi-Newton method. The chord method (where \n\n\n\n\nJ\n\ng\n\n\n(\n\nx\n\nn\n\n\n)\n\n\n{\\displaystyle J_{g}(x_{n})}\n\n is replaced by \n\n\n\n\nJ\n\ng\n\n\n(\n\nx\n\no\n\n\n)\n\n\n{\\displaystyle J_{g}(x_{o})}\n\n for all iterations) for instance is a simple example. The methods given below for optimization refer to an important subclass of quasi-Newton methods, secant methods. [1]\nUsing methods developed to find extrema in order to find zeroes is not always a good idea as the majority of the methods used to find extrema require that the matrix that is used is symmetrical. While this holds in the context of the search for extrema, it rarely holds when searching for zeroes. Broyden's \"good\" method and Broyden's \"bad\" method are two methods commonly used to find extrema that can also be applied to find zeroes. Other methods that can be used are the Column Updating Method, the Inverse Column Updating Method, the Quasi-Newton Least Squares Method and the Quasi-Newton Inverse Least Squares Method.\nMore recently quasi-Newton methods have been applied to find the solution of multiple coupled systems of equations (e.g. fluid-structure interaction problems or interaction problems in physics). They allow the solution to be found by solving each constituent system separately (which is simpler than the global system) in a cyclic, iterative fashion until the solution of the global system is found.[1][2]\nNoting that the search for a minimum or maximum of a single-valued function is nothing else than the search for the zeroes of the gradient of that function, quasi-Newton methods can be readily applied to find extrema of a function. In other words, if \n\n\n\ng\n\n\n{\\displaystyle g}\n\n is the gradient of \n\n\n\nf\n\n\n{\\displaystyle f}\n\n then searching for the zeroes of the multi-valued function \n\n\n\ng\n\n\n{\\displaystyle g}\n\n corresponds to the search for the extrema of the single-valued function \n\n\n\nf\n\n\n{\\displaystyle f}\n\n; the Jacobian of \n\n\n\ng\n\n\n{\\displaystyle g}\n\n now becomes the Hessian of \n\n\n\nf\n\n\n{\\displaystyle f}\n\n. The main difference is that the Hessian matrix is a symmetric matrix, unlike the Jacobian when searching for zeroes. Most quasi-Newton methods used in optimisation exploit this property.\nIn optimization, quasi-Newton methods (a special case of variable metric methods) are algorithms for finding local maxima and minima of functions. Quasi-Newton methods are based on Newton's method to find the stationary point of a function, where the gradient is 0. Newton's method assumes that the function can be locally approximated as a quadratic in the region around the optimum, and uses the first and second derivatives to find the stationary point. In higher dimensions, Newton's method uses the gradient and the Hessian matrix of second derivatives of the function to be minimized.\nIn quasi-Newton methods the Hessian matrix does not need to be computed. The Hessian is updated by analyzing successive gradient vectors instead. Quasi-Newton methods are a generalization of the secant method to find the root of the first derivative for multidimensional problems. In multiple dimensions the secant equation is under-determined, and quasi-Newton methods differ in how they constrain the solution, typically by adding a simple low-rank update to the current estimate of the Hessian.\nThe first quasi-Newton algorithm was proposed by William C. Davidon, a physicist working at Argonne National Laboratory. He developed the first quasi-Newton algorithm in 1959: the DFP updating formula, which was later popularized by Fletcher and Powell in 1963, but is rarely used today. The most common quasi-Newton algorithms are currently the SR1 formula (for symmetric rank one), the BHHH method, the widespread BFGS method (suggested independently by Broyden, Fletcher, Goldfarb, and Shanno, in 1970), and its low-memory extension, L-BFGS. The Broyden's class is a linear combination of the DFP and BFGS methods.\nThe SR1 formula does not guarantee the update matrix to maintain positive-definiteness and can be used for indefinite problems. The Broyden's method does not require the update matrix to be symmetric and it is used to find the root of a general system of equations (rather than the gradient) by updating the Jacobian (rather than the Hessian).\nOne of the chief advantages of quasi-Newton methods over Newton's method is that the Hessian matrix (or, in the case of quasi-Newton methods, its approximation) \n\n\n\nB\n\n\n{\\displaystyle B}\n\n does not need to be inverted. Newton's method, and its derivatives such as interior point methods, require the Hessian to be inverted, which is typically implemented by solving a system of linear equations and is often quite costly. In contrast, quasi-Newton methods usually generate an estimate of \n\n\n\n\nB\n\n\u2212\n1\n\n\n\n\n{\\displaystyle B^{-1}}\n\n directly.\nAs in Newton's method, one uses a second order approximation to find the minimum of a function \n\n\n\nf\n(\nx\n)\n\n\n{\\displaystyle f(x)}\n\n. The Taylor series of \n\n\n\nf\n(\nx\n)\n\n\n{\\displaystyle f(x)}\n\n around an iterate is:\nwhere (\n\n\n\n\u2207\nf\n\n\n{\\displaystyle \\nabla f}\n\n) is the gradient and \n\n\n\nB\n\n\n{\\displaystyle B}\n\n an approximation to the Hessian matrix. The gradient of this approximation (with respect to \n\n\n\n\u0394\nx\n\n\n{\\displaystyle \\Delta x}\n\n) is\nand setting this gradient to zero (which is the objective of optimisation) provides the Newton step:\nThe Hessian approximation \n\n\n\nB\n\n\n{\\displaystyle B}\n\n is chosen to satisfy\nwhich is called the secant equation (the Taylor series of the gradient itself). In more than one dimension \n\n\n\nB\n\n\n{\\displaystyle B}\n\n is underdetermined. In one dimension, solving for \n\n\n\nB\n\n\n{\\displaystyle B}\n\n and applying the Newton's step with the updated value is equivalent to the secant method. The various quasi-Newton methods differ in their choice of the solution to the secant equation (in one dimension, all the variants are equivalent). Most methods (but with exceptions, such as Broyden's method) seek a symmetric solution (\n\n\n\n\nB\n\nT\n\n\n=\nB\n\n\n{\\displaystyle B^{T}=B}\n\n); furthermore, the variants listed below can be motivated by finding an update \n\n\n\n\nB\n\nk\n+\n1\n\n\n\n\n{\\displaystyle B_{k+1}}\n\n that is as close as possible to \n\n\n\n\nB\n\nk\n\n\n\n\n{\\displaystyle B_{k}}\n\n in some norm; that is, \n\n\n\n\nB\n\nk\n+\n1\n\n\n=\n\n\n\nargmin\n\n\n\nB\n\n\n\u2225\nB\n\u2212\n\nB\n\nk\n\n\n\n\u2225\n\nV\n\n\n\n\n{\\displaystyle B_{k+1}={\\textrm {argmin}}_{B}\\|B-B_{k}\\|_{V}}\n\n where \n\n\n\nV\n\n\n{\\displaystyle V}\n\n is some positive definite matrix that defines the norm. An approximate initial value of \n\n\n\n\nB\n\n0\n\n\n=\nI\n\u2217\nx\n\n\n{\\displaystyle B_{0}=I*x}\n\n is often sufficient to achieve rapid convergence. Note that \n\n\n\n\nB\n\n0\n\n\n\n\n{\\displaystyle B_{0}}\n\n should be positive definite. The unknown \n\n\n\n\nx\n\nk\n\n\n\n\n{\\displaystyle x_{k}}\n\n is updated applying the Newton's step calculated using the current approximate Hessian matrix \n\n\n\n\nB\n\nk\n\n\n\n\n{\\displaystyle B_{k}}\n\n\nis used to update the approximate Hessian \n\n\n\n\n\nB\n\nk\n+\n1\n\n\n\n\n\n{\\displaystyle \\displaystyle B_{k+1}}\n\n, or directly its inverse \n\n\n\n\n\nH\n\nk\n+\n1\n\n\n=\n\nB\n\nk\n+\n1\n\n\n\u2212\n1\n\n\n\n\n\n{\\displaystyle \\displaystyle H_{k+1}=B_{k+1}^{-1}}\n\n using the Sherman-Morrison formula.\nThe most popular update formulas are:\nOther methods are Pearson's method, McCormick's Method, the Powell symmetric Broyden (PSB) method and Greenstadt's method.[1]\nWhen \n\n\n\nf\n\n\n{\\displaystyle f}\n\n is a convex quadratic function with positive definite Hessian \n\n\n\nB\n\n\n{\\displaystyle B}\n\n, one would expect the matrices \n\n\n\n\nH\n\nk\n\n\n\n\n{\\displaystyle H_{k}}\n\n generated by a Quasi-Newton method to converge to the inverse Hessian \n\n\n\nH\n=\n\nB\n\n\u2212\n1\n\n\n\n\n{\\displaystyle H=B^{-1}}\n\n. This is indeed the case for the class of Quasi-Newton methods based on least-change updates. [3]\nOwing to their success, there are implementations of quasi-Newton methods in almost all programming languages. The NAG Library contains several routines[4] for minimizing or maximizing a function[5] which use quasi-Newton algorithms.\nScipy.optimize has fmin_bfgs. In the SciPy extension to Python, the scipy.optimize.minimize function includes, among other methods, a BFGS implementation.\nGNU Octave uses a form of BFGS in its 'fsolve' function, with trust region extensions.\nIn MATLAB's Optimization Toolbox, the fminunc function uses (among other methods) the BFGS Quasi-Newton method. Many of the constrained methods of the Optimization toolbox use BFGS and the variant L-BFGS. Many user-contributed quasi-Newton routines are available on MATLAB's file exchange.\nMathematica includes quasi-Newton solvers.\nR's optim general-purpose optimizer routine uses the BFGS method by using method=\"BFGS\"[1].", 
    "name": "Quasi Newton Method"
}
{
    "about": "In coding theory, the BCH codes form a class of cyclic error-correcting codes that are constructed using finite fields. BCH codes were invented in 1959 by French mathematician Alexis Hocquenghem, and independently in 1960 by Raj Bose and D. K. Ray-Chaudhuri.[1][2][3] The acronym BCH comprises the initials of these inventors' surnames (mistakenly, in the case of Ray-Chaudhuri).", 
    "name": "Bch Code", 
    "classification": "Error Detection And Correction", 
    "full_text": "In coding theory, the BCH codes form a class of cyclic error-correcting codes that are constructed using finite fields. BCH codes were invented in 1959 by French mathematician Alexis Hocquenghem, and independently in 1960 by Raj Bose and D. K. Ray-Chaudhuri.[1][2][3] The acronym BCH comprises the initials of these inventors' surnames (mistakenly, in the case of Ray-Chaudhuri).\nOne of the key features of BCH codes is that during code design, there is a precise control over the number of symbol errors correctable by the code. In particular, it is possible to design binary BCH codes that can correct multiple bit errors. Another advantage of BCH codes is the ease with which they can be decoded, namely, via an algebraic method known as syndrome decoding. This simplifies the design of the decoder for these codes, using small low-power electronic hardware.\nBCH codes are used in applications such as satellite communications,[4] compact disc players, DVDs, disk drives, solid-state drives[5] and two-dimensional bar codes.\n\n\nGiven a prime power q and positive integers m and d with d \u2264 qm \u2212 1, a primitive narrow-sense BCH code over the finite field GF(q) with code length n = qm \u2212 1 and distance at least d is constructed by the following method.\nLet \u03b1 be a primitive element of GF(qm). For any positive integer i, let mi(x) be the minimal polynomial of \u03b1i over GF(q). The generator polynomial of the BCH code is defined as the least common multiple g(x) = lcm(m1(x),\u2026,md \u2212 1(x)). It can be seen that g(x) is a polynomial with coefficients in GF(q) and divides xn \u2212 1. Therefore, the polynomial code defined by g(x) is a cyclic code.\nLet q=2 and m=4 (therefore n=15). We will consider different values of d. There is a primitive root \u03b1 in GF(16) satisfying\n\n\n\n\n\n\u03b1\n\n4\n\n\n+\n\u03b1\n+\n1\n=\n0\n\n\n{\\displaystyle \\alpha ^{4}+\\alpha +1=0}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(1)\nits minimal polynomial over GF(2) is\nThe minimal polynomials of the first fourteen powers of \u03b1 are\nThe BCH code with \n\n\n\nd\n=\n2\n,\n3\n\n\n{\\displaystyle d=2,3}\n\n has generator polynomial\n\n\n\n\ng\n(\nx\n)\n=\n\nm\n\n1\n\n\n(\nx\n)\n=\n\nx\n\n4\n\n\n+\nx\n+\n1.\n\n\n\n{\\displaystyle g(x)=m_{1}(x)=x^{4}+x+1.\\,}\n\n\nIt has minimal Hamming distance at least 3 and corrects up to one error. Since the generator polynomial is of degree 4, this code has 11 data bits and 4 checksum bits.\nThe BCH code with \n\n\n\nd\n=\n4\n,\n5\n\n\n{\\displaystyle d=4,5}\n\n has generator polynomial\n\n\n\n\ng\n(\nx\n)\n=\n\n\nl\nc\nm\n\n\n(\n\nm\n\n1\n\n\n(\nx\n)\n,\n\nm\n\n3\n\n\n(\nx\n)\n)\n=\n(\n\nx\n\n4\n\n\n+\nx\n+\n1\n)\n(\n\nx\n\n4\n\n\n+\n\nx\n\n3\n\n\n+\n\nx\n\n2\n\n\n+\nx\n+\n1\n)\n=\n\nx\n\n8\n\n\n+\n\nx\n\n7\n\n\n+\n\nx\n\n6\n\n\n+\n\nx\n\n4\n\n\n+\n1.\n\n\n\n{\\displaystyle g(x)={\\rm {lcm}}(m_{1}(x),m_{3}(x))=(x^{4}+x+1)(x^{4}+x^{3}+x^{2}+x+1)=x^{8}+x^{7}+x^{6}+x^{4}+1.\\,}\n\n\nIt has minimal Hamming distance at least 5 and corrects up to two errors. Since the generator polynomial is of degree 8, this code has 7 data bits and 8 checksum bits.\nThe BCH code with \n\n\n\nd\n=\n8\n\n\n{\\displaystyle d=8}\n\n and higher has generator polynomial\n\n\n\n\n\n\n\n\ng\n(\nx\n)\n\n\n\n\n\n=\n\n\nl\nc\nm\n\n\n(\n\nm\n\n1\n\n\n(\nx\n)\n,\n\nm\n\n3\n\n\n(\nx\n)\n,\n\nm\n\n5\n\n\n(\nx\n)\n,\n\nm\n\n7\n\n\n(\nx\n)\n)\n\n\n\n\n\n\n\n\n=\n(\n\nx\n\n4\n\n\n+\nx\n+\n1\n)\n(\n\nx\n\n4\n\n\n+\n\nx\n\n3\n\n\n+\n\nx\n\n2\n\n\n+\nx\n+\n1\n)\n(\n\nx\n\n2\n\n\n+\nx\n+\n1\n)\n(\n\nx\n\n4\n\n\n+\n\nx\n\n3\n\n\n+\n1\n)\n\n\n\n\n\n\n\n\n=\n\nx\n\n14\n\n\n+\n\nx\n\n13\n\n\n+\n\nx\n\n12\n\n\n+\n\u22ef\n+\n\nx\n\n2\n\n\n+\nx\n+\n1.\n\n\n\n\n\n\n{\\displaystyle {\\begin{aligned}g(x)&{}={\\rm {lcm}}(m_{1}(x),m_{3}(x),m_{5}(x),m_{7}(x))\\\\&{}=(x^{4}+x+1)(x^{4}+x^{3}+x^{2}+x+1)(x^{2}+x+1)(x^{4}+x^{3}+1)\\\\&{}=x^{14}+x^{13}+x^{12}+\\cdots +x^{2}+x+1.\\end{aligned}}}\n\n\nThis code has minimal Hamming distance 15 and corrects 7 errors. It has 1 data bit and 14 checksum bits. In fact, this code has only two codewords: 000000000000000 and 111111111111111.\nGeneral BCH codes differ from primitive narrow-sense BCH codes in two respects.\nFirst, the requirement that \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n be a primitive element of \n\n\n\n\nG\nF\n\n(\n\nq\n\nm\n\n\n)\n\n\n{\\displaystyle \\mathrm {GF} (q^{m})}\n\n can be relaxed. By relaxing this requirement, the code length changes from \n\n\n\n\nq\n\nm\n\n\n\u2212\n1\n\n\n{\\displaystyle q^{m}-1}\n\n to \n\n\n\n\no\nr\nd\n\n(\n\u03b1\n)\n,\n\n\n{\\displaystyle \\mathrm {ord} (\\alpha ),}\n\n the order of the element \n\n\n\n\u03b1\n.\n\n\n{\\displaystyle \\alpha .}\n\n\nSecond, the consecutive roots of the generator polynomial may run from \n\n\n\n\n\u03b1\n\nc\n\n\n,\n\u2026\n,\n\n\u03b1\n\nc\n+\nd\n\u2212\n2\n\n\n\n\n{\\displaystyle \\alpha ^{c},\\ldots ,\\alpha ^{c+d-2}}\n\n instead of \n\n\n\n\u03b1\n,\n\u2026\n,\n\n\u03b1\n\nd\n\u2212\n1\n\n\n.\n\n\n{\\displaystyle \\alpha ,\\ldots ,\\alpha ^{d-1}.}\n\n\nDefinition. Fix a finite field \n\n\n\nG\nF\n(\nq\n)\n,\n\n\n{\\displaystyle GF(q),}\n\n where \n\n\n\nq\n\n\n{\\displaystyle q}\n\n is a prime power. Choose positive integers \n\n\n\nm\n,\nn\n,\nd\n,\nc\n\n\n{\\displaystyle m,n,d,c}\n\n such that \n\n\n\n2\n\u2264\nd\n\u2264\nn\n,\n\n\n{\\displaystyle 2\\leq d\\leq n,}\n\n \n\n\n\n\n\ng\nc\nd\n\n\n(\nn\n,\nq\n)\n=\n1\n,\n\n\n{\\displaystyle {\\rm {gcd}}(n,q)=1,}\n\n and \n\n\n\nm\n\n\n{\\displaystyle m}\n\n is the multiplicative order of \n\n\n\nq\n\n\n{\\displaystyle q}\n\n modulo \n\n\n\nn\n.\n\n\n{\\displaystyle n.}\n\n\nAs before, let \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n be a primitive \n\n\n\nn\n\n\n{\\displaystyle n}\n\nth root of unity in \n\n\n\nG\nF\n(\n\nq\n\nm\n\n\n)\n,\n\n\n{\\displaystyle GF(q^{m}),}\n\n and let \n\n\n\n\nm\n\ni\n\n\n(\nx\n)\n\n\n{\\displaystyle m_{i}(x)}\n\n be the minimal polynomial over \n\n\n\nG\nF\n(\nq\n)\n\n\n{\\displaystyle GF(q)}\n\n of \n\n\n\n\n\u03b1\n\ni\n\n\n\n\n{\\displaystyle \\alpha ^{i}}\n\n for all \n\n\n\ni\n.\n\n\n{\\displaystyle i.}\n\n The generator polynomial of the BCH code is defined as the least common multiple \n\n\n\ng\n(\nx\n)\n=\n\n\nl\nc\nm\n\n\n(\n\nm\n\nc\n\n\n(\nx\n)\n,\n\u2026\n,\n\nm\n\nc\n+\nd\n\u2212\n2\n\n\n(\nx\n)\n)\n.\n\n\n{\\displaystyle g(x)={\\rm {lcm}}(m_{c}(x),\\ldots ,m_{c+d-2}(x)).}\n\n\nNote: if \n\n\n\nn\n=\n\nq\n\nm\n\n\n\u2212\n1\n\n\n{\\displaystyle n=q^{m}-1}\n\n as in the simplified definition, then \n\n\n\n\n\ng\nc\nd\n\n\n(\nn\n,\nq\n)\n\n\n{\\displaystyle {\\rm {gcd}}(n,q)}\n\n is 1, and the order of \n\n\n\nq\n\n\n{\\displaystyle q}\n\n modulo \n\n\n\nn\n\n\n{\\displaystyle n}\n\n is \n\n\n\nm\n.\n\n\n{\\displaystyle m.}\n\n Therefore, the simplified definition is indeed a special case of the general one.\nThe generator polynomial \n\n\n\ng\n(\nx\n)\n\n\n{\\displaystyle g(x)}\n\n of a BCH code has coefficients from \n\n\n\n\nG\nF\n\n(\nq\n)\n.\n\n\n{\\displaystyle \\mathrm {GF} (q).}\n\n In general, a cyclic code over \n\n\n\n\nG\nF\n\n(\n\nq\n\np\n\n\n)\n\n\n{\\displaystyle \\mathrm {GF} (q^{p})}\n\n with \n\n\n\ng\n(\nx\n)\n\n\n{\\displaystyle g(x)}\n\n as the generator polynomial is called a BCH code over \n\n\n\n\nG\nF\n\n(\n\nq\n\np\n\n\n)\n.\n\n\n{\\displaystyle \\mathrm {GF} (q^{p}).}\n\n The BCH code over \n\n\n\n\nG\nF\n\n(\n\nq\n\nm\n\n\n)\n\n\n{\\displaystyle \\mathrm {GF} (q^{m})}\n\n with \n\n\n\ng\n(\nx\n)\n\n\n{\\displaystyle g(x)}\n\n as the generator polynomial is called a Reed\u2013Solomon code. In other words, a Reed\u2013Solomon code is a BCH code where the decoder alphabet is the same as the channel alphabet.[6]\nThe generator polynomial of a BCH code has degree at most \n\n\n\n(\nd\n\u2212\n1\n)\nm\n\n\n{\\displaystyle (d-1)m}\n\n. Moreover, if \n\n\n\nq\n=\n2\n\n\n{\\displaystyle q=2}\n\n and \n\n\n\nc\n=\n1\n\n\n{\\displaystyle c=1}\n\n, the generator polynomial has degree at most \n\n\n\nd\nm\n\n/\n\n2\n\n\n{\\displaystyle dm/2}\n\n.\nEach minimal polynomial \n\n\n\n\nm\n\ni\n\n\n(\nx\n)\n\n\n{\\displaystyle m_{i}(x)}\n\n has degree at most \n\n\n\nm\n\n\n{\\displaystyle m}\n\n. Therefore, the least common multiple of \n\n\n\nd\n\u2212\n1\n\n\n{\\displaystyle d-1}\n\n of them has degree at most \n\n\n\n(\nd\n\u2212\n1\n)\nm\n\n\n{\\displaystyle (d-1)m}\n\n. Moreover, if \n\n\n\nq\n=\n2\n,\n\n\n{\\displaystyle q=2,}\n\n then \n\n\n\n\nm\n\ni\n\n\n(\nx\n)\n=\n\nm\n\n2\ni\n\n\n(\nx\n)\n\n\n{\\displaystyle m_{i}(x)=m_{2i}(x)}\n\n for all \n\n\n\ni\n\n\n{\\displaystyle i}\n\n. Therefore, \n\n\n\ng\n(\nx\n)\n\n\n{\\displaystyle g(x)}\n\n is the least common multiple of at most \n\n\n\nd\n\n/\n\n2\n\n\n{\\displaystyle d/2}\n\n minimal polynomials \n\n\n\n\nm\n\ni\n\n\n(\nx\n)\n\n\n{\\displaystyle m_{i}(x)}\n\n for odd indices \n\n\n\ni\n,\n\n\n{\\displaystyle i,}\n\n each of degree at most \n\n\n\nm\n\n\n{\\displaystyle m}\n\n.\nA BCH code has minimal Hamming distance at least \n\n\n\nd\n\n\n{\\displaystyle d}\n\n.\nSuppose that \n\n\n\np\n(\nx\n)\n\n\n{\\displaystyle p(x)}\n\n is a code word with fewer than \n\n\n\nd\n\n\n{\\displaystyle d}\n\n non-zero terms. Then\nRecall that \n\n\n\n\n\u03b1\n\nc\n\n\n,\n\u2026\n,\n\n\u03b1\n\nc\n+\nd\n\u2212\n2\n\n\n\n\n{\\displaystyle \\alpha ^{c},\\ldots ,\\alpha ^{c+d-2}}\n\n are roots of \n\n\n\ng\n(\nx\n)\n,\n\n\n{\\displaystyle g(x),}\n\n hence of \n\n\n\np\n(\nx\n)\n\n\n{\\displaystyle p(x)}\n\n. This implies that \n\n\n\n\nb\n\n1\n\n\n,\n\u2026\n,\n\nb\n\nd\n\u2212\n1\n\n\n\n\n{\\displaystyle b_{1},\\ldots ,b_{d-1}}\n\n satisfy the following equations, for each \n\n\n\ni\n\u2208\n{\nc\n,\n\u2026\n,\nc\n+\nd\n\u2212\n2\n}\n\n\n{\\displaystyle i\\in \\{c,\\dotsc ,c+d-2\\}}\n\n:\nIn matrix form, we have\nThe determinant of this matrix equals\nThe matrix \n\n\n\nV\n\n\n{\\displaystyle V}\n\n is seen to be a Vandermonde matrix, and its determinant is\nwhich is non-zero. It therefore follows that \n\n\n\n\nb\n\n1\n\n\n,\n\u2026\n,\n\nb\n\nd\n\u2212\n1\n\n\n=\n0\n,\n\n\n{\\displaystyle b_{1},\\ldots ,b_{d-1}=0,}\n\n hence \n\n\n\np\n(\nx\n)\n=\n0.\n\n\n{\\displaystyle p(x)=0.}\n\n\nA BCH code is cyclic.\nA polynomial code of length \n\n\n\nn\n\n\n{\\displaystyle n}\n\n is cyclic if and only if its generator polynomial divides \n\n\n\n\nx\n\nn\n\n\n\u2212\n1.\n\n\n{\\displaystyle x^{n}-1.}\n\n Since \n\n\n\ng\n(\nx\n)\n\n\n{\\displaystyle g(x)}\n\n is the minimal polynomial with roots \n\n\n\n\n\u03b1\n\nc\n\n\n,\n\u2026\n,\n\n\u03b1\n\nc\n+\nd\n\u2212\n2\n\n\n,\n\n\n{\\displaystyle \\alpha ^{c},\\ldots ,\\alpha ^{c+d-2},}\n\n it suffices to check that each of \n\n\n\n\n\u03b1\n\nc\n\n\n,\n\u2026\n,\n\n\u03b1\n\nc\n+\nd\n\u2212\n2\n\n\n\n\n{\\displaystyle \\alpha ^{c},\\ldots ,\\alpha ^{c+d-2}}\n\n is a root of \n\n\n\n\nx\n\nn\n\n\n\u2212\n1.\n\n\n{\\displaystyle x^{n}-1.}\n\n This follows immediately from the fact that \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n is, by definition, an \n\n\n\nn\n\n\n{\\displaystyle n}\n\nth root of unity.\nThere are many algorithms for decoding BCH codes. The most common ones follow this general outline:\nDuring some of these steps, the decoding algorithm may determine that the received vector has too many errors and cannot be corrected. For example, if an appropriate value of t is not found, then the correction would fail. In a truncated (not primitive) code, an error location may be out of range. If the received vector has more errors than the code can correct, the decoder may unknowingly produce an apparently valid message that is not the one that was sent.\nThe received vector \n\n\n\nR\n\n\n{\\displaystyle R}\n\n is the sum of the correct codeword \n\n\n\nC\n\n\n{\\displaystyle C}\n\n and an unknown error vector \n\n\n\nE\n.\n\n\n{\\displaystyle E.}\n\n The syndrome values are formed by considering \n\n\n\nR\n\n\n{\\displaystyle R}\n\n as a polynomial and evaluating it at \n\n\n\n\n\u03b1\n\nc\n\n\n,\n\u2026\n,\n\n\u03b1\n\nc\n+\nd\n\u2212\n2\n\n\n.\n\n\n{\\displaystyle \\alpha ^{c},\\ldots ,\\alpha ^{c+d-2}.}\n\n Thus the syndromes are[7]\nfor \n\n\n\nj\n=\nc\n\n\n{\\displaystyle j=c}\n\n to \n\n\n\nc\n+\nd\n\u2212\n2.\n\n\n{\\displaystyle c+d-2.}\n\n Since \n\n\n\n\n\u03b1\n\nj\n\n\n\n\n{\\displaystyle \\alpha ^{j}}\n\n are the zeros of \n\n\n\ng\n(\nx\n)\n,\n\n\n{\\displaystyle g(x),}\n\n of which \n\n\n\nC\n(\nx\n)\n\n\n{\\displaystyle C(x)}\n\n is a multiple, \n\n\n\nC\n(\n\n\u03b1\n\nj\n\n\n)\n=\n0.\n\n\n{\\displaystyle C(\\alpha ^{j})=0.}\n\n Examining the syndrome values thus isolates the error vector so one can begin to solve for it.\nIf there is no error, \n\n\n\n\ns\n\nj\n\n\n=\n0\n\n\n{\\displaystyle s_{j}=0}\n\n for all \n\n\n\nj\n.\n\n\n{\\displaystyle j.}\n\n If the syndromes are all zero, then the decoding is done.\nIf there are nonzero syndromes, then there are errors. The decoder needs to figure out how many errors and the location of those errors.\nIf there is a single error, write this as \n\n\n\nE\n(\nx\n)\n=\ne\n\n\nx\n\ni\n\n\n,\n\n\n{\\displaystyle E(x)=e\\,x^{i},}\n\n where \n\n\n\ni\n\n\n{\\displaystyle i}\n\n is the location of the error and \n\n\n\ne\n\n\n{\\displaystyle e}\n\n is its magnitude. Then the first two syndromes are\nso together they allow us to calculate \n\n\n\ne\n\n\n{\\displaystyle e}\n\n and provide some information about \n\n\n\ni\n\n\n{\\displaystyle i}\n\n (completely determining it in the case of Reed\u2013Solomon codes).\nIf there are two or more errors,\nIt is not immediately obvious how to begin solving the resulting syndromes for the unknowns \n\n\n\n\ne\n\nk\n\n\n\n\n{\\displaystyle e_{k}}\n\n and \n\n\n\n\ni\n\nk\n\n\n.\n\n\n{\\displaystyle i_{k}.}\n\n First step is finding locator polynomial\nTwo popular algorithms for this task are:\nPeterson's algorithm is the step 2 of the generalized BCH decoding procedure. Peterson's algorithm is used to calculate the error locator polynomial coefficients \n\n\n\n\n\u03bb\n\n1\n\n\n,\n\n\u03bb\n\n2\n\n\n,\n\u2026\n,\n\n\u03bb\n\nv\n\n\n\n\n{\\displaystyle \\lambda _{1},\\lambda _{2},\\dots ,\\lambda _{v}}\n\n of a polynomial\nNow the procedure of the Peterson\u2013Gorenstein\u2013Zierler algorithm.[8] Expect we have at least 2t syndromes sc,...,sc+2t\u22121. Let v\u00a0=\u00a0t.\nNow that you have the \n\n\n\n\u039b\n(\nx\n)\n\n\n{\\displaystyle \\Lambda (x)}\n\n polynomial, its roots can be found in the form \n\n\n\n\u039b\n(\nx\n)\n=\n(\n\n\u03b1\n\n\ni\n\n1\n\n\n\n\nx\n\u2212\n1\n)\n(\n\n\u03b1\n\n\ni\n\n2\n\n\n\n\nx\n\u2212\n1\n)\n\u22ef\n(\n\n\u03b1\n\n\ni\n\nv\n\n\n\n\nx\n\u2212\n1\n)\n\n\n{\\displaystyle \\Lambda (x)=(\\alpha ^{i_{1}}x-1)(\\alpha ^{i_{2}}x-1)\\cdots (\\alpha ^{i_{v}}x-1)}\n\n by brute force for example using the Chien search algorithm. The exponential powers of the primitive element \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n will yield the positions where errors occur in the received word; hence the name 'error locator' polynomial.\nThe zeros of \u039b(x) are \u03b1\u2212i1, ..., \u03b1\u2212iv.\nOnce the error locations are known, the next step is to determine the error values at those locations. The error values are then used to correct the received values at those locations to recover the original codeword.\nFor the case of binary BCH, (with all characters readable) this is trivial; just flip the bits for the received word at these positions, and we have the corrected code word. In the more general case, the error weights \n\n\n\n\ne\n\nj\n\n\n\n\n{\\displaystyle e_{j}}\n\n can be determined by solving the linear system\nHowever, there is a more efficient method known as the Forney algorithm.\nLet\nAnd the error evaluator polynomial[9]\nFinally:\nwhere\nThan if syndromes could be explained by an error word, which could be nonzero only on positions \n\n\n\n\ni\n\nk\n\n\n\n\n{\\displaystyle i_{k}}\n\n, then error values are\nFor narrow-sense BCH codes, c = 1, so the expression simplifies to:\nIt is based on Lagrange interpolation and techniques of generating functions.\nConsider \n\n\n\nS\n(\nx\n)\n\u039b\n(\nx\n)\n,\n\n\n{\\displaystyle S(x)\\Lambda (x),}\n\n and for the sake of simplicity suppose \n\n\n\n\n\u03bb\n\nk\n\n\n=\n0\n\n\n{\\displaystyle \\lambda _{k}=0}\n\n for \n\n\n\nk\n>\nv\n,\n\n\n{\\displaystyle k>v,}\n\n and \n\n\n\n\ns\n\nk\n\n\n=\n0\n\n\n{\\displaystyle s_{k}=0}\n\n for \n\n\n\nk\n>\nc\n+\nd\n\u2212\n2.\n\n\n{\\displaystyle k>c+d-2.}\n\n Then\nWe want to compute unknowns \n\n\n\n\ne\n\nj\n\n\n,\n\n\n{\\displaystyle e_{j},}\n\n and we could simplify the context by removing the \n\n\n\n(\nx\n\n\u03b1\n\n\ni\n\nj\n\n\n\n\n\n)\n\nd\n\u2212\n1\n\n\n\n\n{\\displaystyle (x\\alpha ^{i_{j}})^{d-1}}\n\n terms. This leads to the error evaluator polynomial\nThanks to \n\n\n\nv\n\u2a7d\nd\n\u2212\n1\n\n\n{\\displaystyle v\\leqslant d-1}\n\n we have\nThanks to \n\n\n\n\u039b\n\n\n{\\displaystyle \\Lambda }\n\n (the Lagrange interpolation trick) the sum degenerates to only one summand for \n\n\n\nx\n=\n\n\u03b1\n\n\u2212\n\ni\n\nk\n\n\n\n\n\n\n{\\displaystyle x=\\alpha ^{-i_{k}}}\n\n\nTo get \n\n\n\n\ne\n\nk\n\n\n\n\n{\\displaystyle e_{k}}\n\n we just should get rid of the product. We could compute the product directly from already computed roots \n\n\n\n\n\u03b1\n\n\u2212\n\ni\n\nj\n\n\n\n\n\n\n{\\displaystyle \\alpha ^{-i_{j}}}\n\n of \n\n\n\n\u039b\n,\n\n\n{\\displaystyle \\Lambda ,}\n\n but we could use simpler form.\nAs formal derivative\nwe get again only one summand in\nSo finally\nThis formula is advantageous when one computes the formal derivative of \n\n\n\n\u039b\n\n\n{\\displaystyle \\Lambda }\n\n form\nyielding:\nwhere\nAn alternate process of finding both the polynomial \u039b and the error locator polynomial is based on Yasuo Sugiyama's adaptation of the Extended Euclidean algorithm.[10] Correction of unreadable characters could be incorporated to the algorithm easily as well.\nLet \n\n\n\n\nk\n\n1\n\n\n,\n.\n.\n.\n,\n\nk\n\nk\n\n\n\n\n{\\displaystyle k_{1},...,k_{k}}\n\n be positions of unreadable characters. One creates polynomial localising these positions \n\n\n\n\u0393\n(\nx\n)\n=\n\n\u220f\n\ni\n=\n1\n\n\nk\n\n\n(\nx\n\n\u03b1\n\n\nk\n\ni\n\n\n\n\n\u2212\n1\n)\n.\n\n\n{\\displaystyle \\Gamma (x)=\\prod _{i=1}^{k}(x\\alpha ^{k_{i}}-1).}\n\n Set values on unreadable positions to 0 and compute the syndromes.\nAs we have already defined for the Forney formula let \n\n\n\nS\n(\nx\n)\n=\n\n\u2211\n\ni\n=\n0\n\n\nd\n\u2212\n2\n\n\n\ns\n\nc\n+\ni\n\n\n\nx\n\ni\n\n\n.\n\n\n{\\displaystyle S(x)=\\sum _{i=0}^{d-2}s_{c+i}x^{i}.}\n\n\nLet us run extended Euclidean algorithm for locating least common divisor of polynomials \n\n\n\nS\n(\nx\n)\n\u0393\n(\nx\n)\n\n\n{\\displaystyle S(x)\\Gamma (x)}\n\n and \n\n\n\n\nx\n\nd\n\u2212\n1\n\n\n.\n\n\n{\\displaystyle x^{d-1}.}\n\n The goal is not to find the least common divisor, but a polynomial \n\n\n\nr\n(\nx\n)\n\n\n{\\displaystyle r(x)}\n\n of degree at most \n\n\n\n\u230a\n(\nd\n+\nk\n\u2212\n3\n)\n\n/\n\n2\n\u230b\n\n\n{\\displaystyle \\lfloor (d+k-3)/2\\rfloor }\n\n and polynomials \n\n\n\na\n(\nx\n)\n,\nb\n(\nx\n)\n\n\n{\\displaystyle a(x),b(x)}\n\n such that \n\n\n\nr\n(\nx\n)\n=\na\n(\nx\n)\nS\n(\nx\n)\n\u0393\n(\nx\n)\n+\nb\n(\nx\n)\n\nx\n\nd\n\u2212\n1\n\n\n.\n\n\n{\\displaystyle r(x)=a(x)S(x)\\Gamma (x)+b(x)x^{d-1}.}\n\n Low degree of \n\n\n\nr\n(\nx\n)\n\n\n{\\displaystyle r(x)}\n\n guarantees, that \n\n\n\na\n(\nx\n)\n\n\n{\\displaystyle a(x)}\n\n would satisfy extended (by \n\n\n\n\u0393\n\n\n{\\displaystyle \\Gamma }\n\n) defining conditions for \n\n\n\n\u039b\n.\n\n\n{\\displaystyle \\Lambda .}\n\n\nDefining \n\n\n\n\u039e\n(\nx\n)\n=\na\n(\nx\n)\n\u0393\n(\nx\n)\n\n\n{\\displaystyle \\Xi (x)=a(x)\\Gamma (x)}\n\n and using \n\n\n\n\u039e\n\n\n{\\displaystyle \\Xi }\n\n on the place of \n\n\n\n\u039b\n(\nx\n)\n\n\n{\\displaystyle \\Lambda (x)}\n\n in the Fourney formula will give us error values.\nThe main advantage of the algorithm is that it meanwhile computes \n\n\n\n\u03a9\n(\nx\n)\n=\nS\n(\nx\n)\n\u039e\n(\nx\n)\n\n\nmod\n\nx\n\n\n\nd\n\u2212\n1\n\n\n=\nr\n(\nx\n)\n\n\n{\\displaystyle \\Omega (x)=S(x)\\Xi (x){\\bmod {x}}^{d-1}=r(x)}\n\n required in the Forney formula.\nThe goal is to find a codeword which differs from the received word minimally as possible on readable positions. When expressing the received word as a sum of nearest codeword and error word, we are trying to find error word with minimal number of non-zeros on readable positions. Syndrom \n\n\n\n\ns\n\ni\n\n\n\n\n{\\displaystyle s_{i}}\n\n restricts error word by condition\nWe could write these conditions separately or we could create polynomial\nand compare coefficients near powers \n\n\n\n0\n\n\n{\\displaystyle 0}\n\n to \n\n\n\nd\n\u2212\n2.\n\n\n{\\displaystyle d-2.}\n\n\nSuppose there is unreadable letter on position \n\n\n\n\nk\n\n1\n\n\n,\n\n\n{\\displaystyle k_{1},}\n\n we could replace set of syndromes \n\n\n\n{\n\ns\n\nc\n\n\n,\n\u22ef\n,\n\ns\n\nc\n+\nd\n\u2212\n2\n\n\n}\n\n\n{\\displaystyle \\{s_{c},\\cdots ,s_{c+d-2}\\}}\n\n by set of syndromes \n\n\n\n{\n\nt\n\nc\n\n\n,\n\u22ef\n,\n\nt\n\nc\n+\nd\n\u2212\n3\n\n\n}\n\n\n{\\displaystyle \\{t_{c},\\cdots ,t_{c+d-3}\\}}\n\n defined by equation \n\n\n\n\nt\n\ni\n\n\n=\n\n\u03b1\n\n\nk\n\n1\n\n\n\n\n\ns\n\ni\n\n\n\u2212\n\ns\n\ni\n+\n1\n\n\n.\n\n\n{\\displaystyle t_{i}=\\alpha ^{k_{1}}s_{i}-s_{i+1}.}\n\n Suppose for an error word all restrictions by original set \n\n\n\n{\n\ns\n\nc\n\n\n,\n\u22ef\n,\n\ns\n\nc\n+\nd\n\u2212\n2\n\n\n}\n\n\n{\\displaystyle \\{s_{c},\\cdots ,s_{c+d-2}\\}}\n\n of syndromes hold, than\nNew set of syndromes restricts error vector\nthe same way the original set of syndromes restricted the error vector \n\n\n\n\ne\n\nj\n\n\n.\n\n\n{\\displaystyle e_{j}.}\n\n Note, that except the coordinate \n\n\n\n\nk\n\n1\n\n\n,\n\n\n{\\displaystyle k_{1},}\n\n where we have \n\n\n\n\nf\n\n\nk\n\n1\n\n\n\n\n=\n0\n,\n\n\n{\\displaystyle f_{k_{1}}=0,}\n\n an \n\n\n\n\nf\n\nj\n\n\n\n\n{\\displaystyle f_{j}}\n\n is zero, if \n\n\n\n\ne\n\nj\n\n\n=\n0.\n\n\n{\\displaystyle e_{j}=0.}\n\n For the goal of locating error positions we could change the set of syndromes in the similar way to reflect all unreadable characters. This shortens the set of syndromes by \n\n\n\nk\n.\n\n\n{\\displaystyle k.}\n\n\nIn polynomial formulation, the replacement of syndromes set \n\n\n\n{\n\ns\n\nc\n\n\n,\n\u22ef\n,\n\ns\n\nc\n+\nd\n\u2212\n2\n\n\n}\n\n\n{\\displaystyle \\{s_{c},\\cdots ,s_{c+d-2}\\}}\n\n by syndromes set \n\n\n\n{\n\nt\n\nc\n\n\n,\n\u22ef\n,\n\nt\n\nc\n+\nd\n\u2212\n3\n\n\n}\n\n\n{\\displaystyle \\{t_{c},\\cdots ,t_{c+d-3}\\}}\n\n leads to\nTherefore\nAfter replacement of \n\n\n\nS\n(\nx\n)\n\n\n{\\displaystyle S(x)}\n\n by \n\n\n\nS\n(\nx\n)\n\u0393\n(\nx\n)\n\n\n{\\displaystyle S(x)\\Gamma (x)}\n\n, one would require equation for coefficients near powers \n\n\n\nk\n,\n\u22ef\n,\nd\n\u2212\n2.\n\n\n{\\displaystyle k,\\cdots ,d-2.}\n\n\nOne could consider looking for error positions from the point of view of eliminating influence of given positions similarly as for unreadable characters. If we found \n\n\n\nv\n\n\n{\\displaystyle v}\n\n positions such that eliminating their influence leads to obtaining set of syndromes consisting of all zeros, than there exists error vector with errors only on these coordinates. If \n\n\n\n\u039b\n(\nx\n)\n\n\n{\\displaystyle \\Lambda (x)}\n\n denotes the polynomial eliminating the influence of these coordinates, we obtain\nIn Euclidean algorithm, we try to correct at most \n\n\n\n\n\n\n1\n2\n\n\n\n(\nd\n\u2212\n1\n\u2212\nk\n)\n\n\n{\\displaystyle {\\tfrac {1}{2}}(d-1-k)}\n\n errors (on readable positions), because with bigger error count there could be more codewords in the same distance from the received word. Therefore, for \n\n\n\n\u039b\n(\nx\n)\n\n\n{\\displaystyle \\Lambda (x)}\n\n we are looking for, the equation must hold for coefficients near powers starting from\nIn Forney formula, \n\n\n\n\u039b\n(\nx\n)\n\n\n{\\displaystyle \\Lambda (x)}\n\n could be multiplied by a scalar giving the same result.\nIt could happen that the Euclidean algorithm finds \n\n\n\n\u039b\n(\nx\n)\n\n\n{\\displaystyle \\Lambda (x)}\n\n of degree higher than \n\n\n\n\n\n\n1\n2\n\n\n\n(\nd\n\u2212\n1\n\u2212\nk\n)\n\n\n{\\displaystyle {\\tfrac {1}{2}}(d-1-k)}\n\n having number of different roots equal to its degree, where the Fourney formula would be able to correct errors in all its roots, anyways correcting such many errors could be risky (especially with no other restrictions on received word). Usually after getting \n\n\n\n\u039b\n(\nx\n)\n\n\n{\\displaystyle \\Lambda (x)}\n\n of higher degree, we decide not to correct the errors. Correction could fail in the case \n\n\n\n\u039b\n(\nx\n)\n\n\n{\\displaystyle \\Lambda (x)}\n\n has roots with higher multiplicity or the number of roots is smaller than its degree. Fail could be detected as well by Forney formula returning error outside the transmitted alphabet.\nUsing the error values and error location, correct the errors and form a corrected code vector by subtracting error values at error locations.\nConsider a BCH code in GF(24) with \n\n\n\nd\n=\n7\n\n\n{\\displaystyle d=7}\n\n and \n\n\n\ng\n(\nx\n)\n=\n\nx\n\n10\n\n\n+\n\nx\n\n8\n\n\n+\n\nx\n\n5\n\n\n+\n\nx\n\n4\n\n\n+\n\nx\n\n2\n\n\n+\nx\n+\n1\n\n\n{\\displaystyle g(x)=x^{10}+x^{8}+x^{5}+x^{4}+x^{2}+x+1}\n\n. (This is used in QR codes.) Let the message to be transmitted be [1 1 0 1 1], or in polynomial notation, \n\n\n\nM\n(\nx\n)\n=\n\nx\n\n4\n\n\n+\n\nx\n\n3\n\n\n+\nx\n+\n1.\n\n\n{\\displaystyle M(x)=x^{4}+x^{3}+x+1.}\n\n The \"checksum\" symbols are calculated by dividing \n\n\n\n\nx\n\n10\n\n\nM\n(\nx\n)\n\n\n{\\displaystyle x^{10}M(x)}\n\n by \n\n\n\ng\n(\nx\n)\n\n\n{\\displaystyle g(x)}\n\n and taking the remainder, resulting in \n\n\n\n\nx\n\n9\n\n\n+\n\nx\n\n4\n\n\n+\n\nx\n\n2\n\n\n\n\n{\\displaystyle x^{9}+x^{4}+x^{2}}\n\n or [ 1 0 0 0 0 1 0 1 0 0 ]. These are appended to the message, so the transmitted codeword is [ 1 1 0 1 1 1 0 0 0 0 1 0 1 0 0 ].\nNow, imagine that there are two bit-errors in the transmission, so the received codeword is [ 1 0 0 1 1 1 0 0 0 1 1 0 1 0 0 ]. In polynomial notation:\nIn order to correct the errors, first calculate the syndromes. Taking \n\n\n\n\u03b1\n=\n0010\n,\n\n\n{\\displaystyle \\alpha =0010,}\n\n we have \n\n\n\n\ns\n\n1\n\n\n=\nR\n(\n\n\u03b1\n\n1\n\n\n)\n=\n1011\n,\n\n\n{\\displaystyle s_{1}=R(\\alpha ^{1})=1011,}\n\n \n\n\n\n\ns\n\n2\n\n\n=\n1001\n,\n\n\n{\\displaystyle s_{2}=1001,}\n\n \n\n\n\n\ns\n\n3\n\n\n=\n1011\n,\n\n\n{\\displaystyle s_{3}=1011,}\n\n \n\n\n\n\ns\n\n4\n\n\n=\n1101\n,\n\n\n{\\displaystyle s_{4}=1101,}\n\n \n\n\n\n\ns\n\n5\n\n\n=\n0001\n,\n\n\n{\\displaystyle s_{5}=0001,}\n\n and \n\n\n\n\ns\n\n6\n\n\n=\n1001.\n\n\n{\\displaystyle s_{6}=1001.}\n\n Next, apply the Peterson procedure by row-reducing the following augmented matrix.\nDue to the zero row, S3\u00d73 is singular, which is no surprise since only two errors were introduced into the codeword. However, the upper-left corner of the matrix is identical to [S2\u00d72 | C2\u00d71], which gives rise to the solution \n\n\n\n\n\u03bb\n\n2\n\n\n=\n1000\n,\n\n\n{\\displaystyle \\lambda _{2}=1000,}\n\n \n\n\n\n\n\u03bb\n\n1\n\n\n=\n1011.\n\n\n{\\displaystyle \\lambda _{1}=1011.}\n\n The resulting error locator polynomial is \n\n\n\n\u039b\n(\nx\n)\n=\n1000\n\nx\n\n2\n\n\n+\n1011\nx\n+\n0001\n,\n\n\n{\\displaystyle \\Lambda (x)=1000x^{2}+1011x+0001,}\n\n which has zeros at \n\n\n\n0100\n=\n\n\u03b1\n\n\u2212\n13\n\n\n\n\n{\\displaystyle 0100=\\alpha ^{-13}}\n\n and \n\n\n\n0111\n=\n\n\u03b1\n\n\u2212\n5\n\n\n.\n\n\n{\\displaystyle 0111=\\alpha ^{-5}.}\n\n The exponents of \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n correspond to the error locations. There is no need to calculate the error values in this example, as the only possible value is 1.\nSuppose the same scenario, but the received word has two unreadable characters [ 1 0 0\u00a0? 1 1\u00a0? 0 0 1 1 0 1 0 0 ]. We replace the unreadable characters by zeros while creating the polynom reflecting their positions \n\n\n\n\u0393\n(\nx\n)\n=\n(\n\n\u03b1\n\n8\n\n\nx\n\u2212\n1\n)\n(\n\n\u03b1\n\n11\n\n\nx\n\u2212\n1\n)\n.\n\n\n{\\displaystyle \\Gamma (x)=(\\alpha ^{8}x-1)(\\alpha ^{11}x-1).}\n\n We compute the syndromes \n\n\n\n\ns\n\n1\n\n\n=\n\n\u03b1\n\n\u2212\n7\n\n\n,\n\ns\n\n2\n\n\n=\n\n\u03b1\n\n1\n\n\n,\n\ns\n\n3\n\n\n=\n\n\u03b1\n\n4\n\n\n,\n\ns\n\n4\n\n\n=\n\n\u03b1\n\n2\n\n\n,\n\ns\n\n5\n\n\n=\n\n\u03b1\n\n5\n\n\n,\n\n\n{\\displaystyle s_{1}=\\alpha ^{-7},s_{2}=\\alpha ^{1},s_{3}=\\alpha ^{4},s_{4}=\\alpha ^{2},s_{5}=\\alpha ^{5},}\n\n and \n\n\n\n\ns\n\n6\n\n\n=\n\n\u03b1\n\n\u2212\n7\n\n\n.\n\n\n{\\displaystyle s_{6}=\\alpha ^{-7}.}\n\n (Using log notation which is independent on GF(24) isomorphisms. For computation checking we can use the same representation for addition as was used in previous example. Hexadecimal description of the powers of \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n are consecutively 1,2,4,8,3,6,C,B,5,A,7,E,F,D,9 with the addition based on bitwise xor.)\nLet us make syndrome polynomial\ncompute\nRun the extended Euclidean algorithm:\nWe have reached polynomial of degree at most 3, and as\nwe get\nTherefore\nLet \n\n\n\n\u039b\n(\nx\n)\n=\n\n\u03b1\n\n3\n\n\n+\n\n\u03b1\n\n\u2212\n5\n\n\nx\n+\n\n\u03b1\n\n6\n\n\n\nx\n\n2\n\n\n.\n\n\n{\\displaystyle \\Lambda (x)=\\alpha ^{3}+\\alpha ^{-5}x+\\alpha ^{6}x^{2}.}\n\n Don't worry that \n\n\n\n\n\u03bb\n\n0\n\n\n\u2260\n1.\n\n\n{\\displaystyle \\lambda _{0}\\neq 1.}\n\n Find by brute force a root of \n\n\n\n\u039b\n.\n\n\n{\\displaystyle \\Lambda .}\n\n The roots are \n\n\n\n\n\u03b1\n\n2\n\n\n,\n\n\n{\\displaystyle \\alpha ^{2},}\n\n and \n\n\n\n\n\u03b1\n\n10\n\n\n\n\n{\\displaystyle \\alpha ^{10}}\n\n (after finding for example \n\n\n\n\n\u03b1\n\n2\n\n\n\n\n{\\displaystyle \\alpha ^{2}}\n\n we can divide \n\n\n\n\u039b\n\n\n{\\displaystyle \\Lambda }\n\n by corresponding monom \n\n\n\n(\nx\n\u2212\n\n\u03b1\n\n2\n\n\n)\n\n\n{\\displaystyle (x-\\alpha ^{2})}\n\n and the root of resulting monom could be found easily).\nLet\nLet us look for error values using formula\nwhere \n\n\n\n\n\u03b1\n\n\u2212\n\ni\n\nj\n\n\n\n\n\n\n{\\displaystyle \\alpha ^{-i_{j}}}\n\n are roots of \n\n\n\n\u039e\n(\nx\n)\n.\n\n\n{\\displaystyle \\Xi (x).}\n\n \n\n\n\n\n\u039e\n\u2032\n\n(\nx\n)\n=\n\n\u03b1\n\n2\n\n\n\nx\n\n2\n\n\n.\n\n\n{\\displaystyle \\Xi '(x)=\\alpha ^{2}x^{2}.}\n\n We get\nFact, that \n\n\n\n\ne\n\n3\n\n\n=\n\ne\n\n4\n\n\n=\n1\n,\n\n\n{\\displaystyle e_{3}=e_{4}=1,}\n\n should not be surprising.\nCorrected code is therefore [ 1 1 0 1 1 1 0 0 0 0 1 0 1 0 0].\nLet us show the algorithm behaviour for the case with small number of errors. Let the received word is [ 1 0 0\u00a0? 1 1\u00a0? 0 0 0 1 0 1 0 0 ].\nAgain, replace the unreadable characters by zeros while creating the polynom reflecting their positions \n\n\n\n\u0393\n(\nx\n)\n=\n(\n\n\u03b1\n\n8\n\n\nx\n\u2212\n1\n)\n(\n\n\u03b1\n\n11\n\n\nx\n\u2212\n1\n)\n.\n\n\n{\\displaystyle \\Gamma (x)=(\\alpha ^{8}x-1)(\\alpha ^{11}x-1).}\n\n Compute the syndromes \n\n\n\n\ns\n\n1\n\n\n=\n\n\u03b1\n\n4\n\n\n,\n\ns\n\n2\n\n\n=\n\n\u03b1\n\n\u2212\n7\n\n\n,\n\ns\n\n3\n\n\n=\n\n\u03b1\n\n1\n\n\n,\n\ns\n\n4\n\n\n=\n\n\u03b1\n\n1\n\n\n,\n\ns\n\n5\n\n\n=\n\n\u03b1\n\n0\n\n\n,\n\n\n{\\displaystyle s_{1}=\\alpha ^{4},s_{2}=\\alpha ^{-7},s_{3}=\\alpha ^{1},s_{4}=\\alpha ^{1},s_{5}=\\alpha ^{0},}\n\n and \n\n\n\n\ns\n\n6\n\n\n=\n\n\u03b1\n\n2\n\n\n.\n\n\n{\\displaystyle s_{6}=\\alpha ^{2}.}\n\n Create syndrome polynomial\nLet us run the extended Euclidean algorithm:\n\n\n\n\n\n\n\n\n\n\n(\n\n\n\nS\n(\nx\n)\n\u0393\n(\nx\n)\n\n\n\n\n\nx\n\n6\n\n\n\n\n\n)\n\n\n\n\n\n=\n\n\n(\n\n\n\n\n\u03b1\n\n4\n\n\n+\n\n\u03b1\n\n7\n\n\nx\n+\n\n\u03b1\n\n5\n\n\n\nx\n\n2\n\n\n+\n\n\u03b1\n\n3\n\n\n\nx\n\n3\n\n\n+\n\n\u03b1\n\n1\n\n\n\nx\n\n4\n\n\n+\n\n\u03b1\n\n\u2212\n1\n\n\n\nx\n\n5\n\n\n+\n\n\u03b1\n\n\u2212\n1\n\n\n\nx\n\n6\n\n\n+\n\n\u03b1\n\n6\n\n\n\nx\n\n7\n\n\n\n\n\n\n\nx\n\n6\n\n\n\n\n\n)\n\n\n\n\n\n\n\n\n=\n\n\n(\n\n\n\n\n\u03b1\n\n\u2212\n1\n\n\n+\n\n\u03b1\n\n6\n\n\nx\n\n\n1\n\n\n\n\n1\n\n\n0\n\n\n\n)\n\n\n\n\n(\n\n\n\n\nx\n\n6\n\n\n\n\n\n\n\n\u03b1\n\n4\n\n\n+\n\n\u03b1\n\n7\n\n\nx\n+\n\n\u03b1\n\n5\n\n\n\nx\n\n2\n\n\n+\n\n\u03b1\n\n3\n\n\n\nx\n\n3\n\n\n+\n\n\u03b1\n\n1\n\n\n\nx\n\n4\n\n\n+\n\n\u03b1\n\n\u2212\n1\n\n\n\nx\n\n5\n\n\n+\n2\n\n\u03b1\n\n\u2212\n1\n\n\n\nx\n\n6\n\n\n+\n2\n\n\u03b1\n\n6\n\n\n\nx\n\n7\n\n\n\n\n\n)\n\n\n\n\n\n\n\n\n=\n\n\n(\n\n\n\n\n\u03b1\n\n\u2212\n1\n\n\n+\n\n\u03b1\n\n6\n\n\nx\n\n\n1\n\n\n\n\n1\n\n\n0\n\n\n\n)\n\n\n\n\n(\n\n\n\n\n\u03b1\n\n3\n\n\n+\n\n\u03b1\n\n1\n\n\nx\n\n\n1\n\n\n\n\n1\n\n\n0\n\n\n\n)\n\n\n\n\n(\n\n\n\n\n\u03b1\n\n4\n\n\n+\n\n\u03b1\n\n7\n\n\nx\n+\n\n\u03b1\n\n5\n\n\n\nx\n\n2\n\n\n+\n\n\u03b1\n\n3\n\n\n\nx\n\n3\n\n\n+\n\n\u03b1\n\n1\n\n\n\nx\n\n4\n\n\n+\n\n\u03b1\n\n\u2212\n1\n\n\n\nx\n\n5\n\n\n\n\n\n\n\n\u03b1\n\n7\n\n\n+\n(\n\n\u03b1\n\n\u2212\n5\n\n\n+\n\n\u03b1\n\n5\n\n\n)\nx\n+\n2\n\n\u03b1\n\n\u2212\n7\n\n\n\nx\n\n2\n\n\n+\n2\n\n\u03b1\n\n6\n\n\n\nx\n\n3\n\n\n+\n2\n\n\u03b1\n\n4\n\n\n\nx\n\n4\n\n\n+\n2\n\n\u03b1\n\n2\n\n\n\nx\n\n5\n\n\n+\n2\n\nx\n\n6\n\n\n\n\n\n)\n\n\n\n\n\n\n\n\n=\n\n\n(\n\n\n\n(\n1\n+\n\n\u03b1\n\n2\n\n\n)\n+\n(\n\n\u03b1\n\n0\n\n\n+\n\n\u03b1\n\n\u2212\n6\n\n\n)\nx\n+\n\n\u03b1\n\n7\n\n\n\nx\n\n2\n\n\n\n\n\n\u03b1\n\n\u2212\n1\n\n\n+\n\n\u03b1\n\n6\n\n\nx\n\n\n\n\n\n\u03b1\n\n3\n\n\n+\n\n\u03b1\n\n1\n\n\nx\n\n\n1\n\n\n\n)\n\n\n\n\n(\n\n\n\n\n\u03b1\n\n4\n\n\n+\n\n\u03b1\n\n7\n\n\nx\n+\n\n\u03b1\n\n5\n\n\n\nx\n\n2\n\n\n+\n\n\u03b1\n\n3\n\n\n\nx\n\n3\n\n\n+\n\n\u03b1\n\n1\n\n\n\nx\n\n4\n\n\n+\n\n\u03b1\n\n\u2212\n1\n\n\n\nx\n\n5\n\n\n\n\n\n\n\n\u03b1\n\n7\n\n\n+\n\n\u03b1\n\n0\n\n\nx\n\n\n\n)\n\n\n\n\n\n\n\n\n{\\displaystyle {\\begin{aligned}{\\begin{pmatrix}S(x)\\Gamma (x)\\\\x^{6}\\end{pmatrix}}&={\\begin{pmatrix}\\alpha ^{4}+\\alpha ^{7}x+\\alpha ^{5}x^{2}+\\alpha ^{3}x^{3}+\\alpha ^{1}x^{4}+\\alpha ^{-1}x^{5}+\\alpha ^{-1}x^{6}+\\alpha ^{6}x^{7}\\\\x^{6}\\end{pmatrix}}\\\\&={\\begin{pmatrix}\\alpha ^{-1}+\\alpha ^{6}x&1\\\\1&0\\end{pmatrix}}{\\begin{pmatrix}x^{6}\\\\\\alpha ^{4}+\\alpha ^{7}x+\\alpha ^{5}x^{2}+\\alpha ^{3}x^{3}+\\alpha ^{1}x^{4}+\\alpha ^{-1}x^{5}+2\\alpha ^{-1}x^{6}+2\\alpha ^{6}x^{7}\\end{pmatrix}}\\\\&={\\begin{pmatrix}\\alpha ^{-1}+\\alpha ^{6}x&1\\\\1&0\\end{pmatrix}}{\\begin{pmatrix}\\alpha ^{3}+\\alpha ^{1}x&1\\\\1&0\\end{pmatrix}}{\\begin{pmatrix}\\alpha ^{4}+\\alpha ^{7}x+\\alpha ^{5}x^{2}+\\alpha ^{3}x^{3}+\\alpha ^{1}x^{4}+\\alpha ^{-1}x^{5}\\\\\\alpha ^{7}+(\\alpha ^{-5}+\\alpha ^{5})x+2\\alpha ^{-7}x^{2}+2\\alpha ^{6}x^{3}+2\\alpha ^{4}x^{4}+2\\alpha ^{2}x^{5}+2x^{6}\\end{pmatrix}}\\\\&={\\begin{pmatrix}(1+\\alpha ^{2})+(\\alpha ^{0}+\\alpha ^{-6})x+\\alpha ^{7}x^{2}&\\alpha ^{-1}+\\alpha ^{6}x\\\\\\alpha ^{3}+\\alpha ^{1}x&1\\end{pmatrix}}{\\begin{pmatrix}\\alpha ^{4}+\\alpha ^{7}x+\\alpha ^{5}x^{2}+\\alpha ^{3}x^{3}+\\alpha ^{1}x^{4}+\\alpha ^{-1}x^{5}\\\\\\alpha ^{7}+\\alpha ^{0}x\\end{pmatrix}}\\end{aligned}}}\n\n\nWe have reached polynomial of degree at most 3, and as\nwe get\nTherefore,\nLet \n\n\n\n\u039b\n(\nx\n)\n=\n\n\u03b1\n\n3\n\n\n+\n\n\u03b1\n\n1\n\n\nx\n.\n\n\n{\\displaystyle \\Lambda (x)=\\alpha ^{3}+\\alpha ^{1}x.}\n\n Don't worry that \n\n\n\n\n\u03bb\n\n0\n\n\n\u2260\n1.\n\n\n{\\displaystyle \\lambda _{0}\\neq 1.}\n\n The root of \n\n\n\n\u039b\n(\nx\n)\n\n\n{\\displaystyle \\Lambda (x)}\n\n is \n\n\n\n\n\u03b1\n\n3\n\u2212\n1\n\n\n.\n\n\n{\\displaystyle \\alpha ^{3-1}.}\n\n\nLet\nLet us look for error values using formula \n\n\n\n\ne\n\nj\n\n\n=\n\u2212\n\u03a9\n(\n\n\u03b1\n\n\u2212\n\ni\n\nj\n\n\n\n\n)\n\n/\n\n\n\u039e\n\u2032\n\n(\n\n\u03b1\n\n\u2212\n\ni\n\nj\n\n\n\n\n)\n,\n\n\n{\\displaystyle e_{j}=-\\Omega (\\alpha ^{-i_{j}})/\\Xi '(\\alpha ^{-i_{j}}),}\n\n where \n\n\n\n\n\u03b1\n\n\u2212\n\ni\n\nj\n\n\n\n\n\n\n{\\displaystyle \\alpha ^{-i_{j}}}\n\n are roots of polynomial \n\n\n\n\u039e\n(\nx\n)\n.\n\n\n{\\displaystyle \\Xi (x).}\n\n \n\n\n\n\n\u039e\n\u2032\n\n(\nx\n)\n=\n\n\u03b1\n\n\u2212\n7\n\n\n+\n\n\u03b1\n\n5\n\n\n\nx\n\n2\n\n\n.\n\n\n{\\displaystyle \\Xi '(x)=\\alpha ^{-7}+\\alpha ^{5}x^{2}.}\n\n We get\nThe fact that \n\n\n\n\ne\n\n3\n\n\n=\n1\n\n\n{\\displaystyle e_{3}=1}\n\n should not be surprising.\nCorrected code is therefore [ 1 1 0 1 1 1 0 0 0 0 1 0 1 0 0].", 
    "dbpedia_url": "http://dbpedia.org/resource/BCH_code", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/BCH_code\n"
}
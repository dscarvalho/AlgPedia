{
    "about": "Fuzzy extractors convert biometric data into random strings, which makes it possible to apply cryptographic techniques for biometric security. They are used to encrypt and authenticate users records, with biometric inputs as a key. Historically, the first biometric system of this kind was designed by Juels and Wattenberg and was called \"Fuzzy commitment\", where the cryptographic key is decommitted using biometric data. \"Fuzzy\", in that context, implies that the value close to the original one can extract the committed value. Later, Juels and Sudan came up with Fuzzy vault schemes which are order invariant for the fuzzy commitment scheme but uses a Reed\u2013Solomon code. Codeword is evaluated by polynomial and the secret message is inserted as the coefficients of the polynomial. The polynomial is evaluated for different values of a set of features of the biometric data. So Fuzzy commitment and Fuzzy Vault were per-cursor to Fuzzy extractors. Fuzzy extractor is a biometric tool to authenticate a user using its own biometric template as a key. They extract uniform and random string \n\n\n\nR\n\n\n{\\displaystyle R}\n\n from its input \n\n\n\nw\n\n\n{\\displaystyle w}\n\n that has tolerance for noise. If the input changes to \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n but is still close to \n\n\n\nw\n\n\n{\\displaystyle w}\n\n, the string \n\n\n\nR\n\n\n{\\displaystyle R}\n\n can still be re-constructed. When \n\n\n\nR\n\n\n{\\displaystyle R}\n\n is used first time to re-construct, it outputs a helper string \n\n\n\nP\n\n\n{\\displaystyle P}\n\n which can be made public without compromising the security of \n\n\n\nR\n\n\n{\\displaystyle R}\n\n (used for encryption and authentication key) and \n\n\n\nP\n\n\n{\\displaystyle P}\n\n (helper string) is stored to recover \n\n\n\nR\n\n\n{\\displaystyle R}\n\n. They remain secure even when the adversary modifies \n\n\n\nP\n\n\n{\\displaystyle P}\n\n (key agreement between a user and a server based only on a biometric input). This article is based on the papers \"Fuzzy Extractors: A Brief Survey of Results from 2004 to 2006\" and \"Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data\" by Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin and Adam Smith", 
    "name": "Fuzzy Extractor", 
    "classification": "Cryptographic Algorithms", 
    "full_text": "Fuzzy extractors convert biometric data into random strings, which makes it possible to apply cryptographic techniques for biometric security. They are used to encrypt and authenticate users records, with biometric inputs as a key. Historically, the first biometric system of this kind was designed by Juels and Wattenberg and was called \"Fuzzy commitment\", where the cryptographic key is decommitted using biometric data. \"Fuzzy\", in that context, implies that the value close to the original one can extract the committed value. Later, Juels and Sudan came up with Fuzzy vault schemes which are order invariant for the fuzzy commitment scheme but uses a Reed\u2013Solomon code. Codeword is evaluated by polynomial and the secret message is inserted as the coefficients of the polynomial. The polynomial is evaluated for different values of a set of features of the biometric data. So Fuzzy commitment and Fuzzy Vault were per-cursor to Fuzzy extractors. Fuzzy extractor is a biometric tool to authenticate a user using its own biometric template as a key. They extract uniform and random string \n\n\n\nR\n\n\n{\\displaystyle R}\n\n from its input \n\n\n\nw\n\n\n{\\displaystyle w}\n\n that has tolerance for noise. If the input changes to \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n but is still close to \n\n\n\nw\n\n\n{\\displaystyle w}\n\n, the string \n\n\n\nR\n\n\n{\\displaystyle R}\n\n can still be re-constructed. When \n\n\n\nR\n\n\n{\\displaystyle R}\n\n is used first time to re-construct, it outputs a helper string \n\n\n\nP\n\n\n{\\displaystyle P}\n\n which can be made public without compromising the security of \n\n\n\nR\n\n\n{\\displaystyle R}\n\n (used for encryption and authentication key) and \n\n\n\nP\n\n\n{\\displaystyle P}\n\n (helper string) is stored to recover \n\n\n\nR\n\n\n{\\displaystyle R}\n\n. They remain secure even when the adversary modifies \n\n\n\nP\n\n\n{\\displaystyle P}\n\n (key agreement between a user and a server based only on a biometric input). This article is based on the papers \"Fuzzy Extractors: A Brief Survey of Results from 2004 to 2006\" and \"Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data\" by Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin and Adam Smith\n\n\nAs fuzzy extractors deal with how to generate strong keys from Biometrics and other Noisy Data, it applies cryptography paradigms to biometric data and that means (1) Make little assumptions about the biometric data (these data comes from variety of sources and don't want adversary to exploit that so it is best to assume the input is unpredictable) (2) Apply cryptographic application techniques to the input. (for that fuzzy extractor converts biometric data into secret, uniformly random and reliably reproducible random string). According to \"Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data\" paper by Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin and Adam Smith \u2013 these techniques also have other broader applications (when noisy inputs are used) such as human memory, images used as passwords, keys from quantum channel. Based on the Differential Privacy paper by Cynthia Dwork (ICALP 2006) \u2013 fuzzy extractors have application in the proof of impossibility of strong notions of privacy for statistical databases.\nPredictability indicates probability that adversary can guess a secret key. Mathematically speaking, the predictability of a random variable \n\n\n\nA\n\n\n{\\displaystyle A}\n\n is \n\n\n\n\nmax\n\n\na\n\n\n\nP\n[\nA\n=\na\n]\n\n\n{\\displaystyle \\max _{\\mathrm {a} }P[A=a]}\n\n. For example, if pair of random variable \n\n\n\nA\n\n\n{\\displaystyle A}\n\n and \n\n\n\nB\n\n\n{\\displaystyle B}\n\n, if the adversary knows \n\n\n\nb\n\n\n{\\displaystyle b}\n\n of \n\n\n\nB\n\n\n{\\displaystyle B}\n\n, then predictability of \n\n\n\nA\n\n\n{\\displaystyle A}\n\n will be \n\n\n\n\nmax\n\n\na\n\n\n\nP\n[\nA\n=\na\n\n|\n\nB\n=\nb\n]\n\n\n{\\displaystyle \\max _{\\mathrm {a} }P[A=a|B=b]}\n\n. So, Adversary can predict \n\n\n\nA\n\n\n{\\displaystyle A}\n\n with \n\n\n\n\nE\n\nb\n\u2190\nB\n\n\n[\n\nmax\n\n\na\n\n\n\nP\n[\nA\n=\na\n\n|\n\nB\n=\nb\n]\n]\n\n\n{\\displaystyle E_{b\\leftarrow B}[\\max _{\\mathrm {a} }P[A=a|B=b]]}\n\n. Taking average over \n\n\n\nB\n\n\n{\\displaystyle B}\n\n as it is not under adversary control, but since knowing \n\n\n\nb\n\n\n{\\displaystyle b}\n\n makes \n\n\n\nA\n\n\n{\\displaystyle A}\n\n prediction adversarial, taking the worst case over \n\n\n\nA\n\n\n{\\displaystyle A}\n\n.\nMin-entropy indicates worst-case entropy. Mathematically speaking, it is defined as \n\n\n\n\nH\n\n\u221e\n\n\n(\nA\n)\n=\n\u2212\nlog\n\u2061\n(\n\nmax\n\n\na\n\n\n\nP\n[\nA\n=\na\n]\n)\n\n\n{\\displaystyle H_{\\infty }(A)=-\\log(\\max _{\\mathrm {a} }P[A=a])}\n\n . Random variables with min-entropy at least \n\n\n\nm\n\n\n{\\displaystyle m}\n\n is called \n\n\n\nm\n\n\n{\\displaystyle m}\n\n-source.\nStatistical distance is measure of distinguishability. Mathematically speaking, it is between two probability distributions \n\n\n\nA\n\n\n{\\displaystyle A}\n\n and \n\n\n\nB\n\n\n{\\displaystyle B}\n\n is, \n\n\n\nS\nD\n[\nA\n,\nB\n]\n\n\n{\\displaystyle SD[A,B]}\n\n = \n\n\n\n\n\n1\n2\n\n\n\n\u2211\n\n\nv\n\n\n\n\n|\n\nP\n[\nA\n=\nv\n]\n\u2212\nP\n[\nB\n=\nv\n]\n\n|\n\n\n\n{\\displaystyle {\\frac {1}{2}}\\sum _{\\mathrm {v} }|P[A=v]-P[B=v]|}\n\n. In any system if \n\n\n\nA\n\n\n{\\displaystyle A}\n\n is replaced by \n\n\n\nB\n\n\n{\\displaystyle B}\n\n, it will behave as original system with probability at least \n\n\n\n1\n\u2212\nS\nD\n[\nA\n,\nB\n]\n\n\n{\\displaystyle 1-SD[A,B]}\n\n .\nSet \n\n\n\nM\n\n\n{\\displaystyle M}\n\n is strong randomness extractor. Randomized function Ext: \n\n\n\nM\n\u2192\n{\n0\n,\n1\n\n}\n\nl\n\n\n\n\n{\\displaystyle M\\rightarrow \\{0,1\\}^{l}}\n\n with randomness of length \n\n\n\nr\n\n\n{\\displaystyle r}\n\n is an \n\n\n\n(\nm\n,\nl\n,\n\u03f5\n)\n\n\n{\\displaystyle (m,l,\\epsilon )}\n\n -strong extractor if for all \n\n\n\nm\n\n\n{\\displaystyle m}\n\n-sources (Random variables with min-entropy at least \n\n\n\nm\n\n\n{\\displaystyle m}\n\n is called \n\n\n\nm\n\n\n{\\displaystyle m}\n\n-source) \n\n\n\nW\n\n\n{\\displaystyle W}\n\n on \n\n\n\nM\n(\nE\nx\nt\n(\nW\n;\nI\n)\n,\nI\n)\n\n\u2248\n\n\u03f5\n\n\n(\n\nU\n\nl\n\n\n,\n\nU\n\nr\n\n\n)\n,\n\n\n{\\displaystyle M(Ext(W;I),I)\\approx _{\\epsilon }(U_{l},U_{r}),}\n\n where \n\n\n\nI\n=\n\nU\n\nr\n\n\n\n\n{\\displaystyle I=U_{r}}\n\n is independent of \n\n\n\nW\n\n\n{\\displaystyle W}\n\n. Output of the extractor is a key generated from \n\n\n\nw\n\u2190\nW\n\n\n{\\displaystyle w\\leftarrow W}\n\n with the seed \n\n\n\ni\n\u2190\nI\n\n\n{\\displaystyle i\\leftarrow I}\n\n. It behaves independent of other parts of the system with the probability of \n\n\n\n1\n\u2212\n\u03f5\n\n\n{\\displaystyle 1-\\epsilon }\n\n. Strong extractors can extract at most \n\n\n\nl\n=\nm\n\u2212\n2\nl\no\ng\n\n\n1\n\u03f5\n\n\n+\nO\n(\n1\n)\n\n\n{\\displaystyle l=m-2log{\\frac {1}{\\epsilon }}+O(1)}\n\n bits from arbitrary \n\n\n\nm\n\n\n{\\displaystyle m}\n\n-source.\nSecure sketch makes it possible to reconstruct noisy input, so if the input is \n\n\n\nw\n\n\n{\\displaystyle w}\n\nand sketch is \n\n\n\ns\n\n\n{\\displaystyle s}\n\n, given \n\n\n\ns\n\n\n{\\displaystyle s}\n\n and value \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n close to \n\n\n\nw\n\n\n{\\displaystyle w}\n\n, it is possible to recover \n\n\n\nw\n\n\n{\\displaystyle w}\n\n. But sketch \n\n\n\ns\n\n\n{\\displaystyle s}\n\n doesn't give much information about \n\n\n\nw\n\n\n{\\displaystyle w}\n\n, so it is secure. If \n\n\n\n\nM\n\n\n\n{\\displaystyle \\mathbb {M} }\n\n is a metric space with distance function dis. Secure sketch recovers string \n\n\n\nw\n\u2208\n\nM\n\n\n\n{\\displaystyle w\\in \\mathbb {M} }\n\n from any close string \n\n\n\n\nw\n\u2032\n\n\u2208\n\nM\n\n\n\n{\\displaystyle w'\\in \\mathbb {M} }\n\nwithout disclosing \n\n\n\nw\n\n\n{\\displaystyle w}\n\n.\nAn \n\n\n\n(\nm\n,\n\n\n\nm\n~\n\n\n\n,\nt\n)\n\n\n{\\displaystyle (m,{\\tilde {m}},t)}\n\n secure sketch is a pair of efficient randomized procedures (SS \u2013 Sketch, Rec \u2013 Recover) such that \u2013 (1) The sketching procedure SS on input \n\n\n\nw\n\u2208\n\nM\n\n\n\n{\\displaystyle w\\in \\mathbb {M} }\n\n returns a string \n\n\n\ns\n\u2208\n\n{\n0\n,\n1\n\n}\n\n\u2217\n\n\n\n\n\n{\\displaystyle s\\in {\\{0,1\\}^{*}}}\n\n. The recovery procedure Rec takes an element \n\n\n\n\nw\n\u2032\n\n\u2208\n\nM\n\n\n\n{\\displaystyle w'\\in \\mathbb {M} }\n\n and \n\n\n\ns\n\u2208\n\n{\n0\n,\n1\n\n}\n\n\u2217\n\n\n\n\n\n{\\displaystyle s\\in {\\{0,1\\}^{*}}}\n\n. (2) Correctness: If \n\n\n\nd\ni\ns\n(\nw\n,\n\nw\n\u2032\n\n)\n\u2264\nt\n\n\n{\\displaystyle dis(w,w')\\leq t}\n\n then \n\n\n\nR\ne\nc\n(\n\nw\n\u2032\n\n,\nS\nS\n(\nw\n)\n)\n=\nw\n\n\n{\\displaystyle Rec(w',SS(w))=w}\n\n. (3) Security: For any \n\n\n\nm\n\n\n{\\displaystyle m}\n\n-source over \n\n\n\nM\n\n\n{\\displaystyle M}\n\n, the min-entropy of \n\n\n\nW\n\n\n{\\displaystyle W}\n\n given \n\n\n\ns\n\n\n{\\displaystyle s}\n\n is high: for any \n\n\n\n(\nW\n,\nE\n)\n\n\n{\\displaystyle (W,E)}\n\n, if \n\n\n\n\n\n\n\nH\n~\n\n\n\n\n\n\u221e\n\n\n\n(\nW\n\n|\n\nE\n)\n\u2265\nm\n\n\n{\\displaystyle {\\tilde {H}}_{\\mathrm {\\infty } }(W|E)\\geq m}\n\n, then \n\n\n\n\n\n\n\nH\n~\n\n\n\n\n\n\u221e\n\n\n\n(\nW\n\n|\n\nS\nS\n(\nW\n)\n,\nE\n)\n\u2265\n\n\n\nm\n~\n\n\n\n\n\n{\\displaystyle {\\tilde {H}}_{\\mathrm {\\infty } }(W|SS(W),E)\\geq {\\tilde {m}}}\n\n.\nFuzzy extractors do not recover the original input but generate string \n\n\n\nR\n\n\n{\\displaystyle R}\n\n (which is close to uniform) from \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and its subsequent reproduction (using helper string \n\n\n\nP\n\n\n{\\displaystyle P}\n\n) given any \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n close to \n\n\n\nw\n\n\n{\\displaystyle w}\n\n. Strong extractors are a special case of fuzzy extractors when \n\n\n\nt\n\n\n{\\displaystyle t}\n\n = 0 and \n\n\n\nP\n=\nI\n\n\n{\\displaystyle P=I}\n\n.\nAn \n\n\n\n(\nm\n,\nl\n,\nt\n,\n\u03f5\n)\n\n\n{\\displaystyle (m,l,t,\\epsilon )}\n\n fuzzy extractor is a pair of efficient randomized procedures (Gen \u2013 Generate and Rep \u2013 Reproduce) such that: (1) Gen, given \n\n\n\nw\n\u2208\n\nM\n\n\n\n{\\displaystyle w\\in \\mathbb {M} }\n\n, outputs an extracted string \n\n\n\nR\n\u2208\n\n\n{\n\n0\n,\n1\n\n}\n\nl\n\n\n\n\n\n{\\displaystyle R\\in {\\mathbb {\\{} 0,1\\}^{l}}}\n\n and a helper string \n\n\n\nP\n\u2208\n\n\n{\n\n0\n,\n1\n\n}\n\n\u2217\n\n\n\n\n\n{\\displaystyle P\\in {\\mathbb {\\{} 0,1\\}^{*}}}\n\n. (2) Correctness: If \n\n\n\nd\ni\ns\n(\nw\n,\n\nw\n\u2032\n\n)\n\u2264\nt\n\n\n{\\displaystyle dis(w,w')\\leq t}\n\n and \n\n\n\n(\nR\n,\nP\n)\n\u2190\nG\ne\nn\n(\nw\n)\n\n\n{\\displaystyle (R,P)\\leftarrow Gen(w)}\n\n, then \n\n\n\nR\ne\np\n(\n\nw\n\u2032\n\n,\nP\n)\n=\nR\n\n\n{\\displaystyle Rep(w',P)=R}\n\n. (3) Security: For all m-sources \n\n\n\nW\n\n\n{\\displaystyle W}\n\n over \n\n\n\nM\n\n\n{\\displaystyle M}\n\n, the string \n\n\n\nR\n\n\n{\\displaystyle R}\n\n is nearly uniform even given \n\n\n\nP\n\n\n{\\displaystyle P}\n\n, So \n\n\n\n\n\n\n\nH\n~\n\n\n\n\n\n\u221e\n\n\n\n(\nW\n\n|\n\nE\n)\n\u2265\nm\n\n\n{\\displaystyle {\\tilde {H}}_{\\mathrm {\\infty } }(W|E)\\geq m}\n\n, then \n\n\n\n(\nR\n,\nP\n,\nE\n)\n\u2248\n(\n\nU\n\n\nl\n\n\n\n,\nP\n,\nE\n)\n\n\n{\\displaystyle (R,P,E)\\approx (U_{\\mathrm {l} },P,E)}\n\n.\nSo Fuzzy extractors output almost uniform random bits which is prerequisite for using cryptographic applications (in terms of secret keys). Since output bits are slightly non-uniform, it can decrease security, but not more than the distance \n\n\n\n\u03f5\n\n\n{\\displaystyle \\epsilon }\n\n from the uniform and as long as that distance is sufficiently small \u2013 security still remains robust.\nSecure sketches can be used to construct fuzzy extractors. Like applying SS to \n\n\n\nw\n\n\n{\\displaystyle w}\n\n to obtain \n\n\n\ns\n\n\n{\\displaystyle s}\n\n and strong extractor Ext with randomness \n\n\n\nx\n\n\n{\\displaystyle x}\n\n to \n\n\n\nw\n\n\n{\\displaystyle w}\n\n to get \n\n\n\nR\n\n\n{\\displaystyle R}\n\n. \n\n\n\n(\ns\n,\nx\n)\n\n\n{\\displaystyle (s,x)}\n\n can be stored as helper string \n\n\n\nP\n\n\n{\\displaystyle P}\n\n. \n\n\n\nR\n\n\n{\\displaystyle R}\n\n can be reproduced by \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n and \n\n\n\nP\n=\n(\ns\n,\nx\n)\n\n\n{\\displaystyle P=(s,x)}\n\n. \n\n\n\nR\ne\nc\n(\n\nw\n\u2032\n\n,\ns\n)\n\n\n{\\displaystyle Rec(w',s)}\n\n can recover \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and \n\n\n\nE\nx\nt\n(\nw\n,\nx\n)\n\n\n{\\displaystyle Ext(w,x)}\n\n can reproduce \n\n\n\nR\n\n\n{\\displaystyle R}\n\n. Following Lemma formalize this.\nAssume (SS,Rec) is an \n\n\n\n(\nM\n,\nm\n,\n\n\n\nm\n~\n\n\n\n,\nt\n)\n\n\n{\\displaystyle (M,m,{\\tilde {m}},t)}\n\n secure sketch and let Ext be an average-case \n\n\n\n(\nn\n,\n\n\n\nm\n~\n\n\n\n,\nl\n,\n\u03f5\n)\n\n\n{\\displaystyle (n,{\\tilde {m}},l,\\epsilon )}\n\n strong extractor. Then the following (Gen, Rep) is an \n\n\n\n(\nM\n,\nm\n,\nl\n,\nt\n,\n\u03f5\n)\n\n\n{\\displaystyle (M,m,l,t,\\epsilon )}\n\n fuzzy extractor: (1) Gen \n\n\n\n(\nw\n,\nr\n,\nx\n)\n:\ns\ne\nt\nP\n=\n(\nS\nS\n(\nw\n;\nr\n)\n,\nx\n)\n,\nR\n=\nE\nx\nt\n(\nw\n;\nx\n)\n,\n\n\n{\\displaystyle (w,r,x):setP=(SS(w;r),x),R=Ext(w;x),}\n\n and output \n\n\n\n(\nR\n,\nP\n)\n\n\n{\\displaystyle (R,P)}\n\n. (2) Rep \n\n\n\n(\n\nw\n\u2032\n\n,\n(\ns\n,\nx\n)\n)\n\n\n{\\displaystyle (w',(s,x))}\n\n: recover \n\n\n\nw\n=\nR\ne\nc\n(\n\nw\n\u2032\n\n,\ns\n)\n\n\n{\\displaystyle w=Rec(w',s)}\n\n and output \n\n\n\nR\n=\nE\nx\nt\n(\nw\n;\nx\n)\n\n\n{\\displaystyle R=Ext(w;x)}\n\n.\nProof: From the definition of secure sketch (Definition 2), \n\n\n\n\nH\n\n\u221e\n\n\n(\nW\n\n|\n\nS\nS\n(\nW\n)\n)\n\u2265\n\n\n\nm\n~\n\n\n\n\n\n{\\displaystyle H_{\\infty }(W|SS(W))\\geq {\\tilde {m}}}\n\n. And since Ext is an average-case \n\n\n\n(\nn\n,\nm\n,\nl\n,\n\u03f5\n)\n\n\n{\\displaystyle (n,m,l,\\epsilon )}\n\n-strong extractor. \n\n\n\nS\nD\n(\n(\nE\nx\nt\n(\nW\n;\nX\n)\n,\nS\nS\n(\nW\n)\n,\nX\n)\n,\n(\n\nU\n\nl\n\n\n,\nS\nS\n(\nW\n)\n,\nX\n)\n)\n=\nS\nD\n(\n(\nR\n,\nP\n)\n,\n(\n\nU\n\nl\n\n\n,\nP\n)\n)\n\u2264\n\u03f5\n.\n\n\n{\\displaystyle SD((Ext(W;X),SS(W),X),(U_{l},SS(W),X))=SD((R,P),(U_{l},P))\\leq \\epsilon .}\n\n\nIf (SS,Rec) is an \n\n\n\n(\nM\n,\nm\n,\n\n\n\nm\n~\n\n\n\n,\nt\n)\n\n\n{\\displaystyle (M,m,{\\tilde {m}},t)}\n\n \u2013 secure sketch and Ext is an \n\n\n\n(\nn\n,\n\n\n\nm\n~\n\n\n\n\u2212\nl\no\ng\n(\n\n\n1\n\u03b4\n\n\n)\n,\nl\n,\n\u03f5\n)\n\n\n{\\displaystyle (n,{\\tilde {m}}-log({\\frac {1}{\\delta }}),l,\\epsilon )}\n\n \u2013 strong extractor, then the above construction (Gen,Rep) is a \n\n\n\n(\nM\n,\nm\n,\nl\n,\nt\n,\n\u03f5\n+\n\u03b4\n)\n\n\n{\\displaystyle (M,m,l,t,\\epsilon +\\delta )}\n\n fuzzy extractor.\nReference paper \"Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data\" by Yevgeniy Dodis, Rafail Ostrovsky, Leonid Reyzin and Adam Smith (2008) includes many generic combinatorial bounds on secure sketches and fuzzy extractors\nDue to their error tolerant properties, a secure sketches can be treated, analyzed, and constructed like a \n\n\n\n(\nn\n,\nk\n,\nd\n\n)\n\n\nF\n\n\n\n\n\n{\\displaystyle (n,k,d)_{\\mathcal {F}}}\n\n general error correcting code or \n\n\n\n[\nn\n,\nk\n,\nd\n\n]\n\n\nF\n\n\n\n\n\n{\\displaystyle [n,k,d]_{\\mathcal {F}}}\n\n for linear codes, where \n\n\n\nn\n\n\n{\\displaystyle n}\n\n is the length of codewords, \n\n\n\nk\n\n\n{\\displaystyle k}\n\n is the length of the message to be codded, \n\n\n\nd\n\n\n{\\displaystyle d}\n\n is the distance between codewords, and \n\n\n\n\n\nF\n\n\n\n\n{\\displaystyle {\\mathcal {F}}}\n\n is the alphabet. If \n\n\n\n\n\n\nF\n\n\n\nn\n\n\n\n\n{\\displaystyle {\\mathcal {F}}^{n}}\n\n is the universe of possible words then it may be possible to find an error correcting code \n\n\n\nC\n\u2208\n\n\n\nF\n\n\n\nn\n\n\n\n\n{\\displaystyle C\\in {\\mathcal {F}}^{n}}\n\n that has a unique codeword \n\n\n\nc\n\u2208\nC\n\n\n{\\displaystyle c\\in C}\n\n for every \n\n\n\nw\n\u2208\n\n\n\nF\n\n\n\nn\n\n\n\n\n{\\displaystyle w\\in {\\mathcal {F}}^{n}}\n\n and have a Hamming distance of \n\n\n\nd\ni\n\ns\n\nH\na\nm\n\n\n(\nc\n,\nw\n)\n\u2264\n(\nd\n\u2212\n1\n)\n\n/\n\n2\n\n\n{\\displaystyle dis_{Ham}(c,w)\\leq (d-1)/2}\n\n. The first step for constructing a secure sketch is determining the type of errors that will likely occur and then choosing a distance to measure.\nWhen there is no chance of data being deleted and only being corrupted then the best measurement to use for error correction is Hamming distance. There are two common constructions for correcting Hamming errors depending on whether the code is linear or not. Both constructions start with an error correcting code that has a distance of \n\n\n\n2\nt\n+\n1\n\n\n{\\displaystyle 2t+1}\n\n where \n\n\n\n\nt\n\n\n\n{\\displaystyle {t}}\n\n is the number of tolerated errors.\nWhen using a \n\n\n\n(\nn\n,\nk\n,\n2\nt\n+\n1\n\n)\n\n\nF\n\n\n\n\n\n{\\displaystyle (n,k,2t+1)_{\\mathcal {F}}}\n\n general code, assign a uniformly random codeword \n\n\n\nc\n\u2208\nC\n\n\n{\\displaystyle c\\in C}\n\n to each \n\n\n\nw\n\n\n{\\displaystyle w}\n\n, then let \n\n\n\nS\nS\n(\nw\n)\n=\ns\n=\nw\n\u2212\nc\n\n\n{\\displaystyle SS(w)=s=w-c}\n\n which is the shift needed to change \n\n\n\nc\n\n\n{\\displaystyle c}\n\n into \n\n\n\nw\n\n\n{\\displaystyle w}\n\n. To fix errors in \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n subtract \n\n\n\ns\n\n\n{\\displaystyle s}\n\n from \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n then correct the errors in the resulting incorrect codeword to get \n\n\n\nc\n\n\n{\\displaystyle c}\n\n and finally add \n\n\n\ns\n\n\n{\\displaystyle s}\n\n to \n\n\n\nc\n\n\n{\\displaystyle c}\n\n to get \n\n\n\nw\n\n\n{\\displaystyle w}\n\n. This means \n\n\n\nR\ne\nc\n(\n\nw\n\u2032\n\n,\ns\n)\n=\ns\n+\nd\ne\nc\n(\n\nw\n\u2032\n\n\u2212\ns\n)\n=\nw\n\n\n{\\displaystyle Rec(w',s)=s+dec(w'-s)=w}\n\n. This construction can achieve the best possible tradeoff between error tolerance and entropy loss when \n\n\n\n\n\nF\n\n\n\u2265\nn\n\n\n{\\displaystyle {\\mathcal {F}}\\geq n}\n\n and a Reed\u2013Solomon code is used resulting in an entropy loss of \n\n\n\n2\nt\nlog\n\u2061\n(\n\n\nF\n\n\n)\n\n\n{\\displaystyle 2t\\log({\\mathcal {F}})}\n\n, and the only way to improve upon this is to find a code better than Reed\u2013Solomon.\nWhen using a \n\n\n\n[\nn\n,\nk\n,\n2\nt\n+\n1\n\n]\n\n\nF\n\n\n\n\n\n{\\displaystyle [n,k,2t+1]_{\\mathcal {F}}}\n\n linear code let the \n\n\n\nS\nS\n(\nw\n)\n=\ns\n\n\n{\\displaystyle SS(w)=s}\n\n be the syndrome of \n\n\n\nw\n\n\n{\\displaystyle w}\n\n. To correct \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n find a vector \n\n\n\ne\n\n\n{\\displaystyle e}\n\n such that \n\n\n\ns\ny\nn\n(\ne\n)\n=\ns\ny\nn\n(\n\nw\n\u2032\n\n)\n\u2212\ns\n\n\n{\\displaystyle syn(e)=syn(w')-s}\n\n, then \n\n\n\nw\n=\n\nw\n\u2032\n\n\u2212\ne\n\n\n{\\displaystyle w=w'-e}\n\n.\nWhen working with a very large alphabet or very long strings resulting in a very large universe \n\n\n\n\n\nU\n\n\n\n\n{\\displaystyle {\\mathcal {U}}}\n\n, it may be more efficient to treat \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n as sets and look at set differences to correct errors. To work with a large set \n\n\n\nw\n\n\n{\\displaystyle w}\n\n it is useful to look at its characteristic vector \n\n\n\n\nx\n\nw\n\n\n\n\n{\\displaystyle x_{w}}\n\n, which is a binary vector of length \n\n\n\nn\n\n\n{\\displaystyle n}\n\n that has a value of 1 when an element \n\n\n\na\n\u2208\n\n\nU\n\n\n\n\n{\\displaystyle a\\in {\\mathcal {U}}}\n\n and \n\n\n\na\n\u2208\nw\n\n\n{\\displaystyle a\\in w}\n\n, or 0 when \n\n\n\na\n\u2209\nw\n\n\n{\\displaystyle a\\notin w}\n\n. The best way to decrease the size of a secure sketch when \n\n\n\nn\n\n\n{\\displaystyle n}\n\n is large is make \n\n\n\nk\n\n\n{\\displaystyle k}\n\n large since the size is determined by \n\n\n\nn\n\u2212\nk\n\n\n{\\displaystyle n-k}\n\n. A good code to base this construction on is a \n\n\n\n[\nn\n,\nn\n\u2212\nt\n\u03b1\n,\n2\nt\n+\n1\n\n]\n\n2\n\n\n\n\n{\\displaystyle [n,n-t\\alpha ,2t+1]_{2}}\n\n BCH code where \n\n\n\nn\n=\n\n2\n\n\u03b1\n\n\n\u2212\n1\n\n\n{\\displaystyle n=2^{\\alpha }-1}\n\n and \n\n\n\nt\n\u226a\nn\n\n\n{\\displaystyle t\\ll n}\n\n so \n\n\n\nk\n\u2264\nn\n\u2212\nl\no\ng\n\n\n\n(\n\n\nn\n\nt\n\n\n\n)\n\n\n\n\n\n{\\displaystyle k\\leq n-log{n \\choose {t}}}\n\n, it is also useful that BCH codes can be decode in sub-linear time.\nLet \n\n\n\nS\nS\n(\nw\n)\n=\ns\n=\ns\ny\nn\n(\n\nx\n\nw\n\n\n)\n\n\n{\\displaystyle SS(w)=s=syn(x_{w})}\n\n. To correct \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n first find \n\n\n\nS\nS\n(\n\nw\n\u2032\n\n)\n=\n\ns\n\u2032\n\n=\ns\ny\nn\n(\n\nx\n\nw\n\n\u2032\n\n)\n\n\n{\\displaystyle SS(w')=s'=syn(x_{w}')}\n\n, then find a set v where \n\n\n\ns\ny\nn\n(\n\nx\n\nv\n\n\n)\n=\n\ns\n\u2032\n\n\u2212\ns\n\n\n{\\displaystyle syn(x_{v})=s'-s}\n\n, finally compute the symmetric difference to get \n\n\n\nR\ne\nc\n(\n\nw\n\u2032\n\n,\ns\n)\n=\n\nw\n\u2032\n\n\u25b3\nv\n=\nw\n\n\n{\\displaystyle Rec(w',s)=w'\\triangle v=w}\n\n. While this is not the only construction to use set difference it is the easiest one to use.\nWhen data can be corrupted or deleted the best measurement to use is edit distance. To make a construction based on edit distance it is easiest to start with a construction for set difference or hamming distance as an intermediate correction step and then build the edit distance construction around that.\nThere are many other types of errors and distances that can be measured which can be used to model other situations. Most of these other possible constructions are like edit distance constructions where they build upon simpler constructions.\nIt is possible to show that the error-tolerance of a secure sketch can be improved by applying a probabilistic method to error correction and only needing errors to be correctable with a high probability. This will show that it is possible to exceed the Plotkin bound which is limited to correcting \n\n\n\nn\n\n/\n\n4\n\n\n{\\displaystyle n/4}\n\n errors, and approach Shannon\u2019s bound allowing for nearly \n\n\n\nn\n\n/\n\n2\n\n\n{\\displaystyle n/2}\n\n corrections. To achieve this better error correction a less restrictive error distribution model must be used.\nFor this most restrictive model use a BSC\n\n\n\n\n\n\np\n\n\n\n\n{\\displaystyle _{p}}\n\n to create a \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n that a probability \n\n\n\np\n\n\n{\\displaystyle p}\n\n at each position in \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n that the bit received is wrong. This model can show that entropy loss is limited to \n\n\n\nn\nH\n(\np\n)\n\u2212\no\n(\nn\n)\n\n\n{\\displaystyle nH(p)-o(n)}\n\n, where \n\n\n\nH\n\n\n{\\displaystyle H}\n\n is the binary entropy function, and if min-entropy \n\n\n\nm\n\u2265\nn\n(\nH\n(\n\n\n1\n2\n\n\n\u2212\n\u03b3\n)\n)\n+\n\u03b5\n\n\n{\\displaystyle m\\geq n(H({\\frac {1}{2}}-\\gamma ))+\\varepsilon }\n\n then \n\n\n\nn\n(\n\n\n1\n2\n\n\n\u2212\n\u03b3\n)\n\n\n{\\displaystyle n({\\frac {1}{2}}-\\gamma )}\n\n errors can be tolerated, for some constant \n\n\n\n\u03b3\n>\n0\n\n\n{\\displaystyle \\gamma >0}\n\n.\nFor this model errors do not have a known distribution and can be from an adversary, the only constraints are \n\n\n\nd\ni\n\ns\n\nerr\n\n\n\u2264\nt\n\n\n{\\displaystyle dis_{\\text{err}}\\leq t}\n\n and that a corrupted word depends only on the input \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and not on the secure sketch. It can be shown for this error model that there will never be more than \n\n\n\nt\n\n\n{\\displaystyle t}\n\n errors since this model can account for all complex noise processes, meaning that Shannon\u2019s bound can be reached, to do this a random permutation is prepended to the secure sketch that will reduce entropy loss.\nThis differs from the input dependent model by having errors that depend on both the input \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and the secure sketch, and an adversary is limited to polynomial time algorithms for introducing errors. Since algorithms that can run in better than polynomial time are not currently feasible in the real world, then a positive result using this error model would guarantee that any errors can be fixed. This is the least restrictive model the only known way to approach Shannon\u2019s bound is to use list-decodable codes although this may not always be useful in practice since returning a list instead of a single codeword may not always be acceptable.\nIn general a secure system attempts to leak as little information as possible to an adversary. In the case of biometrics if information about the biometric reading is leaked the adversary may be able to learn personal information about a user. For example an adversary notices that there is a certain pattern in the helper strings that implies the ethnicity of the user. We can consider this additional information a function \n\n\n\nf\n(\nW\n)\n\n\n{\\displaystyle f(W)}\n\n. If an adversary were to learn a helper string, it must be ensured that, from this data he can not infer any data about the person from which the biometric reading was taken.\nIdeally the helper string \n\n\n\nP\n\n\n{\\displaystyle P}\n\n would reveal no information about the biometric input \n\n\n\nw\n\n\n{\\displaystyle w}\n\n. This is only possible when every subsequent biometric reading \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n is identical to the original \n\n\n\nw\n\n\n{\\displaystyle w}\n\n. In this case there is actually no need for the helper string, so it is easy to generate a string that is in no way correlated to \n\n\n\nw\n\n\n{\\displaystyle w}\n\n.\nSince it is desirable to accept biometric input \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n similar to \n\n\n\nw\n\n\n{\\displaystyle w}\n\n the helper string \n\n\n\nP\n\n\n{\\displaystyle P}\n\n must be somehow correlated. The more different \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n are allowed to be, the more correlation there will be between \n\n\n\nP\n\n\n{\\displaystyle P}\n\n and \n\n\n\nw\n\n\n{\\displaystyle w}\n\n, the more correlated they are the more information \n\n\n\nP\n\n\n{\\displaystyle P}\n\n reveals about \n\n\n\nw\n\n\n{\\displaystyle w}\n\n. We can consider this information to be a function \n\n\n\nf\n(\nW\n)\n\n\n{\\displaystyle f(W)}\n\n. The best possible solution is to make sure the adversary can't learn anything useful from the helper string.\nA probabilistic map \n\n\n\nY\n(\n)\n\n\n{\\displaystyle Y()}\n\n hides the results of functions with a small amount of leakage \n\n\n\n\u03f5\n\n\n{\\displaystyle \\epsilon }\n\n. The leakage is the difference in probability two adversaries have of guessing some function when one knows the probabilistic map and one does not. Formally:\nIf the function \n\n\n\nG\ne\nn\n(\nW\n)\n\n\n{\\displaystyle Gen(W)}\n\n is a probabilistic map, then even if an adversary knows both the helper string \n\n\n\nP\n\n\n{\\displaystyle P}\n\n and the secret string \n\n\n\nR\n\n\n{\\displaystyle R}\n\n they are only negligibly more likely figure something out about the subject as if they knew nothing. The string \n\n\n\nR\n\n\n{\\displaystyle R}\n\n is supposed to kept secret, so even if it is leaked (which should be very unlikely) the adversary can still figure out nothing useful about the subject, as long as \n\n\n\n\u03f5\n\n\n{\\displaystyle \\epsilon }\n\n is small. We can consider \n\n\n\nf\n(\nW\n)\n\n\n{\\displaystyle f(W)}\n\n to be any correlation between the biometric input and some physical characteristic of the person. Setting \n\n\n\nY\n=\nG\ne\nn\n(\nW\n)\n=\nR\n,\nP\n\n\n{\\displaystyle Y=Gen(W)=R,P}\n\n in the above equation changes it to:\nThis means that if one adversary \n\n\n\n\nA\n\n1\n\n\n\n\n{\\displaystyle A_{1}}\n\n has \n\n\n\n(\nR\n,\nP\n)\n\n\n{\\displaystyle (R,P)}\n\n and a second adversary \n\n\n\n\nA\n\n2\n\n\n\n\n{\\displaystyle A_{2}}\n\n knows nothing, their best guesses at \n\n\n\nf\n(\nW\n)\n\n\n{\\displaystyle f(W)}\n\n are only \n\n\n\n\u03f5\n\n\n{\\displaystyle \\epsilon }\n\n apart.\nUniform fuzzy extractors are a special case of fuzzy extractors, where the output \n\n\n\n(\nR\n,\nP\n)\n\n\n{\\displaystyle (R,P)}\n\n of \n\n\n\nG\ne\nn\n(\nW\n)\n\n\n{\\displaystyle Gen(W)}\n\n are negligibly different from strings picked from the uniform distribution, i.e. \n\n\n\n(\nR\n,\nP\n)\n\n\u2248\n\n\u03f5\n\n\n(\n\nU\n\n\u2113\n\n\n,\n\nU\n\n\n|\n\nP\n\n|\n\n\n\n)\n\n\n{\\displaystyle (R,P)\\approx _{\\epsilon }(U_{\\ell },U_{|P|})}\n\n\nSince secure sketches imply fuzzy extractors, constructing a uniform secure sketch allows for the easy construction of a uniform fuzzy extractor. In a uniform secure sketch the sketch procedure \n\n\n\nS\nS\n(\nw\n)\n\n\n{\\displaystyle SS(w)}\n\n is a randomness extractor \n\n\n\nE\nx\nt\n(\nw\n;\ni\n)\n\n\n{\\displaystyle Ext(w;i)}\n\n. Where \n\n\n\nw\n\n\n{\\displaystyle w}\n\n is the biometric input and \n\n\n\ni\n\n\n{\\displaystyle i}\n\n is the random seed. Since randomness extractors output a string that appears to be from a uniform distribution they hide all the information about their input.\nExtractor sketches can be used to construct \n\n\n\n(\nm\n,\nt\n,\n\u03f5\n)\n\n\n{\\displaystyle (m,t,\\epsilon )}\n\n-fuzzy perfectly one-way hash functions. When used as a hash function the input \n\n\n\nw\n\n\n{\\displaystyle w}\n\n is the object you want to hash. The \n\n\n\nP\n,\nR\n\n\n{\\displaystyle P,R}\n\n that \n\n\n\nG\ne\nn\n(\nw\n)\n\n\n{\\displaystyle Gen(w)}\n\n outputs is the hash value. If one wanted to verify that a \n\n\n\n\nw\n\u2032\n\n\n\n{\\displaystyle w'}\n\n within \n\n\n\nt\n\n\n{\\displaystyle t}\n\n from the original \n\n\n\nw\n\n\n{\\displaystyle w}\n\n, they would verify that \n\n\n\nR\ne\np\n(\n\nw\n\u2032\n\n,\nP\n)\n=\nR\n\n\n{\\displaystyle Rep(w',P)=R}\n\n. \n\n\n\n(\nm\n,\nt\n,\n\u03f5\n)\n\n\n{\\displaystyle (m,t,\\epsilon )}\n\n-fuzzy perfectly one-way hash functions are special hash functions where they accept any input with at most \n\n\n\nt\n\n\n{\\displaystyle t}\n\n errors, compared to traditional hash functions which only accept when the input matches the original exactly. Traditional cryptographic hash functions attempt to guarantee that is it is computationally infeasible to find two different inputs that hash to the same value. Fuzzy perfectly one-way hash functions make an analogous claim. They make it computationally infeasible two find two inputs, that are more than \n\n\n\nt\n\n\n{\\displaystyle t}\n\n Hamming distance apart and hash to the same value.\nAn active attack could be one where the adversary can modify the helper string \n\n\n\nP\n\n\n{\\displaystyle P}\n\n. If the adversary is able to change \n\n\n\nP\n\n\n{\\displaystyle P}\n\n to another string that is also acceptable to the reproduce function\n\n\n\nR\ne\np\n(\nW\n,\nP\n)\n\n\n{\\displaystyle Rep(W,P)}\n\n, it cause \n\n\n\nR\ne\np\n(\nW\n,\nP\n)\n\n\n{\\displaystyle Rep(W,P)}\n\n to output an incorrect secret string \n\n\n\n\n\n\nR\n~\n\n\n\n\n\n{\\displaystyle {\\tilde {R}}}\n\n. Robust fuzzy extractors solve this problem by allowing the reproduce function to fail, if a modified helper string is provided as input.\nOne method of constructing robust fuzzy extractors is to use hash functions. This construction requires two hash functions \n\n\n\n\nH\n\n1\n\n\n\n\n{\\displaystyle H_{1}}\n\n and \n\n\n\n\nH\n\n2\n\n\n\n\n{\\displaystyle H_{2}}\n\n. The \n\n\n\nG\ne\nn\n(\nW\n)\n\n\n{\\displaystyle Gen(W)}\n\n functions produces the helper string \n\n\n\nP\n\n\n{\\displaystyle P}\n\n by appending the output of a secure sketch \n\n\n\ns\n=\nS\nS\n(\nw\n)\n\n\n{\\displaystyle s=SS(w)}\n\n to the hash of both the reading \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and secure sketch \n\n\n\ns\n\n\n{\\displaystyle s}\n\n. It generates the secret string \n\n\n\nR\n\n\n{\\displaystyle R}\n\n by applying the second hash function to \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and \n\n\n\ns\n\n\n{\\displaystyle s}\n\n. Formally: \n\n\n\nG\ne\nn\n(\nw\n)\n:\ns\n=\nS\nS\n(\nw\n)\n,\nr\ne\nt\nu\nr\nn\n:\nP\n=\n(\ns\n,\n\nH\n\n1\n\n\n(\nw\n,\ns\n)\n)\n,\nR\n=\n\nH\n\n2\n\n\n(\nw\n,\ns\n)\n\n\n{\\displaystyle Gen(w):s=SS(w),return:P=(s,H_{1}(w,s)),R=H_{2}(w,s)}\n\n\nThe reproduce function \n\n\n\nR\ne\np\n(\nW\n,\nP\n)\n\n\n{\\displaystyle Rep(W,P)}\n\n also makes use of the hash functions \n\n\n\n\nH\n\n1\n\n\n\n\n{\\displaystyle H_{1}}\n\n and \n\n\n\n\nH\n\n2\n\n\n\n\n{\\displaystyle H_{2}}\n\n. In addition to verifying the biometric input is similar enough to the one recovered using the \n\n\n\nR\ne\nc\n(\nW\n,\nS\n)\n\n\n{\\displaystyle Rec(W,S)}\n\n function, it also verifies that hash in the second part of \n\n\n\nP\n\n\n{\\displaystyle P}\n\n was actually derived from \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and \n\n\n\ns\n\n\n{\\displaystyle s}\n\n. If both of those conditions are met it returns \n\n\n\nR\n\n\n{\\displaystyle R}\n\n which is itself the second hash function applied to \n\n\n\nw\n\n\n{\\displaystyle w}\n\n and \n\n\n\ns\n\n\n{\\displaystyle s}\n\n. Formally:\n\n\n\n\nR\ne\np\n(\n\nw\n\u2032\n\n,\n\n\n\nP\n~\n\n\n\n)\n:\n\n\n{\\displaystyle Rep(w',{\\tilde {P}}):}\n\n Get \n\n\n\n\n\n\ns\n~\n\n\n\n\n\n{\\displaystyle {\\tilde {s}}}\n\n and \n\n\n\n\n\n\nh\n~\n\n\n\n\n\n{\\displaystyle {\\tilde {h}}}\n\n from \n\n\n\n\n\n\nP\n~\n\n\n\n;\n\n\n\nw\n~\n\n\n\n=\nR\ne\nc\n(\n\nw\n\u2032\n\n,\n\n\n\ns\n~\n\n\n\n)\n.\n\n\n{\\displaystyle {\\tilde {P}};{\\tilde {w}}=Rec(w',{\\tilde {s}}).}\n\n If \n\n\n\n\u0394\n(\n\n\n\nw\n~\n\n\n\n,\n\nw\n\u2032\n\n)\n\u2264\nt\n\n\n{\\displaystyle \\Delta ({\\tilde {w}},w')\\leq t}\n\n and \n\n\n\n\n\n\nh\n~\n\n\n\n=\n\nH\n\n1\n\n\n(\n\n\n\nw\n~\n\n\n\n,\n\n\n\ns\n~\n\n\n\n)\n\n\n{\\displaystyle {\\tilde {h}}=H_{1}({\\tilde {w}},{\\tilde {s}})}\n\n then \n\n\n\nr\ne\nt\nu\nr\nn\n:\n\nH\n\n2\n\n\n(\n\n\n\nw\n~\n\n\n\n,\n\n\n\ns\n~\n\n\n\n)\n\n\n{\\displaystyle return:H_{2}({\\tilde {w}},{\\tilde {s}})}\n\n else \n\n\n\nr\ne\nt\nu\nr\nn\n:\nf\na\ni\nl\n\n\n{\\displaystyle return:fail}\n\n\nIf \n\n\n\nP\n\n\n{\\displaystyle P}\n\n has been tampered with it will be obvious because, \n\n\n\nR\ne\np\n\n\n{\\displaystyle Rep}\n\n will output fail with very high probability. To cause the algorithm accept a different \n\n\n\nP\n\n\n{\\displaystyle P}\n\n an adversary would have to find a \n\n\n\n\n\n\nw\n~\n\n\n\n\n\n{\\displaystyle {\\tilde {w}}}\n\n such that \n\n\n\n\nH\n\n1\n\n\n(\nw\n,\ns\n)\n=\n\nH\n\n1\n\n\n(\n\n\n\nw\n~\n\n\n\n,\n\n\n\ns\n~\n\n\n\n)\n\n\n{\\displaystyle H_{1}(w,s)=H_{1}({\\tilde {w}},{\\tilde {s}})}\n\n. Since hash function are believed to be one way functions, it is computationally infeasible to find such a \n\n\n\n\n\n\nw\n~\n\n\n\n\n\n{\\displaystyle {\\tilde {w}}}\n\n. Seeing \n\n\n\nP\n\n\n{\\displaystyle P}\n\n would provide the adversary with no useful information. Since, again, hash function are one way functions, it is computationally infeasible for the adversary to reverse the hash function and figure out \n\n\n\nw\n\n\n{\\displaystyle w}\n\n. Part of \n\n\n\nP\n\n\n{\\displaystyle P}\n\n is the secure sketch, but by definition the sketch reveals negligible information about its input. Similarly seeing \n\n\n\nR\n\n\n{\\displaystyle R}\n\n(even though it should never see it) would provide the adversary with no useful information as the adversary wouldn't be able to reverse the hash function and see the biometric input.", 
    "dbpedia_url": "http://dbpedia.org/resource/Fuzzy_extractor", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Fuzzy_extractor\n"
}
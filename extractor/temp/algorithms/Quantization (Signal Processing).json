{
    "about": "Quantization, in mathematics and digital signal processing, is the process of mapping a large set of input values to a (countable) smaller set. Rounding and truncation are typical examples of quantization processes. Quantization is involved to some degree in nearly all digital signal processing, as the process of representing a signal in digital form ordinarily involves rounding. Quantization also forms the core of essentially all lossy compression algorithms.", 
    "name": "Quantization (Signal Processing)", 
    "classification": "Digital Signal Processing", 
    "full_text": "Quantization, in mathematics and digital signal processing, is the process of mapping a large set of input values to a (countable) smaller set. Rounding and truncation are typical examples of quantization processes. Quantization is involved to some degree in nearly all digital signal processing, as the process of representing a signal in digital form ordinarily involves rounding. Quantization also forms the core of essentially all lossy compression algorithms.\nThe difference between an input value and its quantized value (such as round-off error) is referred to as quantization error. A device or algorithmic function that performs quantization is called a quantizer. An analog-to-digital converter is an example of a quantizer.\n\n\nBecause quantization is a many-to-few mapping, it is an inherently non-linear and irreversible process (i.e., because the same output value is shared by multiple input values, it is impossible in general to recover the exact input value when given only the output value).\nThe set of possible input values may be infinitely large, and may possibly be continuous and therefore uncountable (such as the set of all real numbers, or all real numbers within some limited range). The set of possible output values may be finite or countably infinite. The input and output sets involved in quantization can be defined in a rather general way. For example, vector quantization is the application of quantization to multi-dimensional (vector-valued) input data.[1]\nOutside the realm of signal processing, this category may simply be called rounding or scalar quantization. An ADC can be modeled as two processes: sampling and quantization. Sampling converts a voltage signal (function of time) into a discrete-time signal (sequence of real numbers). Quantization replaces each real number with an approximation from a finite set of discrete values (levels), which is necessary for storage and processing by numerical methods. Most commonly, these discrete values are represented as fixed-point words (either proportional to the waveform values or companded) or floating-point words. Common word-lengths are 8-bit (256 levels), 16-bit (65,536 levels), 32-bit (4.3\u00a0billion levels), and so on, though any number of quantization levels is possible (not just powers of two). Quantizing a sequence of numbers produces a sequence of quantization errors which is sometimes modeled as an additive random signal called quantization noise because of its stochastic behavior. The more levels a quantizer uses, the lower is its quantization noise power.\nIn general, both ADC processes lose some information. So discrete-valued signals are only an approximation of the continuous-valued discrete-time signal, which is itself only an approximation of the original continuous-valued continuous-time signal. But both types of approximation errors can, in theory, be made arbitrarily small by good design.\nRate\u2013distortion optimized quantization is encountered in source coding for \"lossy\" data compression algorithms, where the purpose is to manage distortion within the limits of the bit rate supported by a communication channel or storage medium. In this second setting, the amount of introduced distortion may be managed carefully by sophisticated techniques, and introducing some significant amount of distortion may be unavoidable. A quantizer designed for this purpose may be quite different and more elaborate in design than an ordinary rounding operation. It is in this domain that substantial rate\u2013distortion theory analysis is likely to be applied. However, the same concepts actually apply in both use cases.\nThe analysis of quantization involves studying the amount of data (typically measured in digits or bits or bit rate) that is used to represent the output of the quantizer, and studying the loss of precision that is introduced by the quantization process (which is referred to as the distortion). The general field of such study of rate and distortion is known as rate\u2013distortion theory.\nAs an example, rounding a real number \n\n\n\nx\n\n\n{\\displaystyle x}\n\n to the nearest integer value forms a very basic type of quantizer \u2013 a uniform one. A typical (mid-tread) uniform quantizer with a quantization step size equal to some value \n\n\n\n\u0394\n\n\n{\\displaystyle \\Delta }\n\n can be expressed as\nwhere the notation \n\n\n\n\u230a\n\u00a0\n\u230b\n\n\n{\\displaystyle \\lfloor \\ \\rfloor }\n\n or \n\n\n\nfloor\n\u2061\n(\n\u00a0\n)\n\n\n{\\displaystyle \\operatorname {floor} (\\ )}\n\n depicts the floor function. For simple rounding to the nearest integer, the step size \n\n\n\n\u0394\n\n\n{\\displaystyle \\Delta }\n\n is equal to 1. With \n\n\n\n\u0394\n=\n1\n\n\n{\\displaystyle \\Delta =1}\n\n or with \n\n\n\n\u0394\n\n\n{\\displaystyle \\Delta }\n\n equal to any other integer value, this quantizer has real-valued inputs and integer-valued outputs, although this property is not a necessity \u2013 a quantizer may also have an integer input domain and may also have non-integer output values. The essential property of a quantizer is that it has a countable set of possible output values that has fewer members than the set of possible input values. The members of the set of output values may have integer, rational, or real values (or even other possible values as well, in general \u2013 such as vector values or complex numbers).\nWhen the quantization step size is small (relative to the variation in the signal being measured), it is relatively simple to show[3][4][5][6][7][8] that the mean squared error produced by such a rounding operation will be approximately \n\n\n\n\n\u0394\n\n2\n\n\n\n/\n\n12\n\n\n{\\displaystyle \\Delta ^{2}/12}\n\n. Mean squared error is also called the quantization noise power. Adding one bit to the quantizer halves the value of \u0394, which reduces the noise power by the factor \u00bc.\u00a0 In terms of decibels, the noise power change is \u00a0\n\n\n\n\n10\n\u22c5\n\nlog\n\n10\n\n\n\u2061\n\n(\n\n\n\n1\n4\n\n\n\n)\n\n\u00a0\n\u2248\n\u00a0\n\u2212\n6\n\u00a0\n\nd\nB\n\n.\n\n\n\n{\\displaystyle \\scriptstyle 10\\cdot \\log _{10}\\left({\\tfrac {1}{4}}\\right)\\ \\approx \\ -6\\ \\mathrm {dB} .}\n\n\nBecause the set of possible output values of a quantizer is countable, any quantizer can be decomposed into two distinct stages, which can be referred to as the classification stage (or forward quantization stage) and the reconstruction stage (or inverse quantization stage), where the classification stage maps the input value to an integer quantization index \n\n\n\nk\n\n\n{\\displaystyle k}\n\n and the reconstruction stage maps the index \n\n\n\nk\n\n\n{\\displaystyle k}\n\n to the reconstruction value \n\n\n\n\ny\n\nk\n\n\n\n\n{\\displaystyle y_{k}}\n\n that is the output approximation of the input value. For the example uniform quantizer described above, the forward quantization stage can be expressed as\nand the reconstruction stage for this example quantizer is simply\nThis decomposition is useful for the design and analysis of quantization behavior, and it illustrates how the quantized data can be communicated over a communication channel \u2013 a source encoder can perform the forward quantization stage and send the index information through a communication channel (possibly applying entropy coding techniques to the quantization indices), and a decoder can perform the reconstruction stage to produce the output approximation of the original input data. In more elaborate quantization designs, both the forward and inverse quantization stages may be substantially more complex. In general, the forward quantization stage may use any function that maps the input data to the integer space of the quantization index data, and the inverse quantization stage can conceptually (or literally) be a table look-up operation to map each quantization index to a corresponding reconstruction value. This two-stage decomposition applies equally well to vector as well as scalar quantizers.\nMost uniform quantizers for signed input data can be classified as being of one of two types: mid-riser and mid-tread. The terminology is based on what happens in the region around the value 0, and uses the analogy of viewing the input-output function of the quantizer as a stairway. Mid-tread quantizers have a zero-valued reconstruction level (corresponding to a tread of a stairway), while mid-riser quantizers have a zero-valued classification threshold (corresponding to a riser of a stairway).[9]\nThe formulas for mid-tread uniform quantization are provided in the previous section.\nThe input-output formula for a mid-riser uniform quantizer is given by:\nwhere the classification rule is given by\nand the reconstruction rule is\nNote that mid-riser uniform quantizers do not have a zero output value \u2013 their minimum output magnitude is half the step size. When the input data can be modeled as a random variable with a probability density function (pdf) that is smooth and symmetric around zero, mid-riser quantizers also always produce an output entropy of at least 1 bit per sample.\nIn contrast, mid-tread quantizers do have a zero output level, and can reach arbitrarily low bit rates per sample for input distributions that are symmetric and taper off at higher magnitudes. For some applications, having a zero output signal representation or supporting low output entropy may be a necessity. In such cases, using a mid-tread uniform quantizer may be appropriate while using a mid-riser one would not be.\nIn general, a mid-riser or mid-tread quantizer may not actually be a uniform quantizer \u2013 i.e., the size of the quantizer's classification intervals may not all be the same, or the spacing between its possible output values may not all be the same. The distinguishing characteristic of a mid-riser quantizer is that it has a classification threshold value that is exactly zero, and the distinguishing characteristic of a mid-tread quantizer is that is it has a reconstruction value that is exactly zero.[9]\nAnother name for a mid-tread quantizer with symmetric behavior around 0 is dead-zone quantizer, and the classification region around the zero output value of such a quantizer is referred to as the dead zone or deadband. The dead zone can sometimes serve the same purpose as a noise gate or squelch function. Especially for compression applications, the dead-zone may be given a different width than that for the other steps. For an otherwise-uniform quantizer, the dead-zone width can be set to any value \n\n\n\nw\n\n\n{\\displaystyle w}\n\n by using the forward quantization rule[10][11][12]\nwhere the function \n\n\n\nsgn\n\n\n{\\displaystyle \\operatorname {sgn} }\n\n(\u00a0) is the sign function (also known as the signum function). The general reconstruction rule for such a dead-zone quantizer is given by\nwhere \n\n\n\n\nr\n\nk\n\n\n\n\n{\\displaystyle r_{k}}\n\n is a reconstruction offset value in the range of 0 to 1 as a fraction of the step size. Ordinarily, \n\n\n\n0\n\u2264\n\nr\n\nk\n\n\n\u2264\n\n\n\n1\n2\n\n\n\n\n\n{\\displaystyle 0\\leq r_{k}\\leq {\\tfrac {1}{2}}}\n\n when quantizing input data with a typical pdf that is symmetric around zero and reaches its peak value at zero (such as a Gaussian, Laplacian, or Generalized Gaussian pdf). Although \n\n\n\n\nr\n\nk\n\n\n\n\n{\\displaystyle r_{k}}\n\n may depend on \n\n\n\nk\n\n\n{\\displaystyle k}\n\n in general, and can be chosen to fulfill the optimality condition described below, it is often simply set to a constant, such as \n\n\n\n\n\n\n1\n2\n\n\n\n\n\n{\\displaystyle {\\tfrac {1}{2}}}\n\n. (Note that in this definition, \n\n\n\n\ny\n\n0\n\n\n=\n0\n\n\n{\\displaystyle y_{0}=0}\n\n due to the definition of the \n\n\n\nsgn\n\n\n{\\displaystyle \\operatorname {sgn} }\n\n(\u00a0) function, so \n\n\n\n\nr\n\n0\n\n\n\n\n{\\displaystyle r_{0}}\n\n has no effect.)\nA very commonly used special case (e.g., the scheme typically used in financial accounting and elementary mathematics) is to set \n\n\n\nw\n=\n\u0394\n\n\n{\\displaystyle w=\\Delta }\n\n and \n\n\n\n\nr\n\nk\n\n\n=\n\n\n\n1\n2\n\n\n\n\n\n{\\displaystyle r_{k}={\\tfrac {1}{2}}}\n\n for all \n\n\n\nk\n\n\n{\\displaystyle k}\n\n.\nOften the design of a quantizer involves supporting only a limited range of possible output values and performing clipping to limit the output to this range whenever the input exceeds the supported range. The error introduced by this clipping is referred to as overload distortion. Within the extreme limits of the supported range, the amount of spacing between the selectable output values of a quantizer is referred to as its granularity, and the error introduced by this spacing is referred to as granular distortion. It is common for the design of a quantizer to involve determining the proper balance between granular distortion and overload distortion. For a given supported number of possible output values, reducing the average granular distortion may involve increasing the average overload distortion, and vice versa. A technique for controlling the amplitude of the signal (or, equivalently, the quantization step size \n\n\n\n\u0394\n\n\n{\\displaystyle \\Delta }\n\n) to achieve the appropriate balance is the use of automatic gain control (AGC). However, in some quantizer designs, the concepts of granular error and overload error may not apply (e.g., for a quantizer with a limited range of input data or with a countably infinite set of selectable output values).\nA common assumption for the analysis of quantization error is that it affects a signal processing system in a similar manner to that of additive white noise \u2013 having negligible correlation with the signal and an approximately flat power spectral density.[4][8][13][14] The additive noise model is commonly used for the analysis of quantization error effects in digital filtering systems, and it can be very useful in such analysis. It has been shown to be a valid model in cases of high resolution quantization (small \n\n\n\n\u0394\n\n\n{\\displaystyle \\Delta }\n\n relative to the signal strength) with smooth probability density functions.[4][15] However, additive noise behaviour is not always a valid assumption, and care should be taken to avoid assuming that this model always applies. In actuality, the quantization error (for quantizers defined as described here) is deterministically related to the signal rather than being independent of it.[8]\u00a0 Thus, periodic signals can create periodic quantization noise. And in some cases it can even cause limit cycles to appear in digital signal processing systems.[14]\nOne way to ensure effective independence of the quantization error from the source signal is to perform dithered quantization (sometimes with noise shaping), which involves adding random (or pseudo-random) noise to the signal prior to quantization.[8][14] This can sometimes be beneficial for such purposes as improving the subjective quality of the result, however it can increase the total quantity of error introduced by the quantization process.\nIn the typical case, the original signal is much larger than one least significant bit (LSB). When this is the case, the quantization error is not significantly correlated with the signal, and has an approximately uniform distribution. In the rounding case, the quantization error has a mean of zero and the RMS value is the standard deviation of this distribution, given by \n\n\n\n\n\n\n1\n\n12\n\n\n\n\nL\nS\nB\n\n\u00a0\n\u2248\n\u00a0\n0.289\n\n\nL\nS\nB\n\n\n\n\n{\\displaystyle \\scriptstyle {\\frac {1}{\\sqrt {12}}}\\mathrm {LSB} \\ \\approx \\ 0.289\\,\\mathrm {LSB} }\n\n. In the truncation case the error has a non-zero mean of \n\n\n\n\n\n\n1\n2\n\n\n\nL\nS\nB\n\n\n\n\n{\\displaystyle \\scriptstyle {\\frac {1}{2}}\\mathrm {LSB} }\n\n and the RMS value is \n\n\n\n\n\n\n1\n\n3\n\n\n\n\nL\nS\nB\n\n\n\n\n{\\displaystyle \\scriptstyle {\\frac {1}{\\sqrt {3}}}\\mathrm {LSB} }\n\n. In either case, the standard deviation, as a percentage of the full signal range, changes by a factor of 2 for each 1-bit change in the number of quantizer bits. The potential signal-to-quantization-noise power ratio therefore changes by 4, or \u00a0\n\n\n\n\n10\n\u22c5\n\nlog\n\n10\n\n\n\u2061\n(\n4\n)\n\u00a0\n=\n\u00a0\n6.02\n\n\n\n{\\displaystyle \\scriptstyle 10\\cdot \\log _{10}(4)\\ =\\ 6.02}\n\n\u00a0 decibels per bit.\nAt lower amplitudes the quantization error becomes dependent on the input signal, resulting in distortion. This distortion is created after the anti-aliasing filter, and if these distortions are above 1/2 the sample rate they will alias back into the band of interest. In order to make the quantization error independent of the input signal, noise with an amplitude of 2 least significant bits is added to the signal. This slightly reduces signal to noise ratio, but, ideally, completely eliminates the distortion. It is known as dither.\nQuantization noise is a model of quantization error introduced by quantization in the analog-to-digital conversion (ADC) in telecommunication systems and signal processing. It is a rounding error between the analog input voltage to the ADC and the output digitized value. The noise is non-linear and signal-dependent. It can be modelled in several different ways.\nIn an ideal analog-to-digital converter, where the quantization error is uniformly distributed between \u22121/2 LSB and +1/2 LSB, and the signal has a uniform distribution covering all quantization levels, the Signal-to-quantization-noise ratio (SQNR) can be calculated from\nWhere Q is the number of quantization bits.\nThe most common test signals that fulfill this are full amplitude triangle waves and sawtooth waves.\nFor example, a 16-bit ADC has a maximum signal-to-noise ratio of 6.02 \u00d7 16 = 96.3\u00a0dB.\nWhen the input signal is a full-amplitude sine wave the distribution of the signal is no longer uniform, and the corresponding equation is instead\nHere, the quantization noise is once again assumed to be uniformly distributed. When the input signal has a high amplitude and a wide frequency spectrum this is the case.[16] In this case a 16-bit ADC has a maximum signal-to-noise ratio of 98.09\u00a0dB. The 1.761 difference in signal-to-noise only occurs due to the signal being a full-scale sine wave instead of a triangle/sawtooth.\nQuantization noise power can be derived from\nwhere \n\n\n\n\u03b4\n\nv\n\n\n\n{\\displaystyle \\delta \\mathrm {v} }\n\n is the voltage of the level.\n(Typical real-life values are worse than this theoretical minimum, due to the addition of dither to reduce the objectionable effects of quantization, and to imperfections of the ADC circuitry. Also see noise shaping.)\nFor complex signals in high-resolution ADCs this is an accurate model. For low-resolution ADCs, low-level signals in high-resolution ADCs, and for simple waveforms the quantization noise is not uniformly distributed, making this model inaccurate.[17] In these cases the quantization noise distribution is strongly affected by the exact amplitude of the signal.\nThe calculations above, however, assume a completely filled input channel. If this is not the case - if the input signal is small - the relative quantization distortion can be very large. To circumvent this issue, analog compressors and expanders can be used, but these introduce large amounts of distortion as well, especially if the compressor does not match the expander. The application of such compressors and expanders is also known as companding.\nA scalar quantizer, which performs a quantization operation, can ordinarily be decomposed into two stages:\nThese two stages together comprise the mathematical operation of \n\n\n\ny\n=\nQ\n(\nx\n)\n\n\n{\\displaystyle y=Q(x)}\n\n.\nEntropy coding techniques can be applied to communicate the quantization indices from a source encoder that performs the classification stage to a decoder that performs the reconstruction stage. One way to do this is to associate each quantization index \n\n\n\nk\n\n\n{\\displaystyle k}\n\n with a binary codeword \n\n\n\n\nc\n\nk\n\n\n\n\n{\\displaystyle c_{k}}\n\n. An important consideration is the number of bits used for each codeword, denoted here by \n\n\n\n\nl\ne\nn\ng\nt\nh\n\n(\n\nc\n\nk\n\n\n)\n\n\n{\\displaystyle \\mathrm {length} (c_{k})}\n\n.\nAs a result, the design of an \n\n\n\nM\n\n\n{\\displaystyle M}\n\n-level quantizer and an associated set of codewords for communicating its index values requires finding the values of \n\n\n\n{\n\nb\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\u2212\n1\n\n\n\n\n{\\displaystyle \\{b_{k}\\}_{k=1}^{M-1}}\n\n, \n\n\n\n{\n\nc\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\n\n\n\n{\\displaystyle \\{c_{k}\\}_{k=1}^{M}}\n\n and \n\n\n\n{\n\ny\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\n\n\n\n{\\displaystyle \\{y_{k}\\}_{k=1}^{M}}\n\n which optimally satisfy a selected set of design constraints such as the bit rate \n\n\n\nR\n\n\n{\\displaystyle R}\n\n and distortion \n\n\n\nD\n\n\n{\\displaystyle D}\n\n.\nAssuming that an information source \n\n\n\nS\n\n\n{\\displaystyle S}\n\n produces random variables \n\n\n\nX\n\n\n{\\displaystyle X}\n\n with an associated probability density function \n\n\n\nf\n(\nx\n)\n\n\n{\\displaystyle f(x)}\n\n, the probability \n\n\n\n\np\n\nk\n\n\n\n\n{\\displaystyle p_{k}}\n\n that the random variable falls within a particular quantization interval \n\n\n\n\nI\n\nk\n\n\n\n\n{\\displaystyle I_{k}}\n\n is given by\nThe resulting bit rate \n\n\n\nR\n\n\n{\\displaystyle R}\n\n, in units of average bits per quantized value, for this quantizer can be derived as follows:\nIf it is assumed that distortion is measured by mean squared error, the distortion D, is given by:\nNote that other distortion measures can also be considered, although mean squared error is a popular one.\nA key observation is that rate \n\n\n\nR\n\n\n{\\displaystyle R}\n\n depends on the decision boundaries \n\n\n\n{\n\nb\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\u2212\n1\n\n\n\n\n{\\displaystyle \\{b_{k}\\}_{k=1}^{M-1}}\n\n and the codeword lengths \n\n\n\n{\n\nl\ne\nn\ng\nt\nh\n\n(\n\nc\n\nk\n\n\n)\n\n}\n\nk\n=\n1\n\n\nM\n\n\n\n\n{\\displaystyle \\{\\mathrm {length} (c_{k})\\}_{k=1}^{M}}\n\n, whereas the distortion \n\n\n\nD\n\n\n{\\displaystyle D}\n\n depends on the decision boundaries \n\n\n\n{\n\nb\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\u2212\n1\n\n\n\n\n{\\displaystyle \\{b_{k}\\}_{k=1}^{M-1}}\n\n and the reconstruction levels \n\n\n\n{\n\ny\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\n\n\n\n{\\displaystyle \\{y_{k}\\}_{k=1}^{M}}\n\n.\nAfter defining these two performance metrics for the quantizer, a typical Rate\u2013Distortion formulation for a quantizer design problem can be expressed in one of two ways:\nOften the solution to these problems can be equivalently (or approximately) expressed and solved by converting the formulation to the unconstrained problem \n\n\n\nmin\n\n{\nD\n+\n\u03bb\n\u22c5\nR\n}\n\n\n\n{\\displaystyle \\min \\left\\{D+\\lambda \\cdot R\\right\\}}\n\n where the Lagrange multiplier \n\n\n\n\u03bb\n\n\n{\\displaystyle \\lambda }\n\n is a non-negative constant that establishes the appropriate balance between rate and distortion. Solving the unconstrained problem is equivalent to finding a point on the convex hull of the family of solutions to an equivalent constrained formulation of the problem. However, finding a solution \u2013 especially a closed-form solution \u2013 to any of these three problem formulations can be difficult. Solutions that do not require multi-dimensional iterative optimization techniques have been published for only three probability distribution functions: the uniform,[18] exponential,[12] and Laplacian[12] distributions. Iterative optimization approaches can be used to find solutions in other cases.[8][19][20]\nNote that the reconstruction values \n\n\n\n{\n\ny\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\n\n\n\n{\\displaystyle \\{y_{k}\\}_{k=1}^{M}}\n\n affect only the distortion \u2013 they do not affect the bit rate \u2013 and that each individual \n\n\n\n\ny\n\nk\n\n\n\n\n{\\displaystyle y_{k}}\n\n makes a separate contribution \n\n\n\n\nd\n\nk\n\n\n\n\n{\\displaystyle d_{k}}\n\n to the total distortion as shown below:\nwhere\nThis observation can be used to ease the analysis \u2013 given the set of \n\n\n\n{\n\nb\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\u2212\n1\n\n\n\n\n{\\displaystyle \\{b_{k}\\}_{k=1}^{M-1}}\n\n values, the value of each \n\n\n\n\ny\n\nk\n\n\n\n\n{\\displaystyle y_{k}}\n\n can be optimized separately to minimize its contribution to the distortion \n\n\n\nD\n\n\n{\\displaystyle D}\n\n.\nFor the mean-square error distortion criterion, it can be easily shown that the optimal set of reconstruction values \n\n\n\n{\n\ny\n\nk\n\n\n\u2217\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\n\n\n\n{\\displaystyle \\{y_{k}^{*}\\}_{k=1}^{M}}\n\n is given by setting the reconstruction value \n\n\n\n\ny\n\nk\n\n\n\n\n{\\displaystyle y_{k}}\n\n within each interval \n\n\n\n\nI\n\nk\n\n\n\n\n{\\displaystyle I_{k}}\n\n to the conditional expected value (also referred to as the centroid) within the interval, as given by:\nThe use of sufficiently well-designed entropy coding techniques can result in the use of a bit rate that is close to the true information content of the indices \n\n\n\n{\nk\n\n}\n\nk\n=\n1\n\n\nM\n\n\n\n\n{\\displaystyle \\{k\\}_{k=1}^{M}}\n\n, such that effectively\nand therefore\nThe use of this approximation can allow the entropy coding design problem to be separated from the design of the quantizer itself. Modern entropy coding techniques such as arithmetic coding can achieve bit rates that are very close to the true entropy of a source, given a set of known (or adaptively estimated) probabilities \n\n\n\n{\n\np\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\n\n\n\n{\\displaystyle \\{p_{k}\\}_{k=1}^{M}}\n\n.\nIn some designs, rather than optimizing for a particular number of classification regions \n\n\n\nM\n\n\n{\\displaystyle M}\n\n, the quantizer design problem may include optimization of the value of \n\n\n\nM\n\n\n{\\displaystyle M}\n\n as well. For some probabilistic source models, the best performance may be achieved when \n\n\n\nM\n\n\n{\\displaystyle M}\n\n approaches infinity.\nIn the above formulation, if the bit rate constraint is neglected by setting \n\n\n\n\u03bb\n\n\n{\\displaystyle \\lambda }\n\n equal to 0, or equivalently if it is assumed that a fixed-length code (FLC) will be used to represent the quantized data instead of a variable-length code (or some other entropy coding technology such as arithmetic coding that is better than an FLC in the rate\u2013distortion sense), the optimization problem reduces to minimization of distortion \n\n\n\nD\n\n\n{\\displaystyle D}\n\n alone.\nThe indices produced by an \n\n\n\nM\n\n\n{\\displaystyle M}\n\n-level quantizer can be coded using a fixed-length code using \n\n\n\nR\n=\n\u2308\n\nlog\n\n2\n\n\n\u2061\nM\n\u2309\n\n\n{\\displaystyle R=\\lceil \\log _{2}M\\rceil }\n\n bits/symbol. For example when \n\n\n\nM\n=\n\n\n{\\displaystyle M=}\n\n256 levels, the FLC bit rate \n\n\n\nR\n\n\n{\\displaystyle R}\n\n is 8 bits/symbol. For this reason, such a quantizer has sometimes been called an 8-bit quantizer. However using an FLC eliminates the compression improvement that can be obtained by use of better entropy coding.\nAssuming an FLC with \n\n\n\nM\n\n\n{\\displaystyle M}\n\n levels, the Rate\u2013Distortion minimization problem can be reduced to distortion minimization alone. The reduced problem can be stated as follows: given a source \n\n\n\nX\n\n\n{\\displaystyle X}\n\n with pdf \n\n\n\nf\n(\nx\n)\n\n\n{\\displaystyle f(x)}\n\n and the constraint that the quantizer must use only \n\n\n\nM\n\n\n{\\displaystyle M}\n\n classification regions, find the decision boundaries \n\n\n\n{\n\nb\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\u2212\n1\n\n\n\n\n{\\displaystyle \\{b_{k}\\}_{k=1}^{M-1}}\n\n and reconstruction levels \n\n\n\n{\n\ny\n\nk\n\n\n\n}\n\nk\n=\n1\n\n\nM\n\n\n\n\n{\\displaystyle \\{y_{k}\\}_{k=1}^{M}}\n\n to minimize the resulting distortion\nFinding an optimal solution to the above problem results in a quantizer sometimes called a MMSQE (minimum mean-square quantization error) solution, and the resulting pdf-optimized (non-uniform) quantizer is referred to as a Lloyd\u2013Max quantizer, named after two people who independently developed iterative methods[8][21][22] to solve the two sets of simultaneous equations resulting from \n\n\n\n\n\u2202\nD\n\n/\n\n\u2202\n\nb\n\nk\n\n\n\n=\n0\n\n\n{\\displaystyle {\\partial D/\\partial b_{k}}=0}\n\n and \n\n\n\n\n\u2202\nD\n\n/\n\n\u2202\n\ny\n\nk\n\n\n\n=\n0\n\n\n{\\displaystyle {\\partial D/\\partial y_{k}}=0}\n\n, as follows:\nwhich places each threshold at the midpoint between each pair of reconstruction values, and\nwhich places each reconstruction value at the centroid (conditional expected value) of its associated classification interval.\nLloyd's Method I algorithm, originally described in 1957, can be generalized in a straightforward way for application to vector data. This generalization results in the Linde\u2013Buzo\u2013Gray (LBG) or k-means classifier optimization methods. Moreover, the technique can be further generalized in a straightforward way to also include an entropy constraint for vector data.[23]\nThe Lloyd\u2013Max quantizer is actually a uniform quantizer when the input pdf is uniformly distributed over the range \n\n\n\n[\n\ny\n\n1\n\n\n\u2212\n\u0394\n\n/\n\n2\n,\n\u00a0\n\ny\n\nM\n\n\n+\n\u0394\n\n/\n\n2\n)\n\n\n{\\displaystyle [y_{1}-\\Delta /2,~y_{M}+\\Delta /2)}\n\n. However, for a source that does not have a uniform distribution, the minimum-distortion quantizer may not be a uniform quantizer.\nThe analysis of a uniform quantizer applied to a uniformly distributed source can be summarized in what follows:\nA symmetric source X can be modelled with \n\n\n\nf\n(\nx\n)\n=\n\n\n1\n\n2\n\nX\n\nm\na\nx\n\n\n\n\n\n\n\n{\\displaystyle f(x)={\\frac {1}{2X_{max}}}}\n\n, for \n\n\n\nx\n\u2208\n[\n\u2212\n\nX\n\nm\na\nx\n\n\n,\n\nX\n\nm\na\nx\n\n\n]\n\n\n{\\displaystyle x\\in [-X_{max},X_{max}]}\n\n and 0 elsewhere. The step size \n\n\n\n\u0394\n=\n\n\n\n2\n\nX\n\nm\na\nx\n\n\n\nM\n\n\n\n\n{\\displaystyle \\Delta ={\\frac {2X_{max}}{M}}}\n\n and the signal to quantization noise ratio (SQNR) of the quantizer is\nFor a fixed-length code using \n\n\n\nN\n\n\n{\\displaystyle N}\n\n bits, \n\n\n\nM\n=\n\n2\n\nN\n\n\n\n\n{\\displaystyle M=2^{N}}\n\n, resulting in \n\n\n\n\n\nS\nQ\nN\nR\n\n\n=\n20\n\nlog\n\n10\n\n\n\u2061\n\n\n2\n\nN\n\n\n\n=\nN\n\u22c5\n(\n20\n\nlog\n\n10\n\n\n\u2061\n2\n)\n=\nN\n\u22c5\n6.0206\n\n\n\nd\nB\n\n\n\n\n{\\displaystyle {\\rm {SQNR}}=20\\log _{10}{2^{N}}=N\\cdot (20\\log _{10}2)=N\\cdot 6.0206\\,{\\rm {dB}}}\n\n,\nor approximately 6\u00a0dB per bit. For example, for \n\n\n\nN\n\n\n{\\displaystyle N}\n\n=8 bits, \n\n\n\nM\n\n\n{\\displaystyle M}\n\n=256 levels and SQNR = 8*6 = 48\u00a0dB; and for \n\n\n\nN\n\n\n{\\displaystyle N}\n\n=16 bits, \n\n\n\nM\n\n\n{\\displaystyle M}\n\n=65536 and SQNR = 16*6 = 96\u00a0dB. The property of 6\u00a0dB improvement in SQNR for each extra bit used in quantization is a well-known figure of merit. However, it must be used with care: this derivation is only for a uniform quantizer applied to a uniform source.\nFor other source pdfs and other quantizer designs, the SQNR may be somewhat different from that predicted by 6\u00a0dB/bit, depending on the type of pdf, the type of source, the type of quantizer, and the bit rate range of operation.\nHowever, it is common to assume that for many sources, the slope of a quantizer SQNR function can be approximated as 6\u00a0dB/bit when operating at a sufficiently high bit rate. At asymptotically high bit rates, cutting the step size in half increases the bit rate by approximately 1 bit per sample (because 1 bit is needed to indicate whether the value is in the left or right half of the prior double-sized interval) and reduces the mean squared error by a factor of 4 (i.e., 6\u00a0dB) based on the \n\n\n\n\n\u0394\n\n2\n\n\n\n/\n\n12\n\n\n{\\displaystyle \\Delta ^{2}/12}\n\n approximation.\nAt asymptotically high bit rates, the 6\u00a0dB/bit approximation is supported for many source pdfs by rigorous theoretical analysis.[4][5][7][8] Moreover, the structure of the optimal scalar quantizer (in the rate\u2013distortion sense) approaches that of a uniform quantizer under these conditions.[7][8]\nMany physical quantities are actually quantized by physical entities. Examples of fields where this limitation applies include electronics (due to electrons), optics (due to photons), biology (due to DNA), physics (due to Planck limits) and chemistry (due to molecules). This is sometimes known as the \"quantum noise limit\" of systems in those fields. This is a different manifestation of \"quantization error,\" in which theoretical models may be analog but physically occurs digitally. Around the quantum limit, the distinction between analog and digital quantities vanishes.[citation needed]", 
    "dbpedia_url": "http://dbpedia.org/resource/Quantization_(signal_processing)", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Quantization_(signal_processing)\n"
}
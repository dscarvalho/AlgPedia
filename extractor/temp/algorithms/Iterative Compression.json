{
    "about": "In computer science, iterative compression is an algorithmic technique for the design of fixed-parameter tractable algorithms, in which one element (such as a vertex of a graph) is added to the problem in each step, and a small solution for the problem prior to the addition is used to help find a small solution to the problem after the step.", 
    "name": "Iterative Compression", 
    "classification": "Graph Algorithms", 
    "full_text": "In computer science, iterative compression is an algorithmic technique for the design of fixed-parameter tractable algorithms, in which one element (such as a vertex of a graph) is added to the problem in each step, and a small solution for the problem prior to the addition is used to help find a small solution to the problem after the step.\nThe technique was invented by Reed, Smith and Vetta[1] to show that the problem odd cycle transversal was solvable in time O(3k\u00a0kmn), for a graph with n vertices, m edges, and odd cycle traversal number k. Odd cycle transversal is the problem of finding the smallest set of vertices of a graph that include at least one vertex from every odd cycle; its parameterized complexity was a longstanding open question.[2][3] This technique later proved very useful in showing fixed-parameter tractability results. It is now considered to be one of the fundamental techniques in the area of parameterized algorithmics.\nIterative compression has been used successfully in many problems, for instance odd cycle transversal (see below) and edge bipartization, feedback vertex set, cluster vertex deletion and directed feedback vertex set.[4] It has also been used successfully for exact exponential time algorithms for independent set.[5]\n\n\nIterative compression applies, for instance, to parameterized graph problems whose inputs are a graph G = (V,E) and a natural number k, and where the problem is to test the existence of a solution (a set of vertices) of size \u2264 k. Suppose that the problem is closed under induced subgraphs (if a solution of size \u2264 k exists in a given graph, then a solution of this size or smaller also exists in every induced subgraph) and that there exists an efficient subroutine that determines whether a solution Y of size k\u00a0+\u00a01 can be compressed to a smaller solution of size k.\nIf these assumptions are met, then the problem can be solved by adding vertices one at a time to an induced subgraph, and finding the solution to the induced subgraph, as follows:\nThis algorithm calls the compression subroutine a linear number of times. Therefore, if the compression variant is solvable in fixed-parameter tractable time, i.e., f(k)\u00a0\u00b7\u00a0nc for some constant c, then the iterative compression procedure solving the entire problem runs in f(k)\u00a0\u00b7\u00a0nc+1 time. The same technique can be applied to finding sets of edges for graph properties closed under subgraphs (rather than induced subgraph), or for other properties beyond graph theory. When the value of the parameter k is unknown, it can be found by using an outer level of exponential search or sequential search for the optimal choice of k, with each step of the search based on the same iterative compression algorithm.\nIn their original paper Reed et al. showed how to make a graph bipartite by deleting at most k vertices in time O(3k\u00a0kmn). Later, a simpler algorithm was given, also using iterative compression, by Lokshstanov, Saurabh and Sikdar.[6] In order to compress a deletion set Y of size k + 1 to a deletion set X of size k, their algorithm tests all of the 3k+1 partitions of Y into three subsets: the subset of Y that belongs to the new deletion set, and the two subsets of Y that belong to the two sides of the bipartite graph that remains after deleting X. Once these three sets have been selected, the remaining vertices of a deletion set X (if it exists) can be found from them by applying a max-flow min-cut algorithm.\nVertex cover is another example for which iterative compression can be employed. In the vertex cover problem, a graph G\u00a0=\u00a0(V,E) and a natural number k are taken as inputs and the algorithm must decide whether there exists a set X of k vertices such that every edge is incident to a vertex in X. In the compression variant of the problem, the input is a set Y of k\u00a0+\u00a01 vertices that are incident to all edges of the graph, and the algorithm must find a set X of size k with the same property, if it exists. One way to do this is to test all 2k + 1 choices of which subset of Y is to be removed from the cover and reintroduced back into the graph. Such a choice can only work if no two removed vertices are adjacent, and for each such choice, the subroutine must include in the cover all the vertices outside Y that are incident to an edge that becomes uncovered by this removal. Using this subroutine in an iterative compression algorithm gives a simple O(2k\u00a0n2) algorithm for vertex cover.", 
    "dbpedia_url": "http://dbpedia.org/resource/Iterative_compression", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Iterative_compression\n"
}
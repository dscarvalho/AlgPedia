{
    "about": "A sorting algorithm falls into the adaptive sort family if it takes advantage of existing order in its input. It benefits from the presortedness in the input sequence \u2013 or a limited amount of disorder for various definitions of measures of disorder \u2013 and sorts faster. Adaptive sorting is usually performed by modifying existing sorting algorithms.", 
    "name": "Adaptive Sort", 
    "classification": "Sorting Algorithms", 
    "full_text": "A sorting algorithm falls into the adaptive sort family if it takes advantage of existing order in its input. It benefits from the presortedness in the input sequence \u2013 or a limited amount of disorder for various definitions of measures of disorder \u2013 and sorts faster. Adaptive sorting is usually performed by modifying existing sorting algorithms.\n\n\nComparison-based sorting algorithms have traditionally dealt with achieving an optimal bound of O(n log n) when dealing with time complexity. Adaptive sort takes advantage of the existing order of the input to try to achieve better times, so that the time taken by the algorithm to sort is a smoothly growing function of the size of the sequence and the disorder in the sequence. In other words, the more presorted the input is, the faster it should be sorted.\nThis is an attractive algorithm because nearly sorted sequences are common in practice. Thus, the performance of existing sort algorithms can be improved by taking into account the existing order in the input.\nNote that the most worst-case sorting algorithms that do optimally well in the worst-case, notably heap sort and merge sort, do not take existing order within their input into account, although this deficiency is easily rectified in the case of merge sort by checking if left.last_item \u2264 right.first_item, in which case a merge operation may be replaced by simple concatenation \u2013 a modification that is well within the scope of making an algorithm adaptive.\nA classic example of an adaptive sorting algorithm is Straight Insertion Sort. In this sorting algorithm, we scan the input from left to right, repeatedly finding the position of the current item, and insert it into an array of previously sorted items.\nIn pseudo-code form, the Straight Insertion Sort algorithm could look something like this (array X is zero-based):\nThe performance of this algorithm can be described in terms of the number of inversions in the input, and then T(n) will be roughly equal to I(A) + (n - 1), where I(A) is the number of Inversions. Using this measure of presortedness \u2013 being relative to the number of inversions \u2013 Straight Insertion Sort takes less time to sort the closer it is to being sorted.\nOther examples of adaptive sorting algorithms are adaptive heap sort, adaptive merge sort, patience sort,[1] smoothsort, splaysort and Timsort.[1]", 
    "dbpedia_url": "http://dbpedia.org/resource/Adaptive_sort", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Adaptive_sort\n"
}
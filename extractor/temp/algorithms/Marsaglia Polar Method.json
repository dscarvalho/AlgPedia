{
    "about": "The polar method (attributed to George Marsaglia, 1964[1]) is a pseudo-random number sampling method for generating a pair of independent standard normal random variables.[2] While it is superior to the Box\u2013Muller transform,[3][4] the Ziggurat algorithm is even more efficient.[5]", 
    "name": "Marsaglia Polar Method", 
    "classification": "Pseudorandom Number Generators", 
    "full_text": "The polar method (attributed to George Marsaglia, 1964[1]) is a pseudo-random number sampling method for generating a pair of independent standard normal random variables.[2] While it is superior to the Box\u2013Muller transform,[3][4] the Ziggurat algorithm is even more efficient.[5]\nStandard normal random variables are frequently used in computer science, computational statistics, and in particular, in applications of the Monte Carlo method.\nThe polar method works by choosing random points (x,\u00a0y) in the square \u22121\u00a0<\u00a0x\u00a0<\u00a01, \u22121\u00a0<\u00a0y\u00a0<\u00a01 until\nand then returning the required pair of normal random variables as\nor, equivalently,\nwhere \n\n\n\nx\n\n/\n\n\n\ns\n\n\n\n\n{\\displaystyle x/{\\sqrt {s}}}\n\n and \n\n\n\ny\n\n/\n\n\n\ns\n\n\n\n\n{\\displaystyle y/{\\sqrt {s}}}\n\n represent the cosine and sine of the angle that the vector (x, y) makes with x axis.\n\n\nThe underlying theory may be summarized as follows:\nIf u is uniformly distributed in the interval 0\u00a0\u2264\u00a0u\u00a0<\u00a01, then the point (cos(2\u03c0u),\u00a0sin(2\u03c0u)) is uniformly distributed on the unit circumference x2\u00a0+\u00a0y2\u00a0=\u00a01, and multiplying that point by an independent random variable \u03c1 whose distribution is\nwill produce a point\nwhose coordinates are jointly distributed as two independent standard normal random variables.\nThis idea dates back to Laplace, whom Gauss credits with finding the above\nby taking the square root of\nThe transformation to polar coordinates makes evident that \u03b8 is uniformly distributed (constant density) from 0 to 2\u03c0, and that the radial distance r has density\n(r2 has the appropriate chi square distribution.)\nThis method of producing a pair of independent standard normal variates by radially projecting a random point on the unit circumference to a distance given by the square root of a chi-square-2 variate is called the polar method for generating a pair of normal random variables,\nA direct application of this idea,\nis called the Box Muller transform, in which the chi variate is usually generated as\nbut that transform requires logarithm, square root, sine and cosine functions. On some processors, the cosine and sine of the same argument can be calculated in parallel using a single instruction.[6] Notably for Intel-based machines, one can use fsincos assembler instruction or the expi instruction (available e.g. in D), to calculate complex\nand just separate the real and imaginary parts.\nIn contrast, the polar method here removes the need to calculate a cosine and sine. Instead, by solving for a point on the unit circle, these two functions can be replaced with the x and y coordinates normalized to the \n\n\n\n\n\n\nx\n\n2\n\n\n+\n\ny\n\n2\n\n\n\n\n\n\n{\\displaystyle {\\sqrt {x^{2}+y^{2}}}}\n\n radius. In particular, a random point (x,\u00a0y) inside the unit circle is projected onto the unit circumference by setting s2\u00a0=\u00a0x2\u00a0+\u00a0y2 and forming the point\nwhich is a faster procedure than calculating the cosine and sine. Some researchers argue that the conditional if instruction (for rejecting a point outside of the unit circle), can make programs slower on modern processors equipped with pipelining and branch prediction.[7] Also this procedure requires about 27% more evaluations of the underlying random number generator (only \n\n\n\n\u03c0\n\n/\n\n4\n\u2248\n79\n%\n\n\n{\\displaystyle \\pi /4\\approx 79\\%}\n\n of generated points lie inside of unit circle).\nThat random point on the circumference is then radially projected the required random distance by means of\nusing the same s because that s is independent of the random point on the circumference and is itself uniformly distributed from 0 to\u00a01.\nSimple implementation in Java using the mean and standard deviation:\nAn implementation, not thread safe, in C++ using the mean and standard deviation:", 
    "dbpedia_url": "http://dbpedia.org/resource/Marsaglia_polar_method", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Marsaglia_polar_method\n"
}
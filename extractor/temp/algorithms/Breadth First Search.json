{
    "about": "Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'[1]) and explores the neighbor nodes first, before moving to the next level neighbors.", 
    "classification": "Graph Algorithms", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Breadth-first_search\n", 
    "full_text": "Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key'[1]) and explores the neighbor nodes first, before moving to the next level neighbors.\nBFS was invented in the late 1950s by E. F. Moore, who used it to find the shortest path out of a maze,[2] and discovered independently by C. Y. Lee as a wire routing algorithm (published 1961).[3][4]\n\n\nInput: A graph Graph and a starting vertex root of Graph\nOutput: Goal state. The parent links trace the shortest path back to root\nA non-recursive implementation of breadth-first search:\nThis non-recursive implementation is similar to the non-recursive implementation of depth-first search, but differs from it in two ways:\nThe Q queue contains the frontier along which the algorithm is currently searching.\nThe S set is used to track which vertices have been visited. At the beginning of the algorithm, the set is empty. At the end of the algorithm, it contains all vertices with a distance from root less than the goal.\nThe parent attribute of each vertex is useful for accessing the nodes in a shortest path, for example by backtracking from the destination node up to the starting node, once the BFS has been run, and the predecessors nodes have been set.\nThe NIL is just a symbol that represents the absence of something, in this case it represents the absence of a parent (or predecessor) node; sometimes instead of the word NIL, words such as null, none or nothing can also be used.\nNote that the word node is usually interchangeable with the word vertex.\nBreadth-first search produces a so-called breadth first tree. You can see how a breadth first tree looks in the following example.\nThe following is an example of the breadth-first tree obtained by running a BFS starting from Frankfurt:\nThe time complexity can be expressed as \n\n\n\nO\n(\n\n|\n\nV\n\n|\n\n+\n\n|\n\nE\n\n|\n\n)\n\n\n{\\displaystyle O(|V|+|E|)}\n\n,[5] since every vertex and every edge will be explored in the worst case. \n\n\n\n\n|\n\nV\n\n|\n\n\n\n{\\displaystyle |V|}\n\n is the number of vertices and \n\n\n\n\n|\n\nE\n\n|\n\n\n\n{\\displaystyle |E|}\n\n is the number of edges in the graph. Note that \n\n\n\nO\n(\n\n|\n\nE\n\n|\n\n)\n\n\n{\\displaystyle O(|E|)}\n\n may vary between \n\n\n\nO\n(\n1\n)\n\n\n{\\displaystyle O(1)}\n\n and \n\n\n\nO\n(\n\n|\n\nV\n\n\n|\n\n\n2\n\n\n)\n\n\n{\\displaystyle O(|V|^{2})}\n\n, depending on how sparse the input graph is.\nWhen the number of vertices in the graph is known ahead of time, and additional data structures are used to determine which vertices have already been added to the queue, the space complexity can be expressed as \n\n\n\nO\n(\n\n|\n\nV\n\n|\n\n)\n\n\n{\\displaystyle O(|V|)}\n\n, where \n\n\n\n\n|\n\nV\n\n|\n\n\n\n{\\displaystyle |V|}\n\n is the cardinality of the set of vertices (as said before). If the graph is represented by an adjacency list it occupies \n\n\n\n\u0398\n(\n\n|\n\nV\n\n|\n\n+\n\n|\n\nE\n\n|\n\n)\n\n\n{\\displaystyle \\Theta (|V|+|E|)}\n\n[6] space in memory, while an adjacency matrix representation occupies \n\n\n\n\u0398\n(\n\n|\n\nV\n\n\n|\n\n\n2\n\n\n)\n\n\n{\\displaystyle \\Theta (|V|^{2})}\n\n.[7]\nWhen working with graphs that are too large to store explicitly (or infinite), it is more practical to describe the complexity of breadth-first search in different terms: to find the nodes that are at distance d from the start node (measured in number of edge traversals), BFS takes O(bd + 1) time and memory, where b is the \"branching factor\" of the graph (the average out-degree).[8]:81\nIn the analysis of algorithms, the input to breadth-first search is assumed to be a finite graph, represented explicitly as an adjacency list or similar representation. However, in the application of graph traversal methods in artificial intelligence the input may be an implicit representation of an infinite graph. In this context, a search method is described as being complete if it is guaranteed to find a goal state if one exists. Breadth-first search is complete, but depth-first search is not. When applied to infinite graphs represented implicitly, breadth-first search will eventually find the goal state, but depth-first search may get lost in parts of the graph that have no goal state and never return.[9]\nAn enumeration of the vertices of a graph is said to be a BFS ordering if it is the possible output of the application of BFS to this graph.\nLet \n\n\n\nG\n=\n(\nV\n,\nE\n)\n\n\n{\\displaystyle G=(V,E)}\n\n be a graph with \n\n\n\nn\n\n\n{\\displaystyle n}\n\n vertices. Recall that \n\n\n\nN\n(\nv\n)\n\n\n{\\displaystyle N(v)}\n\n is the set of neighbors of \n\n\n\nv\n\n\n{\\displaystyle v}\n\n. For \n\n\n\n\u03c3\n=\n(\n\nv\n\n1\n\n\n,\n\u2026\n,\n\nv\n\nm\n\n\n)\n\n\n{\\displaystyle \\sigma =(v_{1},\\dots ,v_{m})}\n\n be a list of distinct elements of \n\n\n\nV\n\n\n{\\displaystyle V}\n\n, for \n\n\n\nv\n\u2208\nV\n\u2216\n{\n\nv\n\n1\n\n\n,\n\u2026\n,\n\nv\n\nm\n\n\n}\n\n\n{\\displaystyle v\\in V\\setminus \\{v_{1},\\dots ,v_{m}\\}}\n\n, let \n\n\n\n\n\u03bd\n\n\u03c3\n\n\n(\nv\n)\n\n\n{\\displaystyle \\nu _{\\sigma }(v)}\n\n be the least \n\n\n\ni\n\n\n{\\displaystyle i}\n\n such that \n\n\n\n\nv\n\ni\n\n\n\n\n{\\displaystyle v_{i}}\n\n is a neighbor of \n\n\n\nv\n\n\n{\\displaystyle v}\n\n, if such a \n\n\n\ni\n\n\n{\\displaystyle i}\n\n exists, and be \n\n\n\n\u221e\n\n\n{\\displaystyle \\infty }\n\n otherwise.\nLet \n\n\n\n\u03c3\n=\n(\n\nv\n\n1\n\n\n,\n\u2026\n,\n\nv\n\nn\n\n\n)\n\n\n{\\displaystyle \\sigma =(v_{1},\\dots ,v_{n})}\n\n be an enumeration of the vertices of \n\n\n\nV\n\n\n{\\displaystyle V}\n\n. The enumeration \n\n\n\n\u03c3\n\n\n{\\displaystyle \\sigma }\n\n is said to be a BFS ordering (with source \n\n\n\n\nv\n\n1\n\n\n\n\n{\\displaystyle v_{1}}\n\n) if, for all \n\n\n\n1\n<\ni\n\u2264\nn\n\n\n{\\displaystyle 1<i\\leq n}\n\n, \n\n\n\n\nv\n\ni\n\n\n\n\n{\\displaystyle v_{i}}\n\n is the vertex \n\n\n\nw\n\u2208\nV\n\u2216\n{\n\nv\n\n1\n\n\n,\n\u2026\n,\n\nv\n\ni\n\n\n\u2212\n1\n}\n\n\n{\\displaystyle w\\in V\\setminus \\{v_{1},\\dots ,v_{i}-1\\}}\n\n such that \n\n\n\n\n\u03bd\n\n(\n\nv\n\n1\n\n\n,\n\u2026\n,\n\nv\n\ni\n\u2212\n1\n\n\n)\n\n\n(\nw\n)\n\n\n{\\displaystyle \\nu _{(v_{1},\\dots ,v_{i-1})}(w)}\n\n is minimal. Equivalently, \n\n\n\n\u03c3\n\n\n{\\displaystyle \\sigma }\n\n is a BFS ordering if, for all \n\n\n\n1\n\u2264\ni\n<\nj\n<\nk\n\u2264\nn\n\n\n{\\displaystyle 1\\leq i<j<k\\leq n}\n\n with \n\n\n\n\nv\n\ni\n\n\n\u2208\nN\n(\n\nv\n\nj\n\n\n)\n\u2216\nN\n(\n\nv\n\nk\n\n\n)\n\n\n{\\displaystyle v_{i}\\in N(v_{j})\\setminus N(v_{k})}\n\n, there exists a neighbor \n\n\n\n\nv\n\nm\n\n\n\n\n{\\displaystyle v_{m}}\n\n of \n\n\n\n\nv\n\nj\n\n\n\n\n{\\displaystyle v_{j}}\n\n such that \n\n\n\nm\n<\ni\n\n\n{\\displaystyle m<i}\n\n.\nBreadth-first search can be used to solve many problems in graph theory, for example:\nBFS can be used to test bipartiteness, by starting the search at any vertex and giving alternating labels to the vertices visited during the search. That is, give label 0 to the starting vertex, 1 to all its neighbors, 0 to those neighbors' neighbors, and so on. If at any step a vertex has (visited) neighbors with the same label as itself, then the graph is not bipartite. If the search ends without such a situation occurring, then the graph is bipartite.", 
    "name": "Breadth First Search"
}
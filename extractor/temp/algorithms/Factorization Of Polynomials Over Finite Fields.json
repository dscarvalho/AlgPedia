{
    "about": "In mathematics and computer algebra the factorization of a polynomial consists of decomposing it into a product of irreducible factors. This decomposition is theoretically possible and is unique for polynomials with coefficients in any field, but rather strong restrictions on the field of the coefficients are needed to allow the computation of the factorization by means of an algorithm. In practice, algorithms have been designed only for polynomials with coefficients in a finite field, in the field of rationals or in a finitely generated field extension of one of them.", 
    "name": "Factorization Of Polynomials Over Finite Fields", 
    "classification": "Computer Algebra", 
    "full_text": "In mathematics and computer algebra the factorization of a polynomial consists of decomposing it into a product of irreducible factors. This decomposition is theoretically possible and is unique for polynomials with coefficients in any field, but rather strong restrictions on the field of the coefficients are needed to allow the computation of the factorization by means of an algorithm. In practice, algorithms have been designed only for polynomials with coefficients in a finite field, in the field of rationals or in a finitely generated field extension of one of them.\nThe case of the factorization of univariate polynomials over a finite field, which is the subject of this article, is especially important, because all the algorithms (including the case of multivariate polynomials over the rational numbers), which are sufficiently efficient to be implemented, reduce the problem to this case (see Polynomial factorization). It is also interesting for various applications of finite fields, such as coding theory (cyclic redundancy codes and BCH codes), cryptography (public key cryptography by the means of elliptic curves), and computational number theory.\nAs the reduction of the factorization of multivariate polynomials to that of univariate polynomials does not have any specificity in the case of coefficients in a finite field, only polynomials with one variable are considered in this article.\n\n\nThe theory of finite fields, whose origins can be traced back to the works of Gauss and Galois, has played a part in various branches of mathematics. Due to the applicability of the concept in other topics of mathematics and sciences like computer science there has been a resurgence of interest in finite fields and this is partly due to important applications in coding theory and cryptography. Applications of finite fields introduce some of these developments in cryptography, computer algebra and coding theory.\nA finite field or Galois field is a field with a finite order (number of elements). The order of a finite field is always a prime or a power of prime. For each prime power q = pr, there exists exactly one finite field with q elements, up to isomorphism. This field is denoted GF(q) or Fq. If p is prime, GF(p) is the prime field of order p; it is the field of residue classes modulo p, and its p elements are denoted 0, 1, ..., p\u22121. Thus a\u00a0=\u00a0b in GF(p) means the same as a \u2261 b (mod p).\nLet F be a finite field. As for general fields, a non-constant polynomial f in F[x] is said to be irreducible over F if it is not the product of two polynomials of positive degree. A polynomial of positive degree that is not irreducible over F is called reducible over F.\nIrreducible polynomials allow us to construct the finite fields of non prime order. In fact, for a prime power q, let Fq be the finite field with q elements, unique up to an isomorphism. A polynomial f of degree n greater than one, which is irreducible over Fq, defines a field extension of degree n which is isomorphic to the field with qn elements: the elements of this extension are the polynomials of degree lower than n; addition, subtraction and multiplication by an element of Fq are those of the polynomials; the product of two elements is the remainder of the division by f of their product as polynomials; the inverse of an element may be computed by the extended GCD algorithm (see Arithmetic of algebraic extensions).\nIt follows that, to compute in a finite field of non prime order, one needs to generate an irreducible polynomial. For this, the common method is to take a polynomial at random and test it for irreducibility. For sake of efficiency of the multiplication in the field, it is usual to search for polynomials of the shape xn + ax + b.[citation needed]\nIrreducible polynomials over finite fields are also useful for Pseudorandom number generators using feedback shift registers and discrete logarithm over F2n.\nThe polynomial P = x4 + 1 is irreducible over Q but not over any finite field.\nPolynomial factoring algorithms use basic polynomial operations such as products, divisions, gcd, powers of one polynomial modulo another, etc. A multiplication of two polynomials of degree at most n can be done in O(n2) operations in Fq using \"classical\" arithmetic, or in O(nlog(n) log(log(n)) ) operations in Fq using \"fast\" arithmetic. A Euclidean division (division with remainder) can be performed within the same time bounds. The cost of a polynomial greatest common divisor between two polynomials of degree at most n can be taken as O(n2) operations in Fq using classical methods, or as O(nlog2(n) log(log(n)) ) operations in Fq using fast methods. For polynomials h, g of degree at most n, the exponentiation hq mod g can be done with O(log(q)) polynomial products, using exponentiation by squaring method, that is O(n2log(q)) operations in Fq using classical methods, or O(nlog(q)log(n) log(log(n))) operations in Fq using fast methods.\nIn the algorithms that follow, the complexities are expressed in terms of number of arithmetic operations in Fq, using classical algorithms for the arithmetic of polynomials.\nMany algorithms for factoring polynomials over finite fields include the following three stages:\nAn important exception is Berlekamp's algorithm, which combines stages 2 and 3.\nThe Berlekamp's algorithm is historically important as being the first factorization algorithm, which works well in practice. However, it contains a loop on the elements of the ground field, which implies that it is practicable only over small finite fields. For a fixed ground field, its time complexity is polynomial, but, for general ground fields, the complexity is exponential in the size of the ground field.\nThe algorithm determines a square-free factorization for polynomials whose coefficients come from the finite field Fq of order q = pm with p a prime. This algorithm firstly determines the derivative and then computes the gcd of the polynomial and its derivative. If it is not one then the gcd is again divided into the original polynomial, provided that the derivative is not zero (a case that exists for non-constant polynomials defined over finite fields).\nThis algorithm uses the fact that, if the derivative of a polynomial is zero, then it is a polynomial in xp, which is, if the coefficients belong to Fp, the pth power of the polynomial obtained by substituting x by x1/p. If the coefficients do not belong to Fp, the p-th root of a polynomial with zero derivative is obtained by the same substitution on x, completed by applying the inverse of the Frobenius automorphism to the coefficients.\nThis algorithm works also over a field of characteristic zero, with the only difference that it never enters in the blocks of instructions where pth roots are computed. However, in this case, Yun's algorithm is much more efficient because it computes the greatest common divisors of polynomials of lower degrees. A consequence is that, when factoring a polynomial over the integers, the algorithm which follows is not used: one compute first the square-free factorization over the integers, and to factor the resulting polynomials, one chooses a p such that they remain square-free modulo p.\nLet\nto be factored over the field with three elements.\nThe algorithm computes first\nSince the derivative is non-zero we have w = f/c = x2 + 2 and we enter the while loop. After one loop we have y = x + 2, z = x + 1 and R = x + 1 with updates i = 2, w = x + 2 and c = x8 + x7 + x6 + x2+x+1. The second time through the loop gives y = x + 2, z = 1, R = x + 1, with updates i = 3, w = x + 2 and c = x7 + 2x6 + x + 2. The third time through the loop also does not change R. For the fourth time through the loop we get y = 1, z = x + 2, R = (x + 1)(x + 2)4, with updates i = 5, w = 1 and c = x6 + 1. Since w = 1, we exit the while loop. Since c \u2260 1, it must be a perfect cube. The cube root of c, obtained by replacing x3 by x is x2\u00a0+\u00a01, and calling the square-free procedure recursively determines that it is square-free. Therefore, cubing it and combining it with the value of R to that point gives the square-free decomposition\nThis algorithm splits a square-free polynomial into a product of polynomials whose irreducible factors all have the same degree. Let f \u2208 Fq[x] of degree n be the polynomial to be factored.\nThe correctness of the algorithm is based on the following:\nLemma. For i \u2265 1 the polynomial\nAt first glance, this is not efficient since it involves computing the GCD of polynomials of a degree which is exponential in the degree of the input polynomial. However\nmay be replaced by\nTherefore, we have to compute:\nthere are two methods:\nMethod I. Start from the value of\ncomputed at the preceding step and to compute its q-th power modulo the new f*, using exponentiation by squaring method. This needs\narithmetic operations in Fq at each step, and thus\nMethod II. Using the fact that the q-th power is a linear map over Fq we may compute its matrix with\noperations. Then at each iteration of the loop, compute the product of a matrix by a vector (with O(deg(f)2) operations). This induces a total number of operations in Fq which is\nIn this section, we consider the factorization of a monic squarefree univariate polynomial f, of degree n, over a finite field Fq, which has r \u2265 2 pairwise distinct irreducible factors \n\n\n\n\nf\n\n1\n\n\n,\n\u2026\n,\n\nf\n\nr\n\n\n\n\n{\\displaystyle f_{1},\\ldots ,f_{r}}\n\n each of degree d.\nWe first describe an algorithm by Cantor and Zassenhaus (1981) and then a variant that has a slightly better complexity. Both are probabilistic algorithms whose running time depends on random choices (Las Vegas algorithms), and have a good average running time. In next section we describe an algorithm by Shoup (1990), which is also an equal-degree factorization algorithm, but is deterministic. All these algorithms require an odd order q for the field of coefficients. For more factorization algorithms see e.g. Knuth's book The Art of Computer Programming volume 2.\nThe correctness of this algorithm relies on the fact that the ring Fq[x]/f is a direct product of the fields Fq[x]/fi where fi runs on the irreducible factors of f. As all these fields have qd elements, the component of g in any of these fields is zero with probability\nThis implies that the polynomial gcd(g, u) is the product of the factors of g for which the component of g is zero.\nIt has been shown that the average number of iterations of the while loop of the algorithm is less than \n\n\n\n2.5\n\nlog\n\n2\n\n\n\u2061\nr\n\n\n{\\displaystyle 2.5\\log _{2}r}\n\n, giving an average number of arithmetic operations in Fq which is \n\n\n\nO\n(\nd\n\nn\n\n2\n\n\nlog\n\u2061\n(\nr\n)\nlog\n\u2061\n(\nq\n)\n)\n\n\n{\\displaystyle O(dn^{2}\\log(r)\\log(q))}\n\n.[1]\nIn the typical case where dlog(q) > n, this complexity may be reduced to\nby choosing h in the kernel of the linear map\nand replacing the instruction\nby\nThe proof of validity is the same as above, replacing the direct product of the fields Fq[x]/fi by the direct product of their subfields with q elements. The complexity is decomposed in \n\n\n\nO\n(\n\nn\n\n2\n\n\nlog\n\u2061\n(\nr\n)\nlog\n\u2061\n(\nq\n)\n)\n\n\n{\\displaystyle O(n^{2}\\log(r)\\log(q))}\n\n for the algorithm itself, \n\n\n\nO\n(\n\nn\n\n2\n\n\n(\nlog\n\u2061\n(\nq\n)\n+\nn\n)\n)\n\n\n{\\displaystyle O(n^{2}(\\log(q)+n))}\n\n for the computation of the matrix of the linear map (which may be already computed in the square-free factorization) and O(n3) for computing its kernel. It may be noted that this algorithm works also if the factors have not the same degree (in this case the number r of factors, needed for stopping the while loop, is found as the dimension of the kernel). Nevertheless, the complexity is slightly better if square-free factorization is done before using this algorithm (as n may decrease with square-free factorization, this reduces the complexity of the critical steps).\nLike the algorithms of the preceding section, Victor Shoup's algorithm is an equal-degree factorization algorithm.[2] Unlike them, it is a deterministic algorithm. However, it is less efficient, in practice, that the algorithms of preceding section. For Shoup's algorithm, the input is restricted to polynomials over prime fields Fp.\nThe worst case time complexity of Shoup's algorithm has a factor \n\n\n\n\n\np\n\n\n.\n\n\n{\\displaystyle {\\sqrt {p}}.}\n\n Although exponential, this complexity is much better that previous deterministic algorithms (Berlekamp's algorithm) which have p as a factor. However, there are very few polynomials for which the computing time is exponential, and the average time complexity of the algorithm is polynomial in \n\n\n\nd\nlog\n\u2061\n(\np\n)\n,\n\n\n{\\displaystyle d\\log(p),}\n\n where d is the degree of the polynomial, and p is the number of elements of the ground field.\nLet g = g1 ... gk be the desired factorization, where the gi are distinct monic irreducible polynomials of degree d. Let n = deg(g) = kd. We consider the ring R = Fq[x]/g and denote also by x the image of x in R. The ring R is the direct product of the fields Ri = Fq[x]/gi, and we denote by pi the natural homomorphism from the R onto Ri. The Galois group of Ri over Fq is cyclic of order d, generated by the field automorphism u \u2192 up. It follows that the roots of gi in Ri are\nLike in the preceding algorithm, this algorithm uses the same subalgebra B of R as the Berlekamp's algorithm, sometimes called the \"Berlekamp subagebra\" and defined as\nA subset S of B is said a separating set if, for every 1\u00a0\u2264\u00a0i\u00a0<\u00a0j\u00a0\u2264\u00a0k there exists s\u00a0\u2208\u00a0S such that \n\n\n\n\np\n\ni\n\n\n(\ns\n)\n\u2260\n\np\n\nj\n\n\n(\ns\n)\n\n\n{\\displaystyle p_{i}(s)\\neq p_{j}(s)}\n\n. In the preceding algorithm, a separating set is constructed by choosing at random the elements of S. In Shoup's algorithm, the separating set is constructed in the following way. Let s in R[Y] be such that\nThen \n\n\n\n{\n\ns\n\n0\n\n\n,\n\u2026\n,\n\ns\n\nd\n\u2212\n1\n\n\n}\n\n\n{\\displaystyle \\{s_{0},\\dots ,s_{d-1}\\}}\n\n is a separating set because \n\n\n\n\np\n\ni\n\n\n(\ns\n)\n=\n\ng\n\ni\n\n\n\n\n{\\displaystyle p_{i}(s)=g_{i}}\n\n for i =1, ..., k (the two monic polynomials have the same roots). As the gi are pairwise distinct, for every pair of distinct indexes (i, j), at least one of the coefficients sh will satisfy \n\n\n\n\np\n\ni\n\n\n(\n\ns\n\nh\n\n\n)\n\u2260\n\np\n\nj\n\n\n(\n\ns\n\nh\n\n\n)\n.\n\n\n{\\displaystyle p_{i}(s_{h})\\neq p_{j}(s_{h}).}\n\n\nHaving a separating set, Shoup's algorithm proceeds as the last algorithm of the preceding section, simply by replacing the instruction \"choose at random h in the kernel of the linear map \n\n\n\nv\n\u2192\n\nv\n\nq\n\n\n\u2212\nv\n\n\n(\nmod\n\nf\n)\n\n\n\n{\\displaystyle v\\to v^{q}-v{\\pmod {f}}}\n\n\" by \"choose h + i with h in S and i in {1, ..., k\u22121}\".\nAs described in previous sections, for the factorization over finite fields, there are randomized algorithms of polynomial time complexity (for example Cantor-Zassenhaus algorithm). There are also deterministic algorithms with a polynomial average complexity (for example Shoup's algorithm).\nThe existence of a deterministic algorithm with a polynomial worst-case complexity is still an open problem.\nLike distinct-degree factorization algorithm, Rabin's algorithm[3] is based on the Lemma stated above. Distinct-degree factorization algorithm tests every d not greater than half the degree of the input polynomial. Rabin's algorithm takes advantage that the factors are not needed for considering fewer d. Otherwise, it is similar to distinct-degree factorization algorithm. It is based on the following fact.\nLet p1, ..., pk, be all the prime divisors of n, and denote \n\n\n\nn\n\n/\n\n\np\n\ni\n\n\n=\n\nn\n\ni\n\n\n\n\n{\\displaystyle n/p_{i}=n_{i}}\n\n, for 1 \u2264 i \u2264 k polynomial f in Fq[x] of degree n is irreducible in Fq[x] if and only if \n\n\n\ngcd\n\n(\nf\n,\n\nx\n\n\nq\n\n\nn\n\ni\n\n\n\n\n\n\n\u2212\nx\n)\n\n=\n1\n\n\n{\\displaystyle \\gcd \\left(f,x^{q^{n_{i}}}-x\\right)=1}\n\n, for 1\u00a0\u2264\u00a0i\u00a0\u2264\u00a0k, and f divides \n\n\n\n\nx\n\n\nq\n\nn\n\n\n\n\n\u2212\nx\n\n\n{\\displaystyle x^{q^{n}}-x}\n\n. In fact, if f has a factor of degree not dividing n, then f does not divide \n\n\n\n\nx\n\n\nq\n\nn\n\n\n\n\n\u2212\nx\n\n\n{\\displaystyle x^{q^{n}}-x}\n\n; if f has a factor of degree dividing n, then this factor divides at least one of the \n\n\n\n\nx\n\n\nq\n\n\nn\n\ni\n\n\n\n\n\n\n\u2212\nx\n.\n\n\n{\\displaystyle x^{q^{n_{i}}}-x.}\n\n\nThe basic idea of this algorithm is to compute \n\n\n\n\nx\n\n\nq\n\n\nn\n\ni\n\n\n\n\n\n\n\nmod\n\nf\n\n\n\n\n{\\displaystyle x^{q^{n_{i}}}{\\bmod {f}}}\n\n starting from the smallest \n\n\n\n\nn\n\n1\n\n\n,\n\u2026\n,\n\nn\n\nk\n\n\n\n\n{\\displaystyle n_{1},\\ldots ,n_{k}}\n\n by repeated squaring or using the Frobenius automorphism, and then to take the correspondent gcd. Using the elementary polynomial arithmetic, the computation of the matrix of the Frobenius automorphism needs \n\n\n\nO\n(\n\nn\n\n2\n\n\n(\nn\n+\nlog\n\u2061\nq\n)\n)\n\n\n{\\displaystyle O(n^{2}(n+\\log q))}\n\n operations in Fq, the computation of\nneeds O(n3) further operations, and the algorithm itself needs O(kn2) operations, giving a total of \n\n\n\nO\n(\n\nn\n\n2\n\n\n(\nn\n+\nlog\n\u2061\nq\n)\n)\n\n\n{\\displaystyle O(n^{2}(n+\\log q))}\n\n operations in Fq. Using fast arithmetic (complexity \n\n\n\nO\n(\nn\nlog\n\u2061\nn\n)\n\n\n{\\displaystyle O(n\\log n)}\n\n for multiplication and division, and \n\n\n\nO\n(\nn\n(\nlog\n\u2061\nn\n\n)\n\n2\n\n\n)\n\n\n{\\displaystyle O(n(\\log n)^{2})}\n\n for GCD computation), the computation of the \n\n\n\n\nx\n\n\nq\n\n\nn\n\ni\n\n\n\n\n\n\n\u2212\nx\n\nmod\n\nf\n\n\n\n\n{\\displaystyle x^{q^{n_{i}}}-x{\\bmod {f}}}\n\n by repeated squaring is \n\n\n\nO\n(\n\nn\n\n2\n\n\nlog\n\u2061\nn\nlog\n\u2061\nq\n)\n\n\n{\\displaystyle O(n^{2}\\log n\\log q)}\n\n, and the algorithm itself is \n\n\n\nO\n(\nk\nn\n(\nlog\n\u2061\nn\n\n)\n\n2\n\n\n)\n\n\n{\\displaystyle O(kn(\\log n)^{2})}\n\n, giving a total of \n\n\n\nO\n(\n\nn\n\n2\n\n\nlog\n\u2061\nn\nlog\n\u2061\nq\n)\n\n\n{\\displaystyle O(n^{2}\\log n\\log q)}\n\n operations in Fq.", 
    "dbpedia_url": "http://dbpedia.org/resource/Factorization_of_polynomials_over_finite_fields", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields\n"
}
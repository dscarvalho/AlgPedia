{
    "about": "A parity bit, or check bit, is a bit added to a string of binary code to ensure that the total number of 1-bits in the string is even or odd. Parity bits are used as the simplest form of error detecting code.", 
    "name": "Parity Bit", 
    "classification": "Error Detection And Correction", 
    "full_text": "A parity bit, or check bit, is a bit added to a string of binary code to ensure that the total number of 1-bits in the string is even or odd. Parity bits are used as the simplest form of error detecting code.\nThere are two variants of parity bits: even parity bit and odd parity bit.\nIn the case of even parity, for a given set of bits, the occurrences of bits whose value is 1 is counted. If that count is odd, the parity bit value is set to 1, making the total count of occurrences of 1's in the whole set (including the parity bit) an even number. If the count of 1's in a given set of bits is already even, the parity bit's value is 0.\nIn the case of odd parity, the coding is reversed. For a given set of bits, if the count of bits with a value of 1 is even, the parity bit value is set to 1 making the total count of 1's in the whole set (including the parity bit) an odd number. If the count of bits with a value of 1 is odd, the count is already odd so the parity bit's value is 0.\nEven parity is a special case of a cyclic redundancy check (CRC), where the 1-bit CRC is generated by the polynomial x+1.\nIf the parity bit is present but not used, it may be referred to as mark parity (when the parity bit is always 1) or space parity (the bit is always 0).\nParity bits are generally applied to the smallest units of a communication protocol, typically 8-bit octets (bytes), although they can also be applied separately to an entire message string of bits.\nThe decimal math equivalent to the parity bit is the Check digit.\n\n\nIn mathematics, parity refers to the evenness or oddness of an integer, which for a binary number is determined only by the least significant bit. In telecommunications and computing, parity refers to the evenness or oddness of the number of bits with value one within a given set of bits, and is thus determined by the value of all the bits. It can be calculated via an XOR sum of the bits, yielding 0 for even parity and 1 for odd parity. This property of being dependent upon all the bits and changing value if any one bit changes allows for its use in error detection schemes.\nIf an odd number of bits (including the parity bit) are transmitted incorrectly, the parity bit will be incorrect, thus indicating that a parity error occurred in the transmission. The parity bit is only suitable for detecting errors; it cannot correct any errors, as there is no way to determine which particular bit is corrupted. The data must be discarded entirely, and re-transmitted from scratch. On a noisy transmission medium, successful transmission can therefore take a long time, or even never occur. However, parity has the advantage that it uses only a single bit and requires only a number of XOR gates to generate. See Hamming code for an example of an error-correcting code.\nParity bit checking is used occasionally for transmitting ASCII characters, which have 7 bits, leaving the 8th bit as a parity bit.\nFor example, the parity bit can be computed as follows, assuming we are sending simple 4-bit values 1001.\nA wants to transmit: 1001\nA computes parity bit value: 1+0+0+1 (mod 2) = 0\nA adds parity bit and sends: 10010\nB receives: 10010\nB computes parity: 1+0+0+1+0 (mod 2) = 0\nB reports correct transmission after observing expected even result.\nA wants to transmit: 1001\nA computes parity bit value: 1+0+0+1 + 1 (mod 2) = 1\nA adds parity bit and sends: 10011\nB receives: 10011\nB computes overall parity: 1+0+0+1+1 (mod 2) = 1\nB reports correct transmission after observing expected odd result.\nThis mechanism enables the detection of single bit errors, because if one bit gets flipped due to line noise, there will be an incorrect number of ones in the received data. In the two examples above, B's calculated parity value matches the parity bit in its received value, indicating there are no single bit errors. Consider the following example with a transmission error in the second bit using XOR:\nError in the second bit\nA computes parity bit value: 1^0^0^1 = 0\nA adds parity bit and sends: 10010\n...TRANSMISSION ERROR...\nB receives: 11010\nB computes overall parity: 1^1^0^1^0 = 1\nB reports incorrect transmission after observing unexpected odd result.\nError in the parity bit\nA computes even parity value: 1^0^0^1 = 0\nA sends: 10010\n...TRANSMISSION ERROR...\nB receives: 10011\nB computes overall parity: 1^0^0^1^1 = 1\nB reports incorrect transmission after observing unexpected odd result.\nThere is a limitation to parity schemes. A parity bit is only guaranteed to detect an odd number of bit errors. If an even number of bits have errors, the parity bit records the correct number of ones, even though the data is corrupt. (See also error detection and correction.) Consider the same example as before with an even number of corrupted bits:\nTwo corrupted bits\nA computes even parity value: 1^0^0^1 = 0\nA sends: 10010\n...TRANSMISSION ERROR...\nB receives: 11011\nB computes overall parity: 1^1^0^1^1 = 0\nB reports correct transmission though actually incorrect.\nB observes even parity, as expected, thereby failing to catch the two bit errors.\nBecause of its simplicity, parity is used in many hardware applications where an operation can be repeated in case of difficulty, or where simply detecting the error is helpful. For example, the SCSI and PCI buses use parity to detect transmission errors, and many microprocessor instruction caches include parity protection. Because the I-cache data is just a copy of main memory, it can be disregarded and re-fetched if it is found to be corrupted.\nIn serial data transmission, a common format is 7 data bits, an even parity bit, and one or two stop bits. This format neatly accommodates all the 7-bit ASCII characters in a convenient 8-bit byte. Other formats are possible; 8 bits of data plus a parity bit can convey all 8-bit byte values.\nIn serial communication contexts, parity is usually generated and checked by interface hardware (e.g., a UART) and, on reception, the result made available to the CPU (and so to, for instance, the operating system) via a status bit in a hardware register in the interface hardware. Recovery from the error is usually done by retransmitting the data, the details of which are usually handled by software (e.g., the operating system I/O routines).\nWhen the total number of transmitted bits, including the parity bit, is even, odd parity has the advantage that the all-zeros and all-ones patterns are both detected as errors. If the total number of bits is odd, only one of the patterns is detected as an error, and the choice can be made based on which is expected to be the more common error.\nParity data is used by some RAID levels to achieve redundancy. If a drive in the array fails, remaining data on the other drives can be combined with the parity data (using the Boolean XOR function) to reconstruct the missing data.\nFor example, suppose two drives in a three-drive RAID 5 array contained the following data:\nDrive 1: 01101101\nDrive 2: 11010100\nTo calculate parity data for the two drives, an XOR is performed on their data:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a001101101\nXOR 11010100\n_____________\n\u00a0 \u00a0 \u00a0 \u00a0 10111001\nThe resulting parity data, 10111001, is then stored on Drive 3.\nShould any of the three drives fail, the contents of the failed drive can be reconstructed on a replacement drive by subjecting the data from the remaining drives to the same XOR operation. If Drive 2 were to fail, its data could be rebuilt using the XOR results of the contents of the two remaining drives, Drive 1 and Drive 3:\nDrive 1: 01101101\nDrive 3: 10111001\nas follows:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a010111001\nXOR 01101101\n_____________\n\u00a0 \u00a0 \u00a0 \u00a0 11010100\nThe result of that XOR calculation yields Drive 2's contents. 11010100 is then stored on Drive 2, fully repairing the array. This same XOR concept applies similarly to larger arrays, using any number of disks. In the case of a RAID 3 array of 12 drives, 11 drives participate in the XOR calculation shown above and yield a value that is then stored on the dedicated parity drive.\nA \"parity track\" was present on the first magnetic tape data storage in 1951. Parity in this form, applied across multiple parallel signals, is known as a transverse redundancy check. This can be combined with parity computed over multiple bits sent on a single signal, a longitudinal redundancy check. In a parallel bus, there is one longitudinal redundancy check bit per parallel signal.\nParity was also used on at least some paper-tape (punched tape) data entry systems (which preceded magnetic tape systems). On the systems sold by British company ICL (formerly ICT) the 1-inch-wide (25\u00a0mm) paper tape had 8 hole positions running across it, with the 8th being for parity. 7 positions were used for the data, e.g., 7-bit ASCII. The 8th position had a hole punched in it depending on the number of data holes punched.", 
    "dbpedia_url": "http://dbpedia.org/resource/Parity_bit", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Parity_bit\n"
}
{
    "about": "The Luhn algorithm or Luhn formula, also known as the \"modulus 10\" or \"mod 10\" algorithm, is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers in the US, Canadian Social Insurance Numbers, and Greek Social Security Numbers (\u0391\u039c\u039a\u0391). It was created by IBM scientist Hans Peter Luhn and described in U.S. Patent No. 2,950,048, filed on January 6, 1954, and granted on August 23, 1960.", 
    "name": "Luhn Algorithm", 
    "classification": "Checksum Algorithms", 
    "full_text": "The Luhn algorithm or Luhn formula, also known as the \"modulus 10\" or \"mod 10\" algorithm, is a simple checksum formula used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers in the US, Canadian Social Insurance Numbers, and Greek Social Security Numbers (\u0391\u039c\u039a\u0391). It was created by IBM scientist Hans Peter Luhn and described in U.S. Patent No. 2,950,048, filed on January 6, 1954, and granted on August 23, 1960.\nThe algorithm is in the public domain and is in wide use today. It is specified in ISO/IEC 7812-1.[1] It is not intended to be a cryptographically secure hash function; it was designed to protect against accidental errors, not malicious attacks. Most credit cards and many government identification numbers use the algorithm as a simple method of distinguishing valid numbers from mistyped or otherwise incorrect numbers.\n\n\nThe formula verifies a number against its included check digit, which is usually appended to a partial account number to generate the full account number. This number must pass the following test:\nAssume an example of an account number \"7992739871\" that will have a check digit added, making it of the form 7992739871x:\nThe sum of all the digits in the third row is 67+x.\nThe check digit (x) is obtained by computing the sum of the non-check digits then computing 9 times that value modulo 10 (in equation form, (67 \u00d7 9 mod 10)). In algorithm form:\n(Alternative method) The check digit (x) is obtained by computing the sum of the other digits (third row) then subtracting the units digit from 10 (67 => Units digit 7; 10 \u2212 7 = check digit 3). In algorithm form:\nThis makes the full account number read 79927398713.\nEach of the numbers 79927398710, 79927398711, 79927398712, 79927398713, 79927398714, 79927398715, 79927398716, 79927398717, 79927398718, 79927398719 can be validated as follows.\nAlternately, you can use the same checksum creation algorithm, ignoring the checksum already in place as if it had not yet been calculated. Then calculate the checksum and compare this calculated checksum to the original checksum included with the credit card number. If the included checksum matches the calculated checksum, then the number is valid.\nThe Luhn algorithm will detect any single-digit error, as well as almost all transpositions of adjacent digits. It will not, however, detect transposition of the two-digit sequence 09 to 90 (or vice versa). It will detect 7 of the 10 possible twin errors (it will not detect 22 \u2194 55, 33 \u2194 66 or 44 \u2194 77).\nOther, more complex check-digit algorithms (such as the Verhoeff algorithm and the Damm algorithm) can detect more transcription errors. The Luhn mod N algorithm is an extension that supports non-numerical strings.\nBecause the algorithm operates on the digits in a right-to-left manner and zero digits affect the result only if they cause shift in position, zero-padding the beginning of a string of numbers does not affect the calculation. Therefore, systems that pad to a specific number of digits (by converting 1234 to 0001234 for instance) can perform Luhn validation before or after the padding and achieve the same result.\nPrepending a 0 to odd-length numbers makes it possible to process the number from left to right rather than right to left, doubling the odd-place digits.\nThe algorithm appeared in a US Patent[2] for a hand-held, mechanical device for computing the checksum. It was therefore required to be rather simple. The device took the mod 10 sum by mechanical means. The substitution digits, that is, the results of the double and reduce procedure, were not produced mechanically. Rather, the digits were marked in their permuted order on the body of the machine.\nThe implementations below are in Python.\nThe algorithm below checks the validity of an input with a check digit. Calculating the check digit requires only a slight adaptation of the algorithm\u2014namely:", 
    "dbpedia_url": "http://dbpedia.org/resource/Luhn_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Luhn_algorithm\n"
}
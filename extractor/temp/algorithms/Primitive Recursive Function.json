{
    "about": "In computability theory, primitive recursive functions are a class of functions that are defined using primitive recursion and composition as central operations and are a strict subset of the total \u00b5-recursive functions (\u00b5-recursive functions are also called partial recursive). Primitive recursive functions form an important building block on the way to a full formalization of computability. These functions are also important in proof theory.", 
    "name": "Primitive Recursive Function", 
    "classification": "Recursion", 
    "full_text": "In computability theory, primitive recursive functions are a class of functions that are defined using primitive recursion and composition as central operations and are a strict subset of the total \u00b5-recursive functions (\u00b5-recursive functions are also called partial recursive). Primitive recursive functions form an important building block on the way to a full formalization of computability. These functions are also important in proof theory.\nMost of the functions normally studied in number theory are primitive recursive. For example, addition and division, the factorial and exponential function, and the function which returns the nth prime are all primitive recursive. So are many approximations to real-valued functions.[1] In fact, it is difficult to devise a total recursive function that is not primitive recursive, although some are known (see the section on Limitations below). The set of primitive recursive functions is known as PR in computational complexity theory.\n\n\nThe primitive recursive functions are among the number-theoretic functions, which are functions from the natural numbers (nonnegative integers) {0, 1, 2, ...} to the natural numbers. These functions take n arguments for some natural number n and are called n-ary.\nThe basic primitive recursive functions are given by these axioms:\nMore complex primitive recursive functions can be obtained by applying the operations given by these axioms:\nExample. We take f(x) as the S(x) defined above. This f is a 1-ary PRF. And so is g(x) = S(x). So h(x) defined as f(g(x)) = S(S(x)) is a primitive recursive 1-ary function too. Informally speaking, h(x) is the function that turns x into x+2.\nExample. Suppose f(x) = P11(x) = x and g(x,y,z)= S(P23(x,y,z)) = S(y). Then h(0,x) = x and h(S(y),x) = g(y,h(y,x),x) = S(h(y,x)). Now h(0,1) = 1, h(1,1) = S(h(0,1)) = 2, h(2,1) = S(h(1,1)) = 3. This h is a 2-ary primitive recursive function. We can call it 'addition'.\nThe primitive recursive functions are the basic functions and those obtained from the basic functions by applying these operations a finite number of times.\nThe projection functions can be used to avoid the apparent rigidity in terms of the arity of the functions above; by using compositions with various projection functions, it is possible to pass a subset of the arguments of one function to another function. For example, if g and h are 2-ary primitive recursive functions then\nis also primitive recursive. One formal definition using projection functions is\nIn some settings it is natural to consider primitive recursive functions that take as inputs tuples that mix numbers with truth values (that is t for true and f for false), or that produce truth values as outputs (see Kleene [1952 pp.\u00a0226\u2013227]). This can be accomplished by identifying the truth values with numbers in any fixed manner. For example, it is common to identify the truth value t with the number 1 and the truth value f with the number 0. Once this identification has been made, the characteristic function of a set A, which always returns 1 or 0, can be viewed as a predicate that tells whether a number is in the set A. Such an identification of predicates with numeric functions will be assumed for the remainder of this article.\nAn example of a primitive recursive programming language is one that contains basic arithmetic operators (e.g. + and \u2212, or ADD and SUBTRACT), conditionals and comparison (IF-THEN, EQUALS, LESS-THAN), and bounded loops, such as the basic for loop, where there is a known or calculable upper bound to all loops (FOR i FROM 1 to n, with neither i nor n modifiable by the loop body). No control structures of greater generality, such as while loops or IF-THEN plus GOTO, are admitted in a primitive recursive language. Douglas Hofstadter's BlooP in G\u00f6del, Escher, Bach is one such. Adding unbounded loops (WHILE, GOTO) makes the language partially recursive, or Turing-complete; Floop is such, as are almost all real-world computer languages.\nArbitrary computer programs, or Turing machines, cannot in general be analyzed to see if they halt or not (the halting problem). However, all primitive recursive functions halt. This is not a contradiction; primitive recursive programs are a non-arbitrary subset of all possible programs, constructed specifically to be analyzable.\nMost number-theoretic functions definable using recursion on a single variable are primitive recursive. Basic examples include the addition and truncated subtraction functions.\nIntuitively, addition can be recursively defined with the rules:\nTo fit this into a strict primitive recursive definition, define:\nHere S(n) is \"the successor of n\" (i.e., n+1), P11 is the identity function, and P23 is the projection function that takes 3 arguments and returns the second one. Functions f and g required by the above definition of the primitive recursion operation are respectively played by P11 and the composition of S and P23.\nBecause primitive recursive functions use natural numbers rather than integers, and the natural numbers are not closed under subtraction, a truncated subtraction function (also called \"proper subtraction\") is studied in this context. This limited subtraction function sub(a, b) [or b \u2238 a] returns b - a if this is nonnegative and returns 0 otherwise.\nThe predecessor function acts as the opposite of the successor function and is recursively defined by the rules:\nThese rules can be converted into a more formal definition by primitive recursion:\nThe limited subtraction function is definable from the predecessor function in a manner analogous to the way addition is defined from successor:\nHere sub(a, b) corresponds to b \u2238 a; for the sake of simplicity, the order of the arguments has been switched from the \"standard\" definition to fit the requirements of primitive recursion. This could easily be rectified using composition with suitable projections.\nExponentiation and primality testing are primitive recursive. Given primitive recursive functions e, f, g, and h, a function that returns the value of g when e\u2264f and the value of h otherwise is primitive recursive.\nBy using G\u00f6del numberings, the primitive recursive functions can be extended to operate on other objects such as integers and rational numbers. If integers are encoded by G\u00f6del numbers in a standard way, the arithmetic operations including addition, subtraction, and multiplication are all primitive recursive. Similarly, if the rationals are represented by G\u00f6del numbers then the field operations are all primitive recursive.\nIn first-order Peano arithmetic, there are infinitely many variables (0-ary symbols) but no k-ary non-logical symbols with k>0 other than S, +, *, and \u2264. Thus in order to define primitive recursive functions one has to use the following trick by G\u00f6del.\nBy using a G\u00f6del numbering for sequences, for example G\u00f6del's \u03b2 function, any sequence of numbers can be encoded by a single number. Such a number can therefore represent the primitive recursive function until a given n.\nLet h be a 1-ary primitive recursion function defined by:\nwhere C is a constant and g is an already defined function.\nUsing G\u00f6del's \u03b2 function, for any sequence of natural numbers (k0, k1, \u2026, kn), there are natural numbers b and c such that, for every i \u2264 n, \u03b2(b, c, i) = ki. We may thus use the following formula to define h; more precisely, m=h(n) is a shorthand for the following:\nand the equating to g, being already defined, is in fact shorthand for some other already defined formula (as is \u03b2, whose formula is given here).\nThe generalization to any k-ary primitive recursion function is trivial.\nThe broader class of partial recursive functions is defined by introducing an unbounded search operator. The use of this operator may result in a partial function, that is, a relation with at most one value for each argument, but does not necessarily have any value for any argument (see domain). An equivalent definition states that a partial recursive function is one that can be computed by a Turing machine. A total recursive function is a partial recursive function that is defined for every input.\nEvery primitive recursive function is total recursive, but not all total recursive functions are primitive recursive. The Ackermann function A(m,n) is a well-known example of a total recursive function (in fact, provable total), that is not primitive recursive. There is a characterization of the primitive recursive functions as a subset of the total recursive functions using the Ackermann function. This characterization states that a function is primitive recursive if and only if there is a natural number m such that the function can be computed by a Turing machine that always halts within A(m,n) or fewer steps, where n is the sum of the arguments of the primitive recursive function.[2]\nAn important property of the primitive recursive functions is that they are a recursively enumerable subset of the set of all total recursive functions (which is not itself recursively enumerable). This means that there is a single computable function f(m,n) that enumerated the primitive recursive functions, namely:\nf can be explicitly constructed by iteratively repeating all possible ways of creating primitive recursive functions. Thus, it is provably total. One can use a diagonalization argument to show that f is not recursive primitive in itself: had it been such, so would be h(n) = f(n,n)+1. But if this equals some primitive recursive function, there is an m such that h(n) = f(m,n) for all n, and then h(m) = f(m,m), leading to contradiction.\nThe set of primitive recursive function is not the largest recursively enumerable subset of the set of all total recursive functions: for example, the set of provably total functions (in Peano arithmetic) is also recursively enumerable, as one can enumerate all the proofs of the theory. While all primitive recursive functions are provably total, the converse in not true.\nPrimitive recursive functions tend to correspond very closely with our intuition of what a computable function must be. Certainly the initial functions are intuitively computable (in their very simplicity), and the two operations by which one can create new primitive recursive functions are also very straightforward. However the set of primitive recursive functions does not include every possible total computable function\u2009\u2014\u2009this can be seen with a variant of Cantor's diagonal argument. This argument provides a total computable function that is not primitive recursive. A sketch of the proof is as follows:\nThis argument can be applied to any class of computable (total) functions that can be enumerated in this way, as explained in the article Machines that always halt. Note however that the partial computable functions (those that need not be defined for all arguments) can be explicitly enumerated, for instance by enumerating Turing machine encodings.\nOther examples of total recursive but not primitive recursive functions are known:\nIn the following we observe that primitive recursive functions can be of four types:\nIn the following the mark \" ' \", e.g. a', is the primitive mark meaning \"the successor of\", usually thought of as \" +1\", e.g. a +1 =def a'. The functions 16-20 and #G are of particular interest with respect to converting primitive recursive predicates to, and extracting them from, their \"arithmetical\" form expressed as G\u00f6del numbers.\nSome additional forms of recursion also define functions that are in fact primitive recursive. Definitions in these forms may be easier to find or more natural for reading or writing. Course-of-values recursion defines primitive recursive functions. Some forms of mutual recursion also define primitive recursive functions.\nThe functions that can be programmed in the LOOP programming language are exactly the primitive recursive functions. This gives a different characterization of the power of these functions. The main limitation of the LOOP language, compared to a Turing-complete language, is that in the LOOP language the number of times that each loop will run is specified before the loop begins to run.\nThe primitive recursive functions are closely related to mathematical finitism, and are used in several contexts in mathematical logic where a particularly constructive system is desired. Primitive recursive arithmetic (PRA), a formal axiom system for the natural numbers and the primitive recursive functions on them, is often used for this purpose.\nPRA is much weaker than Peano arithmetic, which is not a finitistic system. Nevertheless, many results in number theory and in proof theory can be proved in PRA. For example, G\u00f6del's incompleteness theorem can be formalized into PRA, giving the following theorem:\nSimilarly, many of the syntactic results in proof theory can be proved in PRA, which implies that there are primitive recursive functions that carry out the corresponding syntactic transformations of proofs.\nIn proof theory and set theory, there is an interest in finitistic consistency proofs, that is, consistency proofs that themselves are finitistically acceptable. Such a proof establishes that the consistency of a theory T implies the consistency of a theory S by producing a primitive recursive function that can transform any proof of an inconsistency from S into a proof of an inconsistency from T. One sufficient condition for a consistency proof to be finitistic is the ability to formalize it in PRA. For example, many consistency results in set theory that are obtained by forcing can be recast as syntactic proofs that can be formalized in PRA.\nRecursive definitions had been used more or less formally in mathematics before, but the construction of primitive recursion is traced back to Richard Dedekind's theorem 126 of his Was sind und was sollen die Zahlen? (1888). This work was the first to give a proof that a certain recursive construction defines a unique function.[3][4][5]\nPrimitive recursive arithmetic was first proposed by Thoralf Skolem[6] in 1923.\nThe current terminology was coined by R\u00f3zsa P\u00e9ter (1934) after Ackermann had proved in 1928 that the function which today is named after him was not primitive recursive, an event which prompted the need to rename what until then were simply called recursive functions.[4][5]", 
    "dbpedia_url": "http://dbpedia.org/resource/Primitive_recursive_function", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Primitive_recursive_function\n"
}
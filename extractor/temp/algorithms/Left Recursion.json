{
    "about": "In the formal language theory of computer science, left recursion is a special case of recursion where a string is recognized as part of a language by the fact that it decomposes into a string from that same language (on the left) and a suffix (on the right). For instance, \n\n\n\n1\n+\n2\n+\n3\n\n\n{\\displaystyle 1+2+3}\n\n can be recognized as a sum because it can be broken into \n\n\n\n1\n+\n2\n\n\n{\\displaystyle 1+2}\n\n, also a sum, and \n\n\n\n\n\n+\n3\n\n\n{\\displaystyle {}+3}\n\n, a suitable suffix.", 
    "name": "Left Recursion", 
    "classification": "Recursion", 
    "full_text": "In the formal language theory of computer science, left recursion is a special case of recursion where a string is recognized as part of a language by the fact that it decomposes into a string from that same language (on the left) and a suffix (on the right). For instance, \n\n\n\n1\n+\n2\n+\n3\n\n\n{\\displaystyle 1+2+3}\n\n can be recognized as a sum because it can be broken into \n\n\n\n1\n+\n2\n\n\n{\\displaystyle 1+2}\n\n, also a sum, and \n\n\n\n\n\n+\n3\n\n\n{\\displaystyle {}+3}\n\n, a suitable suffix.\nIn terms of context-free grammar, a nonterminal is left-recursive if the leftmost symbol in one of its productions is itself (in the case of direct left recursion) or can be made itself by some sequence of substitutions (in the case of indirect left recursion).\n\n\nA grammar is left-recursive if and only if there exists a nonterminal symbol \n\n\n\nA\n\n\n{\\displaystyle A}\n\n that can derive to a sentential form with itself as the leftmost symbol.[1] Symbolically,\nwhere \n\n\n\n\n\u21d2\n\n+\n\n\n\n\n{\\displaystyle \\Rightarrow ^{+}}\n\n indicates the operation of making one or more substitutions, and \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n is any sequence of terminal and nonterminal symbols.\nDirect left recursion occurs when the definition can be satisfied with only one substitution. It requires a rule of the form\nwhere \n\n\n\n\u03b1\n\n\n{\\displaystyle \\alpha }\n\n is a sequence of nonterminals and terminals. For example, the rule\nis directly left-recursive. A left-to-right recursive descent parser for this rule might look like\nand such code would fall into infinite recursion when executed.\nIndirect left recursion occurs when the definition is satisfied via several substitutions. It entails a set of rules following the pattern\nwhere \n\n\n\n\n\u03b2\n\n0\n\n\n,\n\n\u03b2\n\n1\n\n\n,\n\u2026\n,\n\n\u03b2\n\nn\n\n\n\n\n{\\displaystyle \\beta _{0},\\beta _{1},\\ldots ,\\beta _{n}}\n\n are sequences that can each yield the empty string, while \n\n\n\n\n\u03b1\n\n0\n\n\n,\n\n\u03b1\n\n1\n\n\n,\n\u2026\n,\n\n\u03b1\n\nn\n\n\n\n\n{\\displaystyle \\alpha _{0},\\alpha _{1},\\ldots ,\\alpha _{n}}\n\n may be any sequences at all. The derivation\nthen gives \n\n\n\n\nA\n\n0\n\n\n\n\n{\\displaystyle A_{0}}\n\n as leftmost in its final sentential form.\nLeft recursion often poses problems for parsers, either because it leads them into infinite recursion (as in the case of most top-down parsers) or because they expect rules in a normal form that forbids it (as in the case of many bottom-up parsers, including the CYK algorithm). Therefore, a grammar is often preprocessed to eliminate the left recursion.\nThe general algorithm to remove direct left recursion follows. Several improvements to this method have been made.[2] For a left-recursive nonterminal \n\n\n\nA\n\n\n{\\displaystyle A}\n\n, discard any rules of the form \n\n\n\nA\n\u2192\nA\n\n\n{\\displaystyle A\\rightarrow A}\n\n and consider those that remain:\nwhere:\nReplace these with two sets of productions, one set for \n\n\n\nA\n\n\n{\\displaystyle A}\n\n:\nand another set for the fresh nonterminal \n\n\n\n\nA\n\u2032\n\n\n\n{\\displaystyle A'}\n\n (often called the \"tail\" or the \"rest\"):\nRepeat this process until no direct left recursion remains.\nAs an example, consider the rule set\nThis could be rewritten to avoid left recursion as\nBy establishing a topological ordering on nonterminals, the above process can be extended to also eliminate indirect left recursion[citation needed]:\nNote that this algorithm is highly sensitive to the nonterminal ordering; optimizations often focus on choosing this ordering well.[clarification needed]\nAlthough the above transformations preserve the language generated by a grammar, they may change the parse trees that witness strings' recognition. With suitable bookkeeping, tree rewriting can recover the originals, but if this step is omitted, the differences may change the semantics of a parse.\nAssociativity is particularly vulnerable; left-associative operators typically appear in right-associative-like arrangements under the new grammar. For example, starting with this grammar:\nthe standard transformations to remove left recursion yield the following:\nParsing the string \"1 - 2 - 3\" with the first grammar in an LALR parser (which can handle left-recursive grammars) would have resulted in the parse tree:\nThis parse tree groups the terms on the left, giving the correct semantics (1 - 2) - 3.\nParsing with the second grammar gives\nwhich, properly interpreted, signifies 1 + (-2 + (-3)), also correct, but less faithful to the input and much harder to implement for some operators. Notice how terms to the right appear deeper in the tree, much as a right-recursive grammar would arrange them for 1 - (2 - 3).\nA formal grammar that contains left recursion cannot be parsed by a LL(k)-parser or other naive recursive descent parser unless it is converted to a weakly equivalent right-recursive form. In contrast, left recursion is preferred for LALR parsers because it results in lower stack usage than right recursion. However, more sophisticated top-down parsers can implement general context-free grammars by use of curtailment. In 2006, Frost and Hafiz described an algorithm which accommodates ambiguous grammars with direct left-recursive production rules.[3] That algorithm was extended to a complete parsing algorithm to accommodate indirect as well as direct left recursion in polynomial time, and to generate compact polynomial-size representations of the potentially exponential number of parse trees for highly ambiguous grammars by Frost, Hafiz and Callaghan in 2007.[4] The authors then implemented the algorithm as a set of parser combinators written in the Haskell programming language.[5]", 
    "dbpedia_url": "http://dbpedia.org/resource/Left_recursion", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Left_recursion\n"
}
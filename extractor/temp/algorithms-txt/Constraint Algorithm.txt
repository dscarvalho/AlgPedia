ABOUT
In computational chemistry, a constraint algorithm is a method for satisfying the Newtonian motion of a rigid body which consists of mass points. A restraint algorithm is used to ensure that the distance between mass points is maintained. The general steps involved are; (i) choose novel unconstrained coordinates (internal coordinates), (ii) introduce explicit constraint forces, (iii) minimize constraint forces implicitly by the technique of Lagrange multipliers or projection methods.
FULL TEXT
In computational chemistry, a constraint algorithm is a method for satisfying the Newtonian motion of a rigid body which consists of mass points. A restraint algorithm is used to ensure that the distance between mass points is maintained. The general steps involved are; (i) choose novel unconstrained coordinates (internal coordinates), (ii) introduce explicit constraint forces, (iii) minimize constraint forces implicitly by the technique of Lagrange multipliers or projection methods.
Constraint algorithms are often applied to molecular dynamics simulations. Although such simulations are sometimes performed using internal coordinates that automatically satisfy the bond-length, bond-angle and torsion-angle constraints, simulations may also be performed using explicit or implicit constraint forces for these three constraints. However, explicit constraint forces give rise to inefficiency; more computational power is required to get a trajectory of a given length. Therefore, internal coordinates and implicit-force constraint solvers are generally preferred.
Constraint algorithms achieve computational efficiency by neglecting the motions of intramolecular atoms. If intramolecular behavior is important, e.g. hydrogen bonding and its behaviour, constraint algorithms should not be used.


The motion of a set of N particles can be described by a set of second-order ordinary differential equations, Newton's second law, which can be written in matrix form
where M is a mass matrix and q is the vector of generalized coordinates that describe the particles' positions. For example, the vector q may be a 3N Cartesian coordinates of the particle positions rk, where k runs from 1 to N; in the absence of constraints, M would be the 3Nx3N diagonal square matrix of the particle masses. The vector f represents the generalized forces and the scalar V(q) represents the potential energy, both of which are functions of the generalized coordinates q.
If M constraints are present, the coordinates must also satisfy M time-independent algebraic equations
where the index j runs from 1 to M. For brevity, these functions gi are grouped into an M-dimensional vector g below. The task is to solve the combined set of differential-algebraic (DAE) equations, instead of just the ordinary differential equations (ODE) of Newton's second law.
This problem was studied in detail by Joseph Louis Lagrange, who laid out most of the methods for solving it.[1] The simplest approach is to define new generalized coordinates that are unconstrained; this approach eliminates the algebraic equations and reduces the problem once again to solving an ordinary differential equation. Such an approach is used, for example, in describing the motion of a rigid body; the position and orientation of a rigid body can be described by six independent, unconstrained coordinates, rather than describing the positions of the particles that make it up and the constraints among them that maintain their relative distances. The drawback of this approach is that the equations may become unwieldy and complex; for example, the mass matrix M may become non-diagonal and depend on the generalized coordinates.
A second approach is to introduce explicit forces that work to maintain the constraint; for example, one could introduce strong spring forces that enforce the distances among mass points within a "rigid" body. The two difficulties of this approach are that the constraints are not satisfied exactly, and the strong forces may require very short time-steps, making simulations inefficient computationally.
A third approach is to use a method such as Lagrange multipliers or projection to the constraint manifold to determine the coordinate adjustments necessary to satisfy the constraints. Finally, there are various hybrid approaches in which different sets of constraints are satisfied by different methods, e.g., internal coordinates, explicit forces and implicit-force solutions.
The simplest approach to satisfying constraints in energy minimization and molecular dynamics is to represent the mechanical system in so-called internal coordinates corresponding to unconstrained independent degrees of freedom of the system. For example, the dihedral angles of a protein are an independent set of coordinates that specify the positions of all the atoms without requiring any constraints. The difficulty of such internal-coordinate approaches is twofold: the Newtonian equations of motion become much more complex and the internal coordinates may be difficult to define for cyclic systems of constraints, e.g., in ring puckering or when a protein has a disulfide bond.
The original methods for efficient recursive energy minimization in internal coordinates were developed by Gō and coworkers.[2][3]
Efficient recursive, internal-coordinate constraint solvers were extended to molecular dynamics.[4][5] Analogous methods were applied later to other systems.[6][7][8]
In most of molecular dynamics simulations that use constraint algorithms, constraints are enforced using the method of Lagrange multipliers. Given a set of n linear (holonomic) constraints at the time t,
where 






x


k
α


(
t
)



{\displaystyle \scriptstyle \mathbf {x} _{k\alpha }(t)}

 and 






x


k
β


(
t
)



{\displaystyle \scriptstyle \mathbf {x} _{k\beta }(t)}

 are the positions of the two particles involved in the kth constraint at the time t and 




d

k




{\displaystyle d_{k}}

 is the prescribed inter-particle distance.
The forces due to these constraints are added in the equations of motion, resulting in, for each of the N particles in the system
Adding the constraint forces does not change the total energy, as the net work done by the constraint forces (taken over the set of particles that the constraints act on) is zero.
From integrating both sides of the equation with respect to the time, the constrainted coordinates of particles at the time, 



t
+
Δ
t


{\displaystyle t+\Delta t}

, are given,
where 








x

^




i


(
t
+
Δ
t
)


{\displaystyle {\hat {\mathbf {x} }}_{i}(t+\Delta t)}

 is the unconstrained (or uncorrected) position of the ith particle after integrating the unconstrained equations of motion.
To satisfy the constraints 




σ

k


(
t
+
Δ
t
)


{\displaystyle \sigma _{k}(t+\Delta t)}

 in the next timestep, the Lagrange multipliers should be determined as the following equation,
This implies solving a system of 



n


{\displaystyle n}

 non-linear equations
simultaneously for the 



n


{\displaystyle n}

 unknown Lagrange multipliers 




λ

k




{\displaystyle \lambda _{k}}

.
This system of 



n


{\displaystyle n}

 non-linear equations in 



n


{\displaystyle n}

 unknowns is commonly solved using Newton–Raphson method where the solution vector 





λ
_




{\displaystyle {\underline {\lambda }}}

 is updated using
where 





J


σ




{\displaystyle \mathbf {J} _{\sigma }}

 is the Jacobian of the equations σk:
Since not all particles contribute to all of constraints, 





J


σ




{\displaystyle \mathbf {J} _{\sigma }}

 is a block matrix and can be solved individually to block-unit of the matrix. In other words, 





J


σ




{\displaystyle \mathbf {J} _{\sigma }}

 can be solved individually for each molecule.
Instead of constantly updating the vector 





λ
_




{\displaystyle {\underline {\lambda }}}

, the iteration can be started with 






λ
_



(
0
)


=

0



{\displaystyle {\underline {\lambda }}^{(0)}=\mathbf {0} }

, resulting in simpler expressions for 




σ

k


(
t
)


{\displaystyle \sigma _{k}(t)}

 and 






∂

σ

k


(
t
)


∂

λ

j







{\displaystyle {\frac {\partial \sigma _{k}(t)}{\partial \lambda _{j}}}}

. In this case
then 



λ


{\displaystyle \lambda }

 is updated to
After each iteration, the unconstrained particle positions are updated using
The vector is then reset to

The above procedure is repeated until the solution of constraint equations, 




σ

k


(
t
+
Δ
t
)


{\displaystyle \sigma _{k}(t+\Delta t)}

, converges to a prescribed tolerance of a numerical error.
Although there are a number of algorithms to compute the Lagrange multipliers, these difference is rely only on the methods to solve the system of equations. For this methods, quasi-Newton methods are commonly used.
The SETTLE algorithm[9] solves the system of non-linear equations analytically for 



n
=
3


{\displaystyle n=3}

 constraints in constant time. Although it does not scale to larger numbers of constraints, it is very often used to constrain rigid water molecules, which are present in almost all biological simulations and are usually modelled using three constraints (e.g. SPC/E and TIP3P water models).
The SHAKE algorithm was first developed for satisfying a bond geometry constraint during molecular dynamics simulations.[10] In SHAKE algorithm, the system of non-linear constraint equations is solved using the Gauss-Seidel method which approximates the solution of the linear system of equations using the Newton-Raphson method;
This amounts to assuming that 





J


σ




{\displaystyle \mathbf {J} _{\sigma }}

 is diagonally dominant and solving the 



k


{\displaystyle k}

th equation only for the 



k


{\displaystyle k}

 unknown. In practice, we compute
for all 



k
=
1
…
n


{\displaystyle k=1\dots n}

 iteratively until the constraint equations 




σ

k


(
t
+
Δ
t
)


{\displaystyle \sigma _{k}(t+\Delta t)}

 are solved to a given tolerance.
The calculation cost of each iteration is 





O


(
n
)


{\displaystyle {\mathcal {O}}(n)}

, and the iterations themselves converge linearly.
A noniterative form of SHAKE was developed later.[11]
Several variants of the SHAKE algorithm exist. Although they differ in how they compute or apply the constraints themselves, the constraints are still modelled using Lagrange multipliers which are computed using the Gauss-Seidel method.
The original SHAKE algorithm is limited to mechanical systems with a tree structure, i.e., no closed loops of constraints. A later extension of the method, QSHAKE (Quaternion SHAKE) was developed to amend this.[12] It works satisfactorily for rigid loops such as aromatic ring systems but fails for flexible loops, such as when a protein has a disulfide bond.[13]
Further extensions include RATTLE,[14] WIGGLE[15] and MSHAKE.[16] RATTLE works the same way as SHAKE,[17] yet using the Velocity Verlet time integration scheme. WIGGLE extends SHAKE and RATTLE by using an initial estimate for the Lagrange multipliers 




λ

k




{\displaystyle \lambda _{k}}

 based on the particle velocities. Finally, MSHAKE computes corrections on the constraint forces, achieving better convergence.
A final modification is the P-SHAKE algorithm[18] for rigid or semi-rigid molecules. P-SHAKE computes and updates a pre-conditioner which is applied to the constraint gradients before the SHAKE iteration, causing the Jacobian 





J


σ




{\displaystyle \mathbf {J} _{\sigma }}

 to become diagonal or strongly diagonally dominant. The thus de-coupled constraints converge much faster (quadratically as opposed to linearly) at a cost of 





O


(

n

2


)


{\displaystyle {\mathcal {O}}(n^{2})}

.
The M-SHAKE algorithm[19] solves the non-linear system of equations using Newton's method directly. In each iteration, the linear system of equations
is solved exactly using an LU decomposition. Each iteration costs 





O


(

n

3


)


{\displaystyle {\mathcal {O}}(n^{3})}

 operations, yet the solution converges quadratically, requiring fewer iterations than SHAKE.
This solution was first proposed in 1986 by Ciccotti and Ryckaert[20] under the title "the matrix method", yet differed in the solution of the linear system of equations. Ciccotti and Ryckaert suggest inverting the matrix 





J


σ




{\displaystyle \mathbf {J} _{\sigma }}

 directly, yet doing so only once, in the first iteration. The first iteration then costs 





O


(

n

3


)


{\displaystyle {\mathcal {O}}(n^{3})}

 operations, whereas the following iterations cost only 





O


(

n

2


)


{\displaystyle {\mathcal {O}}(n^{2})}

 operations (for the matrix-vector multiplication). This improvement comes at a cost though, since the Jacobian is no longer updated, convergence is only linear, albeit at a much faster rate than for the SHAKE algorithm.
Several variants of this approach based on sparse matrix techniques were studied by Barth et al..[21]
The SHAPE algorithm[22] is a multicenter analog of SHAKE for constraining rigid bodies of three or more centers. Like SHAKE, an unconstrained step is taken and then corrected by directly calculating and applying the rigid body rotation matrix that satisfies:
This approach involves a single 3x3 matrix diagonalization followed by three or four rapid Newton iterations to determine the rotation matrix. SHAPE provides the identical trajectory that is provided with fully converged iterative SHAKE, yet it is found to be more efficient and more accurate than SHAKE when applied to systems involving three or more centers. It extends the ability of SHAKE like constraints to linear systems with three or more atoms, planar systems with four or more atoms, and to significantly larger rigid structures where SHAKE is intractable. It also allows rigid bodies to be linked with one or two common centers (e.g. peptide planes) by solving rigid body constraints iteratively in the same basic manner that SHAKE is used for atoms involving more than one SHAKE constraint.
An alternative constraint method, LINCS (Linear Constraint Solver) was developed in 1997 by Hess, Bekker, Berendsen and Fraaije,[23] and was based on the 1986 method of Edberg, Evans and Morriss (EEM),[24] and a modification thereof by Baranyai and Evans (BE).[25]
LINCS applies Lagrange multipliers to the constraint forces and solves for the multipliers by using a series expansion to approximate the inverse of the Jacobian 





J


σ




{\displaystyle \mathbf {J} _{\sigma }}

:
in each step of the Newton iteration. This approximation only works for matrices with Eigenvalues smaller than 1, making the LINCS algorithm suitable only for molecules with low connectivity.
LINCS has been reported to be 3-4 times faster than SHAKE.[23]
Hybrid methods have also been introduced in which the constraints are divided into two groups; the constraints of the first group are solved using internal coordinates whereas those of the second group are solved using constraint forces, e.g., by a Lagrange multiplier or projection method.[26][27][28] This approach was pioneered by Lagrange,[1] and result in Lagrange equations of the mixed type.[29]
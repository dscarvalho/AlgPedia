ABOUT
In the formal language theory of computer science, left recursion is a special case of recursion where a string is recognized as part of a language by the fact that it decomposes into a string from that same language (on the left) and a suffix (on the right). For instance, 



1
+
2
+
3


{\displaystyle 1+2+3}

 can be recognized as a sum because it can be broken into 



1
+
2


{\displaystyle 1+2}

, also a sum, and 





+
3


{\displaystyle {}+3}

, a suitable suffix.
FULL TEXT
In the formal language theory of computer science, left recursion is a special case of recursion where a string is recognized as part of a language by the fact that it decomposes into a string from that same language (on the left) and a suffix (on the right). For instance, 



1
+
2
+
3


{\displaystyle 1+2+3}

 can be recognized as a sum because it can be broken into 



1
+
2


{\displaystyle 1+2}

, also a sum, and 





+
3


{\displaystyle {}+3}

, a suitable suffix.
In terms of context-free grammar, a nonterminal is left-recursive if the leftmost symbol in one of its productions is itself (in the case of direct left recursion) or can be made itself by some sequence of substitutions (in the case of indirect left recursion).


A grammar is left-recursive if and only if there exists a nonterminal symbol 



A


{\displaystyle A}

 that can derive to a sentential form with itself as the leftmost symbol.[1] Symbolically,
where 




⇒

+




{\displaystyle \Rightarrow ^{+}}

 indicates the operation of making one or more substitutions, and 



α


{\displaystyle \alpha }

 is any sequence of terminal and nonterminal symbols.
Direct left recursion occurs when the definition can be satisfied with only one substitution. It requires a rule of the form
where 



α


{\displaystyle \alpha }

 is a sequence of nonterminals and terminals. For example, the rule
is directly left-recursive. A left-to-right recursive descent parser for this rule might look like
and such code would fall into infinite recursion when executed.
Indirect left recursion occurs when the definition is satisfied via several substitutions. It entails a set of rules following the pattern
where 




β

0


,

β

1


,
…
,

β

n




{\displaystyle \beta _{0},\beta _{1},\ldots ,\beta _{n}}

 are sequences that can each yield the empty string, while 




α

0


,

α

1


,
…
,

α

n




{\displaystyle \alpha _{0},\alpha _{1},\ldots ,\alpha _{n}}

 may be any sequences at all. The derivation
then gives 




A

0




{\displaystyle A_{0}}

 as leftmost in its final sentential form.
Left recursion often poses problems for parsers, either because it leads them into infinite recursion (as in the case of most top-down parsers) or because they expect rules in a normal form that forbids it (as in the case of many bottom-up parsers, including the CYK algorithm). Therefore, a grammar is often preprocessed to eliminate the left recursion.
The general algorithm to remove direct left recursion follows. Several improvements to this method have been made.[2] For a left-recursive nonterminal 



A


{\displaystyle A}

, discard any rules of the form 



A
→
A


{\displaystyle A\rightarrow A}

 and consider those that remain:
where:
Replace these with two sets of productions, one set for 



A


{\displaystyle A}

:
and another set for the fresh nonterminal 




A
′



{\displaystyle A'}

 (often called the "tail" or the "rest"):
Repeat this process until no direct left recursion remains.
As an example, consider the rule set
This could be rewritten to avoid left recursion as
By establishing a topological ordering on nonterminals, the above process can be extended to also eliminate indirect left recursion[citation needed]:
Note that this algorithm is highly sensitive to the nonterminal ordering; optimizations often focus on choosing this ordering well.[clarification needed]
Although the above transformations preserve the language generated by a grammar, they may change the parse trees that witness strings' recognition. With suitable bookkeeping, tree rewriting can recover the originals, but if this step is omitted, the differences may change the semantics of a parse.
Associativity is particularly vulnerable; left-associative operators typically appear in right-associative-like arrangements under the new grammar. For example, starting with this grammar:
the standard transformations to remove left recursion yield the following:
Parsing the string "1 - 2 - 3" with the first grammar in an LALR parser (which can handle left-recursive grammars) would have resulted in the parse tree:
This parse tree groups the terms on the left, giving the correct semantics (1 - 2) - 3.
Parsing with the second grammar gives
which, properly interpreted, signifies 1 + (-2 + (-3)), also correct, but less faithful to the input and much harder to implement for some operators. Notice how terms to the right appear deeper in the tree, much as a right-recursive grammar would arrange them for 1 - (2 - 3).
A formal grammar that contains left recursion cannot be parsed by a LL(k)-parser or other naive recursive descent parser unless it is converted to a weakly equivalent right-recursive form. In contrast, left recursion is preferred for LALR parsers because it results in lower stack usage than right recursion. However, more sophisticated top-down parsers can implement general context-free grammars by use of curtailment. In 2006, Frost and Hafiz described an algorithm which accommodates ambiguous grammars with direct left-recursive production rules.[3] That algorithm was extended to a complete parsing algorithm to accommodate indirect as well as direct left recursion in polynomial time, and to generate compact polynomial-size representations of the potentially exponential number of parse trees for highly ambiguous grammars by Frost, Hafiz and Callaghan in 2007.[4] The authors then implemented the algorithm as a set of parser combinators written in the Haskell programming language.[5]
ABOUT
The α-algorithm is an algorithm used in process mining, aimed at reconstructing causality from a set of sequences of events. It was first put forward by van der Aalst, Weijters and Măruşter.[1] Several extensions or modifications of it have since been presented, which will be listed below.
FULL TEXT
The α-algorithm is an algorithm used in process mining, aimed at reconstructing causality from a set of sequences of events. It was first put forward by van der Aalst, Weijters and Măruşter.[1] Several extensions or modifications of it have since been presented, which will be listed below.
It constructs P/T nets with special properties (workflow nets) from event logs (as might be collected by an ERP system). Each transition in the net corresponds to an observed task.


The algorithm takes a workflow log 



W
⊆

T

∗




{\displaystyle W\subseteq T^{*}}

 as input and results in a workflow net being constructed.
It does so by examining causal relationships observed between tasks. For example, one specific task might always precede another specific task in every execution trace, which would be useful information.
Declaratively, the algorithm can be presented as follows. Three sets of tasks are determined:
Basic ordering relations are determined (




≻

W




{\displaystyle \succ _{W}}

 first, the latter three can be constructed therefrom)
Places are discovered. Each place is identified with a pair of sets of tasks, in order to keep the number of places low.
The flow relation 




F

W




{\displaystyle F_{W}}

 is the union of the following:
The result is
It can be shown [2] that in the case of a complete workflow log generated by a sound SWF net, the net generating it can be reconstructed. Complete means that its 




≻

W




{\displaystyle \succ _{W}}

 relation is maximal. It is not required that all possible traces be present (which would be countably infinite for a net with a loop).
General workflow nets may contain several types of constructs [3] which the α-algorithm cannot rediscover.
Constructing 




Y

W




{\displaystyle Y_{W}}

 takes exponential time in the number of tasks, since 




≻

W




{\displaystyle \succ _{W}}

 is not constrained and arbitrary subsets of 




T

W




{\displaystyle T_{W}}

 must be considered.
for example [4] [5]
ABOUT
In computer science, K-Way Merge Algorithms or Multiway Merges are a specific type of Sequence Merge Algorithms that specialize in taking in multiple sorted lists and merging them into a single sorted list. These merge algorithms generally refer to merge algorithms that take in a number of sorted lists greater than two. 2-Way Merges are referred to as binary merges on the other hand and are also utilized in k-way merge algorithms. K-Way merge algorithms generally find use in sorting algorithms such as Patience Sorting.
FULL TEXT
In computer science, K-Way Merge Algorithms or Multiway Merges are a specific type of Sequence Merge Algorithms that specialize in taking in multiple sorted lists and merging them into a single sorted list. These merge algorithms generally refer to merge algorithms that take in a number of sorted lists greater than two. 2-Way Merges are referred to as binary merges on the other hand and are also utilized in k-way merge algorithms. K-Way merge algorithms generally find use in sorting algorithms such as Patience Sorting.


A 2-Way Merge, or a binary merge, has been studied extensively due to its key role in Merge sort. An example of such is the classic merge that appears frequently in merge sort examples. The classic merge outputs the data item with the lowest key at each step; given some sorted lists, it produces a sorted list containing all the elements in any of the input lists, and it does so in time proportional to the sum of the lengths of the input lists. There are algorithms that exist that can operate in better than linear times such as the Hwang-Lin Merging Algorithm.[1]
Assume, that we have two arrays A[0..m-1] and B[0..n-1] that are sorted in ascending order and we want to merge them into an array C[0..m+n-1] with the same order.
If the number of sorted lists k is greater than 2, the 2-Way Merge function found in merge sort can still be used to merge everything into a single sorted list.
Let D={n1, ... , nk} be the set of sequences to be merged. Pick ni, nj∈ D and then merge them together using the merge function. The new set D is then D' = (D - {ni, nj}) ∪ {ni+nj}. This process is repeated until |D| = 1. The question then becomes how to pick ni and nj. How the merge algorithm picks ni and nj determines the cost of the overall algorithm. The worst case running time for this algorithm reaches O(k2 • n).
The optimal merge pattern is found by utilizing a Greedy algorithm that selects the two shortest lists at each time to merge. This technique is similar to the one used in Huffman coding. The algorithm picks ni, nj∈ D such that |n| ≥ |ni| and |n| ≥ |nj| ∀ n∈ D.[3]
On the optimal merge pattern on the hand can reduce the running time to O(k • n • log k).[4] By choosing the shortest lists to merge each time, this lets the algorithm minimize how many times it is necessary to copy the same value into each new merged list.
The Ideal Merge technique is another merge method for merging greater than two lists except it does not use the 2-Way merge technique. The ideal merging technique was discussed and saw use as a part of UnShuffle Sort.[5]
Given a group of sorted lists S that we want to merge into list S', the algorithm is as follows:
The head elements are generally stored in a priority queue. Depending on how the priority queue is implemented, the running time can vary. If ideal merge keeps its information in a sorted list, then inserting a new head element to the list would be done through a Linear search and the running time will be Θ(M • N) where N is the total number of elements in the sorted lists, and M is the total number of sorted lists.
On the other hand, if the sorted items in a heap, then the running time becomes Θ(N log M).
As an example, the above technique can be implemented using a binary tree for its priority queue.[6] This can help limit the number of comparisons between the element heads. The binary tree is built containing the results of comparing the head of each array. The topmost node of the binary tree is then popped off and its leaf is refilled with the next element in its array.
As an example, let's say we have 4 sorted arrays:[7]
{5, 10, 15, 20}
{10, 13, 16, 19}
{2, 19, 26, 40}
{18, 22, 23, 24}
We start with the heads of each array and then build a binary tree from there.
The nodes from each array are compared to each other, before the value 2 is found as the lowest list head element. That value is then popped off, and its leaf is refilled with the next value in the list.
The value 2 is repopulated by the next value in the sorted list, 19. The comparisons end with 5 being the smallest value, and thus the next value to be popped off. This continues until all of the sorted lists are empty.
K-way merges find greater use in external sorting procedures. External sorting algorithms are a class of sorting algorithms that can handle massive amounts of data. External sorting is required when the data being sorted do not fit into the main memory of a computing device (usually RAM) and instead they must reside in the slower external memory (usually a hard drive). K-way merge algorithms usually take place in the second stage of external sorting algorithms, much like they do for merge sort.
A multiway merge like that discussed in ideal merge allows for the files outside of memory to be merged in fewer passes than in a binary merge. If there are 6 runs that need be merged together then a binary merge would need to take 3 merge passes, as opposed to a 6-way merges single merge pass. This reduction of merge passes is especially important considering the large amount of information that is usually being sorted in the first place, allowing for greater speed-ups while also reducing the amount of accesses to slower memory.
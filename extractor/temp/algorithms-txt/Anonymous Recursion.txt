ABOUT
In computer science, anonymous recursion is recursion which does not explicitly call a function by name. This can be done either explicitly, by using a higher-order function – passing in a function as an argument and calling it – or implicitly, via reflection features which allow one to access certain functions depending on the current context, especially "the current function" or sometimes "the calling function of the current function".
FULL TEXT
In computer science, anonymous recursion is recursion which does not explicitly call a function by name. This can be done either explicitly, by using a higher-order function – passing in a function as an argument and calling it – or implicitly, via reflection features which allow one to access certain functions depending on the current context, especially "the current function" or sometimes "the calling function of the current function".
In programming practice, anonymous recursion is notably used in JavaScript, which provides reflection facilities to support it. In general programming practice, however, this is considered poor style, and recursion with named functions is suggested instead. Anonymous recursion via explicitly passing functions as arguments is possible in any language that supports functions as arguments, though this is rarely used in practice, as it is longer and less clear than explicitly recursing by name.
In theoretical computer science, anonymous recursion is important, as it shows that one can implement recursion without requiring named functions. This is particularly important for the lambda calculus, which has anonymous unary functions, but is able to compute any recursive function. This anonymous recursion can be produced generically via fixed-point combinators.


Anonymous recursion is primarily of use in allowing recursion for anonymous functions, particularly when they form closures or are used as callbacks, to avoid having to bind the name of the function.
Anonymous recursion primarily consists of calling "the current function", which results in direct recursion. Anonymous indirect recursion is possible, such as by calling "the caller (the previous function)", or, more rarely, by going further up the call stack, and this can be chained to produce mutual recursion. The self-reference of "the current function" is a functional equivalent of the "this" keyword in object-oriented programming, allowing one to refer to the current context.
Anonymous recursion can also be used for named functions, rather that calling them by name, say to specify that one is recursing on the current function, or to allow one to rename the function without needing to change the name where it calls itself. However, as a matter of programming style this is generally not done.
The usual alternative is to use named functions and named recursion. Given an anonymous function, this can be done either by binding a name to the function, as in named function expressions in JavaScript, or by assigning the function to a variable and then calling the variable, as in function statements in JavaScript. Since languages that allow anonymous functions generally allow assigning these functions to variables (if not first-class functions), many languages do not provide a way to refer to the function itself, and explicitly reject anonymous recursion; examples include Go.[1]
For example, in JavaScript the factorial function can be defined via anonymous recursion as such:[2]
Rewritten to use a named function expression yields:
Even without mechanisms to refer to the current function or calling function, anonymous recursion is possible in a language that allows functions as arguments. This is done by adding another parameter to the basic recursive function and using this parameter as the function for the recursive call. This creates a higher-order function, and passing this higher function itself allows anonymous recursion within the actual recursive function. This can be done purely anonymously by applying a fixed-point combinator to this higher order function. This is mainly of academic interest, particularly to show that the lambda calculus has recursion, as the resulting expression is significantly more complicated than the original named recursive function. Conversely, the use of fixed-pointed combinators may be generically referred to as "anonymous recursion", as this is a notable use of them, though they have other applications.[3][4]
This is illustrated below using Python. First, a standard named recursion:
Using a higher-order function so the top-level function recurses anonymously on an argument, but still needing the standard recursive function as an argument:
We can eliminate the standard recursive function by passing the function argument into the call:
The second line can be replaced by a generic higher-order function called a combinator:
Written anonymously:[5]
In the lambda calculus, which only uses functions of a single variable, this can be done via the Y combinator. First make the higher-order function of two variables be a function of a single variable, which directly returns a function, by currying:
There are two "applying a higher order function to itself" operations here: f(f) in the first line and fact1(fact1) in the second. Factoring out the second double application into a combinator yields:
Factoring out the other double application yields:
Combining the two combinators into one yields the Y combinator:
Expanding out the Y combinator yields:
Combining these yields a recursive definition of the factorial in lambda calculus (anonymous functions of a single variable):[6]
In JavaScript, the current function is accessible via arguments.callee, while the calling function is accessible via arguments.caller. These allow anonymous recursion, such as in this implementation of the factorial:[2]
Starting with Perl 5.16, the current subroutine is accessible via the __SUB__ token, which returns a reference to the current subroutine, or undef outside a subroutine.[7] This allows anonymous recursion, such as in the following implementation of the factorial:
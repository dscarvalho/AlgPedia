ABOUT
this, self, and Me are keywords used in some computer programming languages to refer to the object, class, or other entity that the currently running code is part of. The entity referred to by these keywords thus depends on the execution context (such as which object is having its method called). Different programming languages use these keywords in slightly different ways. In languages where a keyword like "this" is mandatory, the keyword is the only way to access data and methods stored in the current object. Where optional, they can disambiguate variables and functions with the same name.
FULL TEXT
this, self, and Me are keywords used in some computer programming languages to refer to the object, class, or other entity that the currently running code is part of. The entity referred to by these keywords thus depends on the execution context (such as which object is having its method called). Different programming languages use these keywords in slightly different ways. In languages where a keyword like "this" is mandatory, the keyword is the only way to access data and methods stored in the current object. Where optional, they can disambiguate variables and functions with the same name.


In many object-oriented programming languages, this (also called self or Me) is a variable that is used in instance methods to refer to the object on which they are working. C++ and languages which derive in style from it (such as Java, C#, D, and PHP) generally use this. Smalltalk and others, such as Object Pascal, Perl, Python, Ruby, Objective-C, DataFlex and Swift, use self. Microsoft's Visual Basic uses Me.
The concept is similar in all languages: this is usually an immutable reference or pointer which refers to the current object; the current object often being the code that acts as 'parent' to the property, method, sub-routine or function that contains the this keyword. After an object is properly constructed, or instantiated, this is always a valid reference. Some languages require it explicitly; others use lexical scoping to use it implicitly to make symbols within their class visible. Or alternatively, the current object referred to by this may be an independent code object that has called the function or method containing the keyword this. Such a thing happens, for example, when a Javascript event handler attached to an HTML tag in a web page calls a function containing the keyword this stored in the global space outside the document object; in that context, this will refer to the page element within the document object, not the enclosing window object.[1]
In some languages, for example C++ and Java, this or self is a keyword, and the variable automatically exists in instance methods. In others, for example Python and Perl 5, the first parameter of an instance method is such a reference. It needs to be specified explicitly. In that case, the parameter need not necessarily be named this or self; it can be named freely by the programmer like any other parameter. However, by informal convention, the first parameter of an instance method in Perl or Python is named self.
Static methods in C++ or Java are not associated with instances but classes, and so cannot use this, because there is no object. In other languages, such as Python, Ruby, Smalltalk, Objective-C, or Swift, the method is associated with a class object that is passed as this, and they are called class methods.
When lexical scoping is used to infer this, the use of this in code, while not illegal, may raise warning bells to a maintenance programmer, although there are still legitimate uses of this in this case, such as referring to instance variables hidden by local variables of the same name, or if the method wants to return a reference to the current object, i.e. this, itself.
In some compilers (for example GCC), pointers to C++ instance methods can be directly cast to a pointer of another type, with an explicit this pointer parameter.[2]
The dispatch semantics of this, namely that method calls on this are dynamically dispatched, is known as open recursion, and means that these methods can be overridden by derived classes or objects. By contrast, direct named recursion or anonymous recursion of a function uses closed recursion, with early binding. For example, in the following Perl code for the factorial, the token __SUB__ is a reference to the current function:
By contrast, in C++ (using an explicit this for clarity, though not necessary) the this binds to the object itself, but if the class method was declared "virtual" i.e. polymorphic in the base, it's resolved via dynamic dispatch (late binding) so that derived classes can override it.
This example is artificial, since this is direct recursion, so overriding the factorial method would override this function; more natural examples are when a method in a derived class calls the same method in a base class, or in cases of mutual recursion.[3][4]
The fragile base class problem has been blamed on open recursion, with the suggestion that invoking methods on this default to closed recursion (static dispatch, early binding) rather than open recursion (dynamic dispatch, late binding), only using open recursion when it is specifically requested; external calls (not using this) would be dynamically dispatched as usual.[5][6] The way this is solved in practice in the JDK is through a certain programmer discipline; this discipline has been formalized by C. Ruby and G. T. Leavens; it basically consists of the following rules:[7]
Early versions of C++ would let the this pointer be changed; by doing so a programmer could change which object a method was working on. This feature was eventually removed, and now this in C++ is an r-value.[8]
Early versions of C++ did not include references and it has been suggested that had they been so in C++ from the beginning, this would have been a reference, not a pointer.[9]
C++ lets objects destroy themselves with the source code statement: delete this.
The keyword this is a Java language keyword that represents the current instance of the class in which it appears. It is used to access class variables and methods.
Since all instance methods are virtual in Java, this can never be null.[10]
The keyword this in C# works the same way as in Java, for reference types. However, within C# value types, this has quite different semantics, being similar to an ordinary mutable variable reference, and can even occur on the left side of an assignment.
One use of this in C# is to allow reference to an outer field variable within a method that contains a local variable that has the same name. In such a situation, for example, the statement var n = localAndFieldname; within the method will assign the type and value of the local variable localAndFieldname to n, whereas the statement var n = this.localAndFieldname; will assign the type and value of the outer field variable to n.[11]
In D this in a class, struct or union method refers to an immutable reference of the instance of the enclosing aggregate. Classes are reference types, structs and unions are value types. In the first version of D, the keyword this is used as a pointer to the instance of the object the method is bound to, while in D2 it has the character of an implicit ref function argument.
In the programming language Dylan, which is an object-oriented language that supports multimethods and doesn't have a concept of this, sending a message to an object is still kept in the syntax. The two forms below work in the same way; the differences are just syntactic sugar.
and
Within a class text, the current type is the type obtained from the current class. Within features (routines, commands and queries) of a class, one may use the keyword Current to reference the current class and its features. The use of the keyword Current is optional as the keyword Current is implied by simply referring to the name of the current class feature openly. For example: One might have a feature `foo' in a class MY_CLASS and refer to it by:
[12]
Line #10 (above) has the implied reference to Current by the call to simple `foo'.
Line #10 (below) has the explicit reference to Current by the call to `Current.foo'.
Either approach is acceptable to the compiler, but the implied version (e.g. xÂ := foo) is preferred as it is less verbose.
As with other languages, there are times when the use of the keyword Current is mandated, such as:
In the case of the code above, the call on line #11 to make_with_something is passing the current class by explicitly passing the keyword Current.
In JavaScript, which is a programming or scripting language used extensively in web browsers, this is an important keyword, although what it evaluates to depends on where it is used.
To work around the different meaning of this in nested functions such as DOM event handlers, it is a common idiom in JavaScript to save the this reference of the calling object in a variable (commonly called that or self), and then use the variable to refer to the calling object in nested functions.
For example:
In Python, there is no keyword for this. When a member function is called on an object, it invokes the member function with the same name on the object's class object, with the object automatically bound to the first argument of the function. Thus, the obligatory first parameter of instance methods serves as this; this parameter is conventionally named self, but can be named anything.
In class methods (created with the classmethod decorator), the first argument refers to the class object itself, and is conventionally called cls; these are primarily used for inheritable constructors,[16] where the use of the class as a parameter allows subclassing the constructor. In static methods (created with the staticmethod decorator), no special first argument exists.
The Self language is named after this use of "self".
Self is strictly used within methods of a class. Another way to refer to Self is to use ::.
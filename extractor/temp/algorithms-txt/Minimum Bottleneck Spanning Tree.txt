ABOUT
In mathematics, a minimum bottleneck spanning tree (MBST) in an undirected graph is a spanning tree in which the most expensive edge is as cheap as possible. A bottleneck edge is the highest weighted edge in a spanning tree. A spanning tree is a minimum bottleneck spanning tree if the graph does not contain a spanning tree with a smaller bottleneck edge weight.[1] For a directed graph, a similar problem is known as Minimum Bottleneck Spanning Arborescence (MBSA).
FULL TEXT
In mathematics, a minimum bottleneck spanning tree (MBST) in an undirected graph is a spanning tree in which the most expensive edge is as cheap as possible. A bottleneck edge is the highest weighted edge in a spanning tree. A spanning tree is a minimum bottleneck spanning tree if the graph does not contain a spanning tree with a smaller bottleneck edge weight.[1] For a directed graph, a similar problem is known as Minimum Bottleneck Spanning Arborescence (MBSA).


In an undirected graph G(V, E) and a function w : E → R, let S be the set of all spanning trees Ti. Let B(Ti) be the maximum weight edge for any spanning tree Ti. We define subset of minimum bottleneck spanning trees S' such that for every Tj ∈ S' and Tk ∈ S we have B(Tj) ≤ B(Tk) for all i and k.[2]
The graph on the right is an example of MBST, the red edges in the graph form a MBST of G(V, E).
An arborescence of graph G is a directed tree of G which contains a directed path from a specified node L to each node of a subset V’ of V \ {L}. Node L is called the root of arborescence. An arborescence is a spanning arborescence if V’ = V \ {L}. MBST in this case is a spanning arborescence with the minimum bottleneck edge. An MBST in this case is called a Minimum Bottleneck Spanning Arborescence (MBSA).
The graph on the right is an example of MBSA, the red edges in the graph form a MBSA of G(V, E).
A MST (or minimum spanning tree) is necessarily a MBST, but a MBST is not necessarily a MST.[citation needed]
Camerini proposed[3] an algorithm used to obtain a minimum bottleneck spanning tree (MBST) in a given undirected, connected, edge-weighted graph in 1978. It half divides edges into two sets. The weights of edges in one set are no more than that in the other. If a spanning tree exists in subgraph composed solely with edges in smaller edges set, it then computes a MBST in the subgraph, a MBST of the subgraph is exactly a MBST of the original graph. If a spanning tree does not exist, it combines each disconnected component into a new super vertex, then computes a MBST in the graph formed by these super vertices and edges in the larger edges set. A forest in each disconnected component is part of a MBST in original graph. Repeat this process until two (super) vertices are left in the graph and a single edge with smallest weight between them is to be added. A MBST is found consisting of all the edges found in previous steps.[4]
The procedure has two input parameters. G is a graph, w is a weights array of all edges in the graph G.[5]
In the above (GA)η is the subgraph composed of super vertices (by regarding vertices in a disconnected component as one) and edges in A.
The algorithm is running in O(E) time, where E is the number of edges. This bound is achieved as follows:
In the following example green edges are used to form a MBST and dashed red areas indicate super vertices formed during the algorithm steps.
There are two algorithms available for directed graph: Camerini’s algorithm for finding MBSA and another from Gabow and Tarjan.[4]
For a directed graph, Camerini’s algorithm focuses on finding the set of edges that would have its maximum cost as the bottleneck cost of the MBSA. This is done by partitioning the set of edges E into two sets A and B and maintaining the set T that is the set in which it is known that GT does not have a spanning arborescence, increasing T by B whenever the maximal arborescence of G(B ∪ T) is not a spanning arborescence of G, otherwise we decrease E by A. Total total time complexity is O(E log E).[3][4]
Gabow and Tarjan provided a modification of Dijkstra's algorithm for single-source shortest path that produces an MBSA. Their algorithm runs in O(E + V log V) time if Fibonacci heap used.[6]
The following example shows that how the algorithm works.
Another approach proposed by Tarjan and Gabow with bound of O(E log* V) for sparse graphs, in which it is very similar to Camerini’s algorithm for MBSA, but rather than partitioning the set of edges into two sets per each iteration, K(i) was introduced in which i is the number of splits that has taken place or in other words the iteration number, and K(i) is an increasing function that denotes the number of partitioned sets that one should have per iteration. K(i) = 2k(i − 1) with k(1) = 2. The algorithm finds λ* in which it is the value of the bottleneck edge in any MBSA. After λ* is found any spanning arborescence in G(λ*) is an MBSA in which G(λ*) is the graph where all its edge’s costs are ≤ λ*.[4][6]
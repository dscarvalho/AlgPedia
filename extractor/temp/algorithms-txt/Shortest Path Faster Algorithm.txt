ABOUT
The Shortest Path Faster Algorithm (SPFA) is an improvement of the Bellman–Ford algorithm which computes single-source shortest paths in a weighted directed graph. The algorithm is believed to work well on random sparse graphs and is particularly suitable for graphs that contain negative-weight edges.[1] However, the worst-case complexity of SPFA is the same as that of Bellman–Ford, so for graphs with nonnegative edge weights Dijkstra's algorithm is preferred.[2] The SPFA algorithm was published in 1994 by Fanding Duan.[3]
FULL TEXT
The Shortest Path Faster Algorithm (SPFA) is an improvement of the Bellman–Ford algorithm which computes single-source shortest paths in a weighted directed graph. The algorithm is believed to work well on random sparse graphs and is particularly suitable for graphs that contain negative-weight edges.[1] However, the worst-case complexity of SPFA is the same as that of Bellman–Ford, so for graphs with nonnegative edge weights Dijkstra's algorithm is preferred.[2] The SPFA algorithm was published in 1994 by Fanding Duan.[3]


Given a weighted directed graph G = (V, E) and a source vertex s, the SPFA algorithm finds the shortest path from s to each vertex v in the graph. The length of the shortest path from s to v is stored in d(v) for each vertex v.
The basic idea of SPFA is the same as Bellman–Ford algorithm in that each vertex is used as a candidate to relax its adjacent vertices. The improvement over the latter is that instead of trying all vertices blindly, SPFA maintains a queue of candidate vertices and adds a vertex to the queue only if that vertex is relaxed. This process repeats until no more vertex can be relaxed.
Below is the pseudo-code of the algorithm.[4] Here Q is a first-in, first-out queue of candidate vertices, and w(u, v) is the edge weight of (u, v).
The algorithm can also be applied to an undirected graph by replacing each undirected edge with two directed edge of opposite directions.
http://wcipeg.com/wiki/Shortest_Path_Faster_Algorithm
For a random graph, the empirical average time complexity is O(|E|).[4][3]
Following is a way to construct a data to defeat this algorithm (without queue optimization???).[1] Suppose one wants the shortest path from vertex 1 to vertex n. Then we can add edge (i, i + 1) with a small random weight for 1 ≤ i < n (thus the shortest path should be 1-2-...-n), and randomly add 4n other heavy edges. For this case, the so-called SPFA algorithm will be very slow.
The performance of the algorithm is strongly determined by the order in which candidate vertices are used to relax other vertices. In fact, if Q is a priority queue, than the algorithm pretty much resembles Dijkstra's. However, since a priority queue is not used here, two techniques are sometimes employed to improve the quality of the queue, which in turn improves the average-case performance (but not the worst-case performance). Both techniques rearranges the order of elements in Q so that vertices closer to the source are processed first. Therefore, when implementing these techniques, Q is no longer a first-in, first-out queue, but rather a normal doubly linked list or double-ended queue.
Small Label First (SLF) technique. In line 11, instead of always pushing vertex v to the end of the queue, we compare d(v) to d(front(Q)), and insert v to the front of the queue if d(v) is smaller. The pseudo-code for this technique is (after pushing v to the end of the queue in line 11):
Large Label Last (LLL) technique. After line 11, we update the queue so that the first element is smaller than the average, and any element larger than the average is moved to the end of the queue. The pseudo-code is:
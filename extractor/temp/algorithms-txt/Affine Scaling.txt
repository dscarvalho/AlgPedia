ABOUT
In mathematical optimization, affine scaling is an algorithm for solving linear programming problems. Specifically, it is an interior point method, discovered by Soviet mathematician I. I. Dikin in 1967 and reinvented in the U.S. in the mid-1980s.
FULL TEXT
In mathematical optimization, affine scaling is an algorithm for solving linear programming problems. Specifically, it is an interior point method, discovered by Soviet mathematician I. I. Dikin in 1967 and reinvented in the U.S. in the mid-1980s.


Affine scaling has a history of multiple discovery. It was first published by I. I. Dikin in the 1967 Doklady Akademii Nauk SSSR, followed by a proof of its convergence in 1974.[1] Dikin's work went largely unnoticed until the 1984 discovery of Karmarkar's algorithm, the first practical polynomial time algorithm for linear programming. The importance and complexity of Karmarkar's method prompted mathematicians to search for a simpler version.
Several groups then independently came up with a variant of Karmarkar's algorithm. E. R. Barnes at IBM,[2] a team led by R. J. Vanderbei at AT&T,[3] and several others replaced the projective transformations that Karmarkar used by affine ones. After a few years, it was realized that the "new" affine scaling algorithms were in fact reinventions of the decades-old results of Dikin.[1][4] Of the re-discoverers, only Barnes and Vanderbei et al. managed to produce an analysis of affine scaling's convergence properties. Karmarkar, who had also came with affine scaling in this timeframe, mistakenly believed that it converged as quickly as his own algorithm.[5]:346
Affine scaling works in two phases, the first of which finds a feasible point from which to start optimizing, while the second does the actual optimization while staying strictly inside the feasible region.
Both phases solve linear programs in equality form, viz.
These problems are solved using an iterative method, which conceptually proceeds by plotting a trajectory of points strictly inside the feasible region of a problem, computing projected gradient descent steps in a re-scaled version of the problem, then scaling the step back to the original problem. The scaling ensures that the algorithm can continue to do large steps even when the point under consideration is close to the feasible region's boundary.[5]:337
Formally, the iterative method at the heart of affine scaling takes as inputs A, b, c, an initial guess x0 > 0 that is strictly feasible (i.e., Ax0 = b), a tolerance ε and a stepsize β. It then proceeds by iterating[1]:111
Phase I, the initialization, solves an auxiliary problem with an additional variable u and uses the result to derive an initial point for the original problem. Let x0 be an arbitrary, strictly positive point; it need not be feasible for the original problem. The infeasibility of x0 is measured by the vector
If v = 0, x0 is feasible. If it is not, phase I solves the auxiliary problem
This problem has the right form for solution by the above iterative algorithm,[a] and
is a feasible initial point for it. Solving the auxiliary problem gives
If u* = 0, then x* = 0 is feasible in the original problem (though not necessarily strictly interior), while if u* > 0, the original problem is infeasible.[5]:343
While easy to state, affine scaling was found hard to analyze. Its convergence depends on the step size, β. For step sizes β ≤ 2/3, Vanderbei's variant of affine scaling has been proven to converge, while for β > 0.995, an example problem is known that converges to a suboptimal value.[5]:342 Other variants of the algorithm have been shown to exhibit chaotic behavior even on small problems when β > 2/3.[6][7]